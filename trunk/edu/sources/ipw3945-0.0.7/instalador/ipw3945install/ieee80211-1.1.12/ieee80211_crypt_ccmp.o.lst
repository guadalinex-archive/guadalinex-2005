GAS LISTING  			page 1


   1              	.file "ieee80211_crypt_ccmp.c"
   9              	.Ltext0:
  10              	.section .modinfo,"a",@progbits
  13              	__mod_author29:
  14 0000 61757468 	.string "author=Jouni Malinen"
  14      6F723D4A 
  14      6F756E69 
  14      204D616C 
  14      696E656E 
  15 0015 00000000 	.align 32
  15      00000000 
  15      000000
  18              	__mod_description30:
  19 0020 64657363 	.string "description=Host AP crypt: CCMP"
  19      72697074 
  19      696F6E3D 
  19      486F7374 
  19      20415020 
  22              	__mod_license31:
  23 0040 6C696365 	.string "license=GPL"
  23      6E73653D 
  23      47504C00 
  24              	.text
  26              	ieee80211_ccmp_aes_encrypt:
  27              	.LFB687:
  28              	.file 1 "/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c"
   1:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** /*
   2:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c ****  * Host AP crypt: host-based CCMP encryption implementation for Host AP driver
   3:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c ****  *
   4:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c ****  * Copyright (c) 2003-2004, Jouni Malinen <jkmaline@cc.hut.fi>
   5:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c ****  *
   6:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c ****  * This program is free software; you can redistribute it and/or modify
   7:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c ****  * it under the terms of the GNU General Public License version 2 as
   8:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c ****  * published by the Free Software Foundation. See README and COPYING for
   9:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c ****  * more details.
  10:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c ****  */
  11:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 
  12:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** #include <linux/config.h>
  13:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** #include <linux/module.h>
  14:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** #include <linux/init.h>
  15:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** #include <linux/slab.h>
  16:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** #include <linux/random.h>
  17:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** #include <linux/skbuff.h>
  18:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** #include <linux/netdevice.h>
  19:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** #include <linux/if_ether.h>
  20:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** #include <linux/if_arp.h>
  21:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** #include <asm/string.h>
  22:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** #include <linux/wireless.h>
  23:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 
  24:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** #include <net/ieee80211.h>
  25:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 
  26:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** #include <linux/crypto.h>
  27:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** #include <asm/scatterlist.h>
  28:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 
  29:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** MODULE_AUTHOR("Jouni Malinen");
  30:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** MODULE_DESCRIPTION("Host AP crypt: CCMP");
  31:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** MODULE_LICENSE("GPL");
GAS LISTING  			page 2


  32:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 
  33:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** #define AES_BLOCK_LEN 16
  34:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** #define CCMP_HDR_LEN 8
  35:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** #define CCMP_MIC_LEN 8
  36:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** #define CCMP_TK_LEN 16
  37:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** #define CCMP_PN_LEN 6
  38:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 
  39:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** struct ieee80211_ccmp_data {
  40:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	u8 key[CCMP_TK_LEN];
  41:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	int key_set;
  42:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 
  43:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	u8 tx_pn[CCMP_PN_LEN];
  44:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	u8 rx_pn[CCMP_PN_LEN];
  45:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 
  46:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	u32 dot11RSNAStatsCCMPFormatErrors;
  47:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	u32 dot11RSNAStatsCCMPReplays;
  48:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	u32 dot11RSNAStatsCCMPDecryptErrors;
  49:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 
  50:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	int key_idx;
  51:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 
  52:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	struct crypto_tfm *tfm;
  53:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 
  54:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	/* scratch buffers for virt_to_page() (crypto API) */
  55:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	u8 tx_b0[AES_BLOCK_LEN], tx_b[AES_BLOCK_LEN],
  56:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	    tx_e[AES_BLOCK_LEN], tx_s0[AES_BLOCK_LEN];
  57:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	u8 rx_b0[AES_BLOCK_LEN], rx_b[AES_BLOCK_LEN], rx_a[AES_BLOCK_LEN];
  58:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** };
  59:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 
  60:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** static void ieee80211_ccmp_aes_encrypt(struct crypto_tfm *tfm,
  61:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 				       const u8 pt[16], u8 ct[16])
  62:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** {
  29              	.loc 1 62 0
  30 0000 56       	pushl %esi
  31              	.LCFI0:
  32 0001 53       	pushl %ebx
  33              	.LCFI1:
  34 0002 83EC20   	subl $32,%esp
  35              	.LCFI2:
  36              	.loc 1 62 0
  37 0005 8B542430 	movl 48(%esp),%edx
  63:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	struct scatterlist src, dst;
  64:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 
  65:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	src.page = virt_to_page(pt);
  38              	.loc 1 65 0
  39 0009 8D820000 	leal 1073741824(%edx),%eax
  39      0040
  40 000f C1E80C   	shrl $12,%eax
  41 0012 C1E005   	sall $5,%eax
  42 0015 8B0D0000 	movl mem_map,%ecx
  42      0000
  43 001b 8D0401   	leal (%ecx,%eax),%eax
  44              	.loc 1 62 0
  45 001e 8B5C2434 	movl 52(%esp),%ebx
  46              	.loc 1 65 0
  47 0022 89442410 	movl %eax,16(%esp)
  66:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	src.offset = offset_in_page(pt);
  67:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	src.length = AES_BLOCK_LEN;
GAS LISTING  			page 3


  68:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 
  69:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	dst.page = virt_to_page(ct);
  48              	.loc 1 69 0
  49 0026 8D830000 	leal 1073741824(%ebx),%eax
  49      0040
  50 002c C1E80C   	shrl $12,%eax
  51 002f C1E005   	sall $5,%eax
  52 0032 01C1     	addl %eax,%ecx
  53              	.loc 1 66 0
  54 0034 81E2FF0F 	andl $4095,%edx
  54      0000
  70:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	dst.offset = offset_in_page(ct);
  55              	.loc 1 70 0
  56 003a 81E3FF0F 	andl $4095,%ebx
  56      0000
  57              	.loc 1 66 0
  58 0040 89542414 	movl %edx,20(%esp)
  59              	.loc 1 69 0
  60 0044 890C24   	movl %ecx,(%esp)
  61              	.loc 1 67 0
  62 0047 C744241C 	movl $16,28(%esp)
  62      10000000 
  63              	.loc 1 70 0
  64 004f 895C2404 	movl %ebx,4(%esp)
  71:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	dst.length = AES_BLOCK_LEN;
  65              	.loc 1 71 0
  66 0053 C744240C 	movl $16,12(%esp)
  66      10000000 
  67              	.loc 1 62 0
  68 005b 8B74242C 	movl 44(%esp),%esi
  69              	.LBB2:
  70              	.LBB3:
  71              	.LBB4:
  72              	.LBB5:
  73              	.file 2 "include/linux/crypto.h"
   1:include/linux/crypto.h **** /*
   2:include/linux/crypto.h ****  * Scatterlist Cryptographic API.
   3:include/linux/crypto.h ****  *
   4:include/linux/crypto.h ****  * Copyright (c) 2002 James Morris <jmorris@intercode.com.au>
   5:include/linux/crypto.h ****  * Copyright (c) 2002 David S. Miller (davem@redhat.com)
   6:include/linux/crypto.h ****  *
   7:include/linux/crypto.h ****  * Portions derived from Cryptoapi, by Alexander Kjeldaas <astor@fast.no>
   8:include/linux/crypto.h ****  * and Nettle, by Niels Möller.
   9:include/linux/crypto.h ****  * 
  10:include/linux/crypto.h ****  * This program is free software; you can redistribute it and/or modify it
  11:include/linux/crypto.h ****  * under the terms of the GNU General Public License as published by the Free
  12:include/linux/crypto.h ****  * Software Foundation; either version 2 of the License, or (at your option) 
  13:include/linux/crypto.h ****  * any later version.
  14:include/linux/crypto.h ****  *
  15:include/linux/crypto.h ****  */
  16:include/linux/crypto.h **** #ifndef _LINUX_CRYPTO_H
  17:include/linux/crypto.h **** #define _LINUX_CRYPTO_H
  18:include/linux/crypto.h **** 
  19:include/linux/crypto.h **** #include <linux/config.h>
  20:include/linux/crypto.h **** #include <linux/module.h>
  21:include/linux/crypto.h **** #include <linux/kernel.h>
  22:include/linux/crypto.h **** #include <linux/types.h>
GAS LISTING  			page 4


  23:include/linux/crypto.h **** #include <linux/list.h>
  24:include/linux/crypto.h **** #include <linux/string.h>
  25:include/linux/crypto.h **** #include <asm/page.h>
  26:include/linux/crypto.h **** 
  27:include/linux/crypto.h **** /*
  28:include/linux/crypto.h ****  * Algorithm masks and types.
  29:include/linux/crypto.h ****  */
  30:include/linux/crypto.h **** #define CRYPTO_ALG_TYPE_MASK		0x000000ff
  31:include/linux/crypto.h **** #define CRYPTO_ALG_TYPE_CIPHER		0x00000001
  32:include/linux/crypto.h **** #define CRYPTO_ALG_TYPE_DIGEST		0x00000002
  33:include/linux/crypto.h **** #define CRYPTO_ALG_TYPE_COMPRESS	0x00000004
  34:include/linux/crypto.h **** 
  35:include/linux/crypto.h **** /*
  36:include/linux/crypto.h ****  * Transform masks and values (for crt_flags).
  37:include/linux/crypto.h ****  */
  38:include/linux/crypto.h **** #define CRYPTO_TFM_MODE_MASK		0x000000ff
  39:include/linux/crypto.h **** #define CRYPTO_TFM_REQ_MASK		0x000fff00
  40:include/linux/crypto.h **** #define CRYPTO_TFM_RES_MASK		0xfff00000
  41:include/linux/crypto.h **** 
  42:include/linux/crypto.h **** #define CRYPTO_TFM_MODE_ECB		0x00000001
  43:include/linux/crypto.h **** #define CRYPTO_TFM_MODE_CBC		0x00000002
  44:include/linux/crypto.h **** #define CRYPTO_TFM_MODE_CFB		0x00000004
  45:include/linux/crypto.h **** #define CRYPTO_TFM_MODE_CTR		0x00000008
  46:include/linux/crypto.h **** 
  47:include/linux/crypto.h **** #define CRYPTO_TFM_REQ_WEAK_KEY		0x00000100
  48:include/linux/crypto.h **** #define CRYPTO_TFM_RES_WEAK_KEY		0x00100000
  49:include/linux/crypto.h **** #define CRYPTO_TFM_RES_BAD_KEY_LEN   	0x00200000
  50:include/linux/crypto.h **** #define CRYPTO_TFM_RES_BAD_KEY_SCHED 	0x00400000
  51:include/linux/crypto.h **** #define CRYPTO_TFM_RES_BAD_BLOCK_LEN 	0x00800000
  52:include/linux/crypto.h **** #define CRYPTO_TFM_RES_BAD_FLAGS 	0x01000000
  53:include/linux/crypto.h **** 
  54:include/linux/crypto.h **** /*
  55:include/linux/crypto.h ****  * Miscellaneous stuff.
  56:include/linux/crypto.h ****  */
  57:include/linux/crypto.h **** #define CRYPTO_UNSPEC			0
  58:include/linux/crypto.h **** #define CRYPTO_MAX_ALG_NAME		64
  59:include/linux/crypto.h **** 
  60:include/linux/crypto.h **** #define CRYPTO_DIR_ENCRYPT		1
  61:include/linux/crypto.h **** #define CRYPTO_DIR_DECRYPT		0
  62:include/linux/crypto.h **** 
  63:include/linux/crypto.h **** struct scatterlist;
  64:include/linux/crypto.h **** 
  65:include/linux/crypto.h **** /*
  66:include/linux/crypto.h ****  * Algorithms: modular crypto algorithm implementations, managed
  67:include/linux/crypto.h ****  * via crypto_register_alg() and crypto_unregister_alg().
  68:include/linux/crypto.h ****  */
  69:include/linux/crypto.h **** struct cipher_alg {
  70:include/linux/crypto.h **** 	unsigned int cia_min_keysize;
  71:include/linux/crypto.h **** 	unsigned int cia_max_keysize;
  72:include/linux/crypto.h **** 	int (*cia_setkey)(void *ctx, const u8 *key,
  73:include/linux/crypto.h **** 	                  unsigned int keylen, u32 *flags);
  74:include/linux/crypto.h **** 	void (*cia_encrypt)(void *ctx, u8 *dst, const u8 *src);
  75:include/linux/crypto.h **** 	void (*cia_decrypt)(void *ctx, u8 *dst, const u8 *src);
  76:include/linux/crypto.h **** };
  77:include/linux/crypto.h **** 
  78:include/linux/crypto.h **** struct digest_alg {
  79:include/linux/crypto.h **** 	unsigned int dia_digestsize;
GAS LISTING  			page 5


  80:include/linux/crypto.h **** 	void (*dia_init)(void *ctx);
  81:include/linux/crypto.h **** 	void (*dia_update)(void *ctx, const u8 *data, unsigned int len);
  82:include/linux/crypto.h **** 	void (*dia_final)(void *ctx, u8 *out);
  83:include/linux/crypto.h **** 	int (*dia_setkey)(void *ctx, const u8 *key,
  84:include/linux/crypto.h **** 	                  unsigned int keylen, u32 *flags);
  85:include/linux/crypto.h **** };
  86:include/linux/crypto.h **** 
  87:include/linux/crypto.h **** struct compress_alg {
  88:include/linux/crypto.h **** 	int (*coa_init)(void *ctx);
  89:include/linux/crypto.h **** 	void (*coa_exit)(void *ctx);
  90:include/linux/crypto.h **** 	int (*coa_compress)(void *ctx, const u8 *src, unsigned int slen,
  91:include/linux/crypto.h **** 	                    u8 *dst, unsigned int *dlen);
  92:include/linux/crypto.h **** 	int (*coa_decompress)(void *ctx, const u8 *src, unsigned int slen,
  93:include/linux/crypto.h **** 	                      u8 *dst, unsigned int *dlen);
  94:include/linux/crypto.h **** };
  95:include/linux/crypto.h **** 
  96:include/linux/crypto.h **** #define cra_cipher	cra_u.cipher
  97:include/linux/crypto.h **** #define cra_digest	cra_u.digest
  98:include/linux/crypto.h **** #define cra_compress	cra_u.compress
  99:include/linux/crypto.h **** 
 100:include/linux/crypto.h **** struct crypto_alg {
 101:include/linux/crypto.h **** 	struct list_head cra_list;
 102:include/linux/crypto.h **** 	u32 cra_flags;
 103:include/linux/crypto.h **** 	unsigned int cra_blocksize;
 104:include/linux/crypto.h **** 	unsigned int cra_ctxsize;
 105:include/linux/crypto.h **** 	const char cra_name[CRYPTO_MAX_ALG_NAME];
 106:include/linux/crypto.h **** 
 107:include/linux/crypto.h **** 	union {
 108:include/linux/crypto.h **** 		struct cipher_alg cipher;
 109:include/linux/crypto.h **** 		struct digest_alg digest;
 110:include/linux/crypto.h **** 		struct compress_alg compress;
 111:include/linux/crypto.h **** 	} cra_u;
 112:include/linux/crypto.h **** 	
 113:include/linux/crypto.h **** 	struct module *cra_module;
 114:include/linux/crypto.h **** };
 115:include/linux/crypto.h **** 
 116:include/linux/crypto.h **** /*
 117:include/linux/crypto.h ****  * Algorithm registration interface.
 118:include/linux/crypto.h ****  */
 119:include/linux/crypto.h **** int crypto_register_alg(struct crypto_alg *alg);
 120:include/linux/crypto.h **** int crypto_unregister_alg(struct crypto_alg *alg);
 121:include/linux/crypto.h **** 
 122:include/linux/crypto.h **** /*
 123:include/linux/crypto.h ****  * Algorithm query interface.
 124:include/linux/crypto.h ****  */
 125:include/linux/crypto.h **** #ifdef CONFIG_CRYPTO
 126:include/linux/crypto.h **** int crypto_alg_available(const char *name, u32 flags);
 127:include/linux/crypto.h **** #else
 128:include/linux/crypto.h **** static inline int crypto_alg_available(const char *name, u32 flags)
 129:include/linux/crypto.h **** {
 130:include/linux/crypto.h **** 	return 0;
 131:include/linux/crypto.h **** }
 132:include/linux/crypto.h **** #endif
 133:include/linux/crypto.h **** 
 134:include/linux/crypto.h **** /*
 135:include/linux/crypto.h ****  * Transforms: user-instantiated objects which encapsulate algorithms
 136:include/linux/crypto.h ****  * and core processing logic.  Managed via crypto_alloc_tfm() and
GAS LISTING  			page 6


 137:include/linux/crypto.h ****  * crypto_free_tfm(), as well as the various helpers below.
 138:include/linux/crypto.h ****  */
 139:include/linux/crypto.h **** struct crypto_tfm;
 140:include/linux/crypto.h **** 
 141:include/linux/crypto.h **** struct cipher_tfm {
 142:include/linux/crypto.h **** 	void *cit_iv;
 143:include/linux/crypto.h **** 	unsigned int cit_ivsize;
 144:include/linux/crypto.h **** 	u32 cit_mode;
 145:include/linux/crypto.h **** 	int (*cit_setkey)(struct crypto_tfm *tfm,
 146:include/linux/crypto.h **** 	                  const u8 *key, unsigned int keylen);
 147:include/linux/crypto.h **** 	int (*cit_encrypt)(struct crypto_tfm *tfm,
 148:include/linux/crypto.h **** 			   struct scatterlist *dst,
 149:include/linux/crypto.h **** 			   struct scatterlist *src,
 150:include/linux/crypto.h **** 			   unsigned int nbytes);
 151:include/linux/crypto.h **** 	int (*cit_encrypt_iv)(struct crypto_tfm *tfm,
 152:include/linux/crypto.h **** 	                      struct scatterlist *dst,
 153:include/linux/crypto.h **** 	                      struct scatterlist *src,
 154:include/linux/crypto.h **** 	                      unsigned int nbytes, u8 *iv);
 155:include/linux/crypto.h **** 	int (*cit_decrypt)(struct crypto_tfm *tfm,
 156:include/linux/crypto.h **** 			   struct scatterlist *dst,
 157:include/linux/crypto.h **** 			   struct scatterlist *src,
 158:include/linux/crypto.h **** 			   unsigned int nbytes);
 159:include/linux/crypto.h **** 	int (*cit_decrypt_iv)(struct crypto_tfm *tfm,
 160:include/linux/crypto.h **** 			   struct scatterlist *dst,
 161:include/linux/crypto.h **** 			   struct scatterlist *src,
 162:include/linux/crypto.h **** 			   unsigned int nbytes, u8 *iv);
 163:include/linux/crypto.h **** 	void (*cit_xor_block)(u8 *dst, const u8 *src);
 164:include/linux/crypto.h **** };
 165:include/linux/crypto.h **** 
 166:include/linux/crypto.h **** struct digest_tfm {
 167:include/linux/crypto.h **** 	void (*dit_init)(struct crypto_tfm *tfm);
 168:include/linux/crypto.h **** 	void (*dit_update)(struct crypto_tfm *tfm,
 169:include/linux/crypto.h **** 	                   struct scatterlist *sg, unsigned int nsg);
 170:include/linux/crypto.h **** 	void (*dit_final)(struct crypto_tfm *tfm, u8 *out);
 171:include/linux/crypto.h **** 	void (*dit_digest)(struct crypto_tfm *tfm, struct scatterlist *sg,
 172:include/linux/crypto.h **** 	                   unsigned int nsg, u8 *out);
 173:include/linux/crypto.h **** 	int (*dit_setkey)(struct crypto_tfm *tfm,
 174:include/linux/crypto.h **** 	                  const u8 *key, unsigned int keylen);
 175:include/linux/crypto.h **** #ifdef CONFIG_CRYPTO_HMAC
 176:include/linux/crypto.h **** 	void *dit_hmac_block;
 177:include/linux/crypto.h **** #endif
 178:include/linux/crypto.h **** };
 179:include/linux/crypto.h **** 
 180:include/linux/crypto.h **** struct compress_tfm {
 181:include/linux/crypto.h **** 	int (*cot_compress)(struct crypto_tfm *tfm,
 182:include/linux/crypto.h **** 	                    const u8 *src, unsigned int slen,
 183:include/linux/crypto.h **** 	                    u8 *dst, unsigned int *dlen);
 184:include/linux/crypto.h **** 	int (*cot_decompress)(struct crypto_tfm *tfm,
 185:include/linux/crypto.h **** 	                      const u8 *src, unsigned int slen,
 186:include/linux/crypto.h **** 	                      u8 *dst, unsigned int *dlen);
 187:include/linux/crypto.h **** };
 188:include/linux/crypto.h **** 
 189:include/linux/crypto.h **** #define crt_cipher	crt_u.cipher
 190:include/linux/crypto.h **** #define crt_digest	crt_u.digest
 191:include/linux/crypto.h **** #define crt_compress	crt_u.compress
 192:include/linux/crypto.h **** 
 193:include/linux/crypto.h **** struct crypto_tfm {
GAS LISTING  			page 7


 194:include/linux/crypto.h **** 
 195:include/linux/crypto.h **** 	u32 crt_flags;
 196:include/linux/crypto.h **** 	
 197:include/linux/crypto.h **** 	union {
 198:include/linux/crypto.h **** 		struct cipher_tfm cipher;
 199:include/linux/crypto.h **** 		struct digest_tfm digest;
 200:include/linux/crypto.h **** 		struct compress_tfm compress;
 201:include/linux/crypto.h **** 	} crt_u;
 202:include/linux/crypto.h **** 	
 203:include/linux/crypto.h **** 	struct crypto_alg *__crt_alg;
 204:include/linux/crypto.h **** };
 205:include/linux/crypto.h **** 
 206:include/linux/crypto.h **** /* 
 207:include/linux/crypto.h ****  * Transform user interface.
 208:include/linux/crypto.h ****  */
 209:include/linux/crypto.h ****  
 210:include/linux/crypto.h **** /*
 211:include/linux/crypto.h ****  * crypto_alloc_tfm() will first attempt to locate an already loaded algorithm.
 212:include/linux/crypto.h ****  * If that fails and the kernel supports dynamically loadable modules, it
 213:include/linux/crypto.h ****  * will then attempt to load a module of the same name or alias.  A refcount
 214:include/linux/crypto.h ****  * is grabbed on the algorithm which is then associated with the new transform.
 215:include/linux/crypto.h ****  *
 216:include/linux/crypto.h ****  * crypto_free_tfm() frees up the transform and any associated resources,
 217:include/linux/crypto.h ****  * then drops the refcount on the associated algorithm.
 218:include/linux/crypto.h ****  */
 219:include/linux/crypto.h **** struct crypto_tfm *crypto_alloc_tfm(const char *alg_name, u32 tfm_flags);
 220:include/linux/crypto.h **** void crypto_free_tfm(struct crypto_tfm *tfm);
 221:include/linux/crypto.h **** 
 222:include/linux/crypto.h **** /*
 223:include/linux/crypto.h ****  * Transform helpers which query the underlying algorithm.
 224:include/linux/crypto.h ****  */
 225:include/linux/crypto.h **** static inline const char *crypto_tfm_alg_name(struct crypto_tfm *tfm)
 226:include/linux/crypto.h **** {
 227:include/linux/crypto.h **** 	return tfm->__crt_alg->cra_name;
 228:include/linux/crypto.h **** }
 229:include/linux/crypto.h **** 
 230:include/linux/crypto.h **** static inline const char *crypto_tfm_alg_modname(struct crypto_tfm *tfm)
 231:include/linux/crypto.h **** {
 232:include/linux/crypto.h **** 	return module_name(tfm->__crt_alg->cra_module);
 233:include/linux/crypto.h **** }
 234:include/linux/crypto.h **** 
 235:include/linux/crypto.h **** static inline u32 crypto_tfm_alg_type(struct crypto_tfm *tfm)
 236:include/linux/crypto.h **** {
 237:include/linux/crypto.h **** 	return tfm->__crt_alg->cra_flags & CRYPTO_ALG_TYPE_MASK;
  74              	.loc 2 237 0
  75 005f 8B4628   	movl 40(%esi),%eax
  76              	.LBE5:
  77              	.LBE4:
  78              	.loc 2 236 0
  79 0062 80780801 	cmpb $1,8(%eax)
  80              	.LBE3:
 238:include/linux/crypto.h **** }
 239:include/linux/crypto.h **** 
 240:include/linux/crypto.h **** static inline unsigned int crypto_tfm_alg_min_keysize(struct crypto_tfm *tfm)
 241:include/linux/crypto.h **** {
 242:include/linux/crypto.h **** 	BUG_ON(crypto_tfm_alg_type(tfm) != CRYPTO_ALG_TYPE_CIPHER);
 243:include/linux/crypto.h **** 	return tfm->__crt_alg->cra_cipher.cia_min_keysize;
GAS LISTING  			page 8


 244:include/linux/crypto.h **** }
 245:include/linux/crypto.h **** 
 246:include/linux/crypto.h **** static inline unsigned int crypto_tfm_alg_max_keysize(struct crypto_tfm *tfm)
 247:include/linux/crypto.h **** {
 248:include/linux/crypto.h **** 	BUG_ON(crypto_tfm_alg_type(tfm) != CRYPTO_ALG_TYPE_CIPHER);
 249:include/linux/crypto.h **** 	return tfm->__crt_alg->cra_cipher.cia_max_keysize;
 250:include/linux/crypto.h **** }
 251:include/linux/crypto.h **** 
 252:include/linux/crypto.h **** static inline unsigned int crypto_tfm_alg_ivsize(struct crypto_tfm *tfm)
 253:include/linux/crypto.h **** {
 254:include/linux/crypto.h **** 	BUG_ON(crypto_tfm_alg_type(tfm) != CRYPTO_ALG_TYPE_CIPHER);
 255:include/linux/crypto.h **** 	return tfm->crt_cipher.cit_ivsize;
 256:include/linux/crypto.h **** }
 257:include/linux/crypto.h **** 
 258:include/linux/crypto.h **** static inline unsigned int crypto_tfm_alg_blocksize(struct crypto_tfm *tfm)
 259:include/linux/crypto.h **** {
 260:include/linux/crypto.h **** 	return tfm->__crt_alg->cra_blocksize;
 261:include/linux/crypto.h **** }
 262:include/linux/crypto.h **** 
 263:include/linux/crypto.h **** static inline unsigned int crypto_tfm_alg_digestsize(struct crypto_tfm *tfm)
 264:include/linux/crypto.h **** {
 265:include/linux/crypto.h **** 	BUG_ON(crypto_tfm_alg_type(tfm) != CRYPTO_ALG_TYPE_DIGEST);
 266:include/linux/crypto.h **** 	return tfm->__crt_alg->cra_digest.dia_digestsize;
 267:include/linux/crypto.h **** }
 268:include/linux/crypto.h **** 
 269:include/linux/crypto.h **** /*
 270:include/linux/crypto.h ****  * API wrappers.
 271:include/linux/crypto.h ****  */
 272:include/linux/crypto.h **** static inline void crypto_digest_init(struct crypto_tfm *tfm)
 273:include/linux/crypto.h **** {
 274:include/linux/crypto.h **** 	BUG_ON(crypto_tfm_alg_type(tfm) != CRYPTO_ALG_TYPE_DIGEST);
 275:include/linux/crypto.h **** 	tfm->crt_digest.dit_init(tfm);
 276:include/linux/crypto.h **** }
 277:include/linux/crypto.h **** 
 278:include/linux/crypto.h **** static inline void crypto_digest_update(struct crypto_tfm *tfm,
 279:include/linux/crypto.h ****                                         struct scatterlist *sg,
 280:include/linux/crypto.h ****                                         unsigned int nsg)
 281:include/linux/crypto.h **** {
 282:include/linux/crypto.h **** 	BUG_ON(crypto_tfm_alg_type(tfm) != CRYPTO_ALG_TYPE_DIGEST);
 283:include/linux/crypto.h **** 	tfm->crt_digest.dit_update(tfm, sg, nsg);
 284:include/linux/crypto.h **** }
 285:include/linux/crypto.h **** 
 286:include/linux/crypto.h **** static inline void crypto_digest_final(struct crypto_tfm *tfm, u8 *out)
 287:include/linux/crypto.h **** {
 288:include/linux/crypto.h **** 	BUG_ON(crypto_tfm_alg_type(tfm) != CRYPTO_ALG_TYPE_DIGEST);
 289:include/linux/crypto.h **** 	tfm->crt_digest.dit_final(tfm, out);
 290:include/linux/crypto.h **** }
 291:include/linux/crypto.h **** 
 292:include/linux/crypto.h **** static inline void crypto_digest_digest(struct crypto_tfm *tfm,
 293:include/linux/crypto.h ****                                         struct scatterlist *sg,
 294:include/linux/crypto.h ****                                         unsigned int nsg, u8 *out)
 295:include/linux/crypto.h **** {
 296:include/linux/crypto.h **** 	BUG_ON(crypto_tfm_alg_type(tfm) != CRYPTO_ALG_TYPE_DIGEST);
 297:include/linux/crypto.h **** 	tfm->crt_digest.dit_digest(tfm, sg, nsg, out);
 298:include/linux/crypto.h **** }
 299:include/linux/crypto.h **** 
 300:include/linux/crypto.h **** static inline int crypto_digest_setkey(struct crypto_tfm *tfm,
GAS LISTING  			page 9


 301:include/linux/crypto.h ****                                        const u8 *key, unsigned int keylen)
 302:include/linux/crypto.h **** {
 303:include/linux/crypto.h **** 	BUG_ON(crypto_tfm_alg_type(tfm) != CRYPTO_ALG_TYPE_DIGEST);
 304:include/linux/crypto.h **** 	if (tfm->crt_digest.dit_setkey == NULL)
 305:include/linux/crypto.h **** 		return -ENOSYS;
 306:include/linux/crypto.h **** 	return tfm->crt_digest.dit_setkey(tfm, key, keylen);
 307:include/linux/crypto.h **** }
 308:include/linux/crypto.h **** 
 309:include/linux/crypto.h **** static inline int crypto_cipher_setkey(struct crypto_tfm *tfm,
 310:include/linux/crypto.h ****                                        const u8 *key, unsigned int keylen)
 311:include/linux/crypto.h **** {
 312:include/linux/crypto.h **** 	BUG_ON(crypto_tfm_alg_type(tfm) != CRYPTO_ALG_TYPE_CIPHER);
 313:include/linux/crypto.h **** 	return tfm->crt_cipher.cit_setkey(tfm, key, keylen);
 314:include/linux/crypto.h **** }
 315:include/linux/crypto.h **** 
 316:include/linux/crypto.h **** static inline int crypto_cipher_encrypt(struct crypto_tfm *tfm,
 317:include/linux/crypto.h ****                                         struct scatterlist *dst,
 318:include/linux/crypto.h ****                                         struct scatterlist *src,
 319:include/linux/crypto.h ****                                         unsigned int nbytes)
 320:include/linux/crypto.h **** {
  81              	.loc 2 320 0
  82 0066 89E1     	movl %esp,%ecx
  83 0068 8D542410 	leal 16(%esp),%edx
  84              	.LBB6:
  85              	.loc 2 236 0
  86 006c 7402     	je .L2
 321:include/linux/crypto.h **** 	BUG_ON(crypto_tfm_alg_type(tfm) != CRYPTO_ALG_TYPE_CIPHER);
  87              	.loc 2 321 0
  88              	
  89 006e 0F0B     	ud2
  90              	
  91              	
  92              	.L2:
  93 0070 6A10     	pushl $16
  94              	.LCFI3:
  95 0072 52       	pushl %edx
  96              	.LCFI4:
  97 0073 51       	pushl %ecx
  98              	.LCFI5:
  99 0074 56       	pushl %esi
 100              	.LCFI6:
 101 0075 FF5614   	call *20(%esi)
 102              	.LBE6:
 103              	.LBE2:
 104              	.loc 2 320 0
 105 0078 83C430   	addl $48,%esp
 106 007b 5B       	popl %ebx
 107 007c 5E       	popl %esi
 108 007d C3       	ret
 109              	.LCFI7:
 110              	.LFE687:
 112              	.section .rodata.str1.1,"aMS",@progbits,1
 113              	.LC0:
 114 0000 61657300 	.string "aes"
 115              	.LC1:
 116 0004 3C373E69 	.string "<7>ieee80211_crypt_ccmp: could not allocate crypto API aes\n"
 116      65656538 
GAS LISTING  			page 10


 116      30323131 
 116      5F637279 
 116      70745F63 
 117              	.text
 119              	ieee80211_ccmp_init:
 120              	.LFB688:
  72:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 
  73:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	crypto_cipher_encrypt(tfm, &dst, &src, AES_BLOCK_LEN);
  74:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** }
  75:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 
  76:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** static void *ieee80211_ccmp_init(int key_idx)
  77:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** {
 121              	.loc 1 77 0
 122              	.L9:
 123 007e 57       	pushl %edi
 124              	.LCFI8:
 125 007f 56       	pushl %esi
 126              	.LCFI9:
 127 0080 53       	pushl %ebx
 128              	.LCFI10:
 129              	.loc 1 77 0
 130 0081 50       	pushl %eax
 131              	.LCFI11:
 132              	.LBB7:
 133              	.LBB8:
 134              	.LBB9:
 135              	.file 3 "include/linux/slab.h"
   1:include/linux/slab.h **** /*
   2:include/linux/slab.h ****  * linux/mm/slab.h
   3:include/linux/slab.h ****  * Written by Mark Hemment, 1996.
   4:include/linux/slab.h ****  * (markhe@nextd.demon.co.uk)
   5:include/linux/slab.h ****  */
   6:include/linux/slab.h **** 
   7:include/linux/slab.h **** #ifndef _LINUX_SLAB_H
   8:include/linux/slab.h **** #define	_LINUX_SLAB_H
   9:include/linux/slab.h **** 
  10:include/linux/slab.h **** #if	defined(__KERNEL__)
  11:include/linux/slab.h **** 
  12:include/linux/slab.h **** typedef struct kmem_cache_s kmem_cache_t;
  13:include/linux/slab.h **** 
  14:include/linux/slab.h **** #include	<linux/config.h>	/* kmalloc_sizes.h needs CONFIG_ options */
  15:include/linux/slab.h **** #include	<linux/gfp.h>
  16:include/linux/slab.h **** #include	<linux/init.h>
  17:include/linux/slab.h **** #include	<linux/types.h>
  18:include/linux/slab.h **** #include	<asm/page.h>		/* kmalloc_sizes.h needs PAGE_SIZE */
  19:include/linux/slab.h **** #include	<asm/cache.h>		/* kmalloc_sizes.h needs L1_CACHE_BYTES */
  20:include/linux/slab.h **** 
  21:include/linux/slab.h **** /* flags for kmem_cache_alloc() */
  22:include/linux/slab.h **** #define	SLAB_NOFS		GFP_NOFS
  23:include/linux/slab.h **** #define	SLAB_NOIO		GFP_NOIO
  24:include/linux/slab.h **** #define	SLAB_ATOMIC		GFP_ATOMIC
  25:include/linux/slab.h **** #define	SLAB_USER		GFP_USER
  26:include/linux/slab.h **** #define	SLAB_KERNEL		GFP_KERNEL
  27:include/linux/slab.h **** #define	SLAB_DMA		GFP_DMA
  28:include/linux/slab.h **** 
  29:include/linux/slab.h **** #define SLAB_LEVEL_MASK		GFP_LEVEL_MASK
  30:include/linux/slab.h **** 
GAS LISTING  			page 11


  31:include/linux/slab.h **** #define	SLAB_NO_GROW		__GFP_NO_GROW	/* don't grow a cache */
  32:include/linux/slab.h **** 
  33:include/linux/slab.h **** /* flags to pass to kmem_cache_create().
  34:include/linux/slab.h ****  * The first 3 are only valid when the allocator as been build
  35:include/linux/slab.h ****  * SLAB_DEBUG_SUPPORT.
  36:include/linux/slab.h ****  */
  37:include/linux/slab.h **** #define	SLAB_DEBUG_FREE		0x00000100UL	/* Peform (expensive) checks on free */
  38:include/linux/slab.h **** #define	SLAB_DEBUG_INITIAL	0x00000200UL	/* Call constructor (as verifier) */
  39:include/linux/slab.h **** #define	SLAB_RED_ZONE		0x00000400UL	/* Red zone objs in a cache */
  40:include/linux/slab.h **** #define	SLAB_POISON		0x00000800UL	/* Poison objects */
  41:include/linux/slab.h **** #define	SLAB_NO_REAP		0x00001000UL	/* never reap from the cache */
  42:include/linux/slab.h **** #define	SLAB_HWCACHE_ALIGN	0x00002000UL	/* align objs on a h/w cache lines */
  43:include/linux/slab.h **** #define SLAB_CACHE_DMA		0x00004000UL	/* use GFP_DMA memory */
  44:include/linux/slab.h **** #define SLAB_MUST_HWCACHE_ALIGN	0x00008000UL	/* force alignment */
  45:include/linux/slab.h **** #define SLAB_STORE_USER		0x00010000UL	/* store the last owner for bug hunting */
  46:include/linux/slab.h **** #define SLAB_RECLAIM_ACCOUNT	0x00020000UL	/* track pages allocated to indicate
  47:include/linux/slab.h **** 						   what is reclaimable later*/
  48:include/linux/slab.h **** #define SLAB_PANIC		0x00040000UL	/* panic if kmem_cache_create() fails */
  49:include/linux/slab.h **** #define SLAB_DESTROY_BY_RCU	0x00080000UL	/* defer freeing pages to RCU */
  50:include/linux/slab.h **** 
  51:include/linux/slab.h **** /* flags passed to a constructor func */
  52:include/linux/slab.h **** #define	SLAB_CTOR_CONSTRUCTOR	0x001UL		/* if not set, then deconstructor */
  53:include/linux/slab.h **** #define SLAB_CTOR_ATOMIC	0x002UL		/* tell constructor it can't sleep */
  54:include/linux/slab.h **** #define	SLAB_CTOR_VERIFY	0x004UL		/* tell constructor it's a verify call */
  55:include/linux/slab.h **** 
  56:include/linux/slab.h **** /* prototypes */
  57:include/linux/slab.h **** extern void __init kmem_cache_init(void);
  58:include/linux/slab.h **** 
  59:include/linux/slab.h **** extern kmem_cache_t *kmem_cache_create(const char *, size_t, size_t, unsigned long,
  60:include/linux/slab.h **** 				       void (*)(void *, kmem_cache_t *, unsigned long),
  61:include/linux/slab.h **** 				       void (*)(void *, kmem_cache_t *, unsigned long));
  62:include/linux/slab.h **** extern int kmem_cache_destroy(kmem_cache_t *);
  63:include/linux/slab.h **** extern int kmem_cache_shrink(kmem_cache_t *);
  64:include/linux/slab.h **** extern void *kmem_cache_alloc(kmem_cache_t *, unsigned int __nocast);
  65:include/linux/slab.h **** extern void kmem_cache_free(kmem_cache_t *, void *);
  66:include/linux/slab.h **** extern unsigned int kmem_cache_size(kmem_cache_t *);
  67:include/linux/slab.h **** extern kmem_cache_t *kmem_find_general_cachep(size_t size, int gfpflags);
  68:include/linux/slab.h **** 
  69:include/linux/slab.h **** /* Size description struct for general caches. */
  70:include/linux/slab.h **** struct cache_sizes {
  71:include/linux/slab.h **** 	size_t		 cs_size;
  72:include/linux/slab.h **** 	kmem_cache_t	*cs_cachep;
  73:include/linux/slab.h **** 	kmem_cache_t	*cs_dmacachep;
  74:include/linux/slab.h **** };
  75:include/linux/slab.h **** extern struct cache_sizes malloc_sizes[];
  76:include/linux/slab.h **** extern void *__kmalloc(size_t, unsigned int __nocast);
  77:include/linux/slab.h **** 
  78:include/linux/slab.h **** static inline void *kmalloc(size_t size, unsigned int __nocast flags)
  79:include/linux/slab.h **** {
  80:include/linux/slab.h **** 	if (__builtin_constant_p(size)) {
  81:include/linux/slab.h **** 		int i = 0;
  82:include/linux/slab.h **** #define CACHE(x) \
  83:include/linux/slab.h **** 		if (size <= x) \
  84:include/linux/slab.h **** 			goto found; \
  85:include/linux/slab.h **** 		else \
  86:include/linux/slab.h **** 			i++;
  87:include/linux/slab.h **** #include "kmalloc_sizes.h"
GAS LISTING  			page 12


  88:include/linux/slab.h **** #undef CACHE
  89:include/linux/slab.h **** 		{
  90:include/linux/slab.h **** 			extern void __you_cannot_kmalloc_that_much(void);
  91:include/linux/slab.h **** 			__you_cannot_kmalloc_that_much();
  92:include/linux/slab.h **** 		}
  93:include/linux/slab.h **** found:
 136              	.loc 3 93 0
 137 0082 6A20     	pushl $32
 138              	.LCFI12:
 139 0084 FF352800 	pushl malloc_sizes+40
 139      0000
 140              	.LCFI13:
 141              	.LCFI14:
 142 008a E8FCFFFF 	call kmem_cache_alloc
 142      FF
 143 008f 5B       	popl %ebx
 144              	.LCFI15:
 145 0090 31F6     	xorl %esi,%esi
 146              	.LBE9:
 147              	.LBE8:
 148              	.LBE7:
  78:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	struct ieee80211_ccmp_data *priv;
  79:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 
  80:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	priv = kmalloc(sizeof(*priv), GFP_ATOMIC);
  81:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	if (priv == NULL)
 149              	.loc 1 81 0
 150 0092 85C0     	testl %eax,%eax
 151              	.LBB10:
 152              	.LBB11:
 153              	.LBB12:
 154              	.loc 3 93 0
 155 0094 5F       	popl %edi
 156              	.LCFI16:
 157 0095 89C3     	movl %eax,%ebx
 158              	.LBE12:
 159              	.LBE11:
 160              	.LBE10:
 161              	.loc 1 81 0
 162 0097 7449     	je .L54
 163              	.LBB13:
 164              	.LBB14:
 165              	.LBB15:
 166              	.file 4 "include/asm/string.h"
   1:include/asm/string.h **** #ifndef _I386_STRING_H_
   2:include/asm/string.h **** #define _I386_STRING_H_
   3:include/asm/string.h **** 
   4:include/asm/string.h **** #ifdef __KERNEL__
   5:include/asm/string.h **** #include <linux/config.h>
   6:include/asm/string.h **** /*
   7:include/asm/string.h ****  * On a 486 or Pentium, we are better off not using the
   8:include/asm/string.h ****  * byte string operations. But on a 386 or a PPro the
   9:include/asm/string.h ****  * byte string ops are faster than doing it by hand
  10:include/asm/string.h ****  * (MUCH faster on a Pentium).
  11:include/asm/string.h ****  */
  12:include/asm/string.h **** 
  13:include/asm/string.h **** /*
  14:include/asm/string.h ****  * This string-include defines all string functions as inline
GAS LISTING  			page 13


  15:include/asm/string.h ****  * functions. Use gcc. It also assumes ds=es=data space, this should be
  16:include/asm/string.h ****  * normal. Most of the string-functions are rather heavily hand-optimized,
  17:include/asm/string.h ****  * see especially strsep,strstr,str[c]spn. They should work, but are not
  18:include/asm/string.h ****  * very easy to understand. Everything is done entirely within the register
  19:include/asm/string.h ****  * set, making the functions fast and clean. String instructions have been
  20:include/asm/string.h ****  * used through-out, making for "slightly" unclear code :-)
  21:include/asm/string.h ****  *
  22:include/asm/string.h ****  *		NO Copyright (C) 1991, 1992 Linus Torvalds,
  23:include/asm/string.h ****  *		consider these trivial functions to be PD.
  24:include/asm/string.h ****  */
  25:include/asm/string.h **** 
  26:include/asm/string.h **** /* AK: in fact I bet it would be better to move this stuff all out of line.
  27:include/asm/string.h ****  */
  28:include/asm/string.h **** 
  29:include/asm/string.h **** #define __HAVE_ARCH_STRCPY
  30:include/asm/string.h **** static inline char * strcpy(char * dest,const char *src)
  31:include/asm/string.h **** {
  32:include/asm/string.h **** int d0, d1, d2;
  33:include/asm/string.h **** __asm__ __volatile__(
  34:include/asm/string.h **** 	"1:\tlodsb\n\t"
  35:include/asm/string.h **** 	"stosb\n\t"
  36:include/asm/string.h **** 	"testb %%al,%%al\n\t"
  37:include/asm/string.h **** 	"jne 1b"
  38:include/asm/string.h **** 	: "=&S" (d0), "=&D" (d1), "=&a" (d2)
  39:include/asm/string.h **** 	:"0" (src),"1" (dest) : "memory");
  40:include/asm/string.h **** return dest;
  41:include/asm/string.h **** }
  42:include/asm/string.h **** 
  43:include/asm/string.h **** #define __HAVE_ARCH_STRNCPY
  44:include/asm/string.h **** static inline char * strncpy(char * dest,const char *src,size_t count)
  45:include/asm/string.h **** {
  46:include/asm/string.h **** int d0, d1, d2, d3;
  47:include/asm/string.h **** __asm__ __volatile__(
  48:include/asm/string.h **** 	"1:\tdecl %2\n\t"
  49:include/asm/string.h **** 	"js 2f\n\t"
  50:include/asm/string.h **** 	"lodsb\n\t"
  51:include/asm/string.h **** 	"stosb\n\t"
  52:include/asm/string.h **** 	"testb %%al,%%al\n\t"
  53:include/asm/string.h **** 	"jne 1b\n\t"
  54:include/asm/string.h **** 	"rep\n\t"
  55:include/asm/string.h **** 	"stosb\n"
  56:include/asm/string.h **** 	"2:"
  57:include/asm/string.h **** 	: "=&S" (d0), "=&D" (d1), "=&c" (d2), "=&a" (d3)
  58:include/asm/string.h **** 	:"0" (src),"1" (dest),"2" (count) : "memory");
  59:include/asm/string.h **** return dest;
  60:include/asm/string.h **** }
  61:include/asm/string.h **** 
  62:include/asm/string.h **** #define __HAVE_ARCH_STRCAT
  63:include/asm/string.h **** static inline char * strcat(char * dest,const char * src)
  64:include/asm/string.h **** {
  65:include/asm/string.h **** int d0, d1, d2, d3;
  66:include/asm/string.h **** __asm__ __volatile__(
  67:include/asm/string.h **** 	"repne\n\t"
  68:include/asm/string.h **** 	"scasb\n\t"
  69:include/asm/string.h **** 	"decl %1\n"
  70:include/asm/string.h **** 	"1:\tlodsb\n\t"
  71:include/asm/string.h **** 	"stosb\n\t"
GAS LISTING  			page 14


  72:include/asm/string.h **** 	"testb %%al,%%al\n\t"
  73:include/asm/string.h **** 	"jne 1b"
  74:include/asm/string.h **** 	: "=&S" (d0), "=&D" (d1), "=&a" (d2), "=&c" (d3)
  75:include/asm/string.h **** 	: "0" (src), "1" (dest), "2" (0), "3" (0xffffffffu):"memory");
  76:include/asm/string.h **** return dest;
  77:include/asm/string.h **** }
  78:include/asm/string.h **** 
  79:include/asm/string.h **** #define __HAVE_ARCH_STRNCAT
  80:include/asm/string.h **** static inline char * strncat(char * dest,const char * src,size_t count)
  81:include/asm/string.h **** {
  82:include/asm/string.h **** int d0, d1, d2, d3;
  83:include/asm/string.h **** __asm__ __volatile__(
  84:include/asm/string.h **** 	"repne\n\t"
  85:include/asm/string.h **** 	"scasb\n\t"
  86:include/asm/string.h **** 	"decl %1\n\t"
  87:include/asm/string.h **** 	"movl %8,%3\n"
  88:include/asm/string.h **** 	"1:\tdecl %3\n\t"
  89:include/asm/string.h **** 	"js 2f\n\t"
  90:include/asm/string.h **** 	"lodsb\n\t"
  91:include/asm/string.h **** 	"stosb\n\t"
  92:include/asm/string.h **** 	"testb %%al,%%al\n\t"
  93:include/asm/string.h **** 	"jne 1b\n"
  94:include/asm/string.h **** 	"2:\txorl %2,%2\n\t"
  95:include/asm/string.h **** 	"stosb"
  96:include/asm/string.h **** 	: "=&S" (d0), "=&D" (d1), "=&a" (d2), "=&c" (d3)
  97:include/asm/string.h **** 	: "0" (src),"1" (dest),"2" (0),"3" (0xffffffffu), "g" (count)
  98:include/asm/string.h **** 	: "memory");
  99:include/asm/string.h **** return dest;
 100:include/asm/string.h **** }
 101:include/asm/string.h **** 
 102:include/asm/string.h **** #define __HAVE_ARCH_STRCMP
 103:include/asm/string.h **** static inline int strcmp(const char * cs,const char * ct)
 104:include/asm/string.h **** {
 105:include/asm/string.h **** int d0, d1;
 106:include/asm/string.h **** register int __res;
 107:include/asm/string.h **** __asm__ __volatile__(
 108:include/asm/string.h **** 	"1:\tlodsb\n\t"
 109:include/asm/string.h **** 	"scasb\n\t"
 110:include/asm/string.h **** 	"jne 2f\n\t"
 111:include/asm/string.h **** 	"testb %%al,%%al\n\t"
 112:include/asm/string.h **** 	"jne 1b\n\t"
 113:include/asm/string.h **** 	"xorl %%eax,%%eax\n\t"
 114:include/asm/string.h **** 	"jmp 3f\n"
 115:include/asm/string.h **** 	"2:\tsbbl %%eax,%%eax\n\t"
 116:include/asm/string.h **** 	"orb $1,%%al\n"
 117:include/asm/string.h **** 	"3:"
 118:include/asm/string.h **** 	:"=a" (__res), "=&S" (d0), "=&D" (d1)
 119:include/asm/string.h **** 	:"1" (cs),"2" (ct)
 120:include/asm/string.h **** 	:"memory");
 121:include/asm/string.h **** return __res;
 122:include/asm/string.h **** }
 123:include/asm/string.h **** 
 124:include/asm/string.h **** #define __HAVE_ARCH_STRNCMP
 125:include/asm/string.h **** static inline int strncmp(const char * cs,const char * ct,size_t count)
 126:include/asm/string.h **** {
 127:include/asm/string.h **** register int __res;
 128:include/asm/string.h **** int d0, d1, d2;
GAS LISTING  			page 15


 129:include/asm/string.h **** __asm__ __volatile__(
 130:include/asm/string.h **** 	"1:\tdecl %3\n\t"
 131:include/asm/string.h **** 	"js 2f\n\t"
 132:include/asm/string.h **** 	"lodsb\n\t"
 133:include/asm/string.h **** 	"scasb\n\t"
 134:include/asm/string.h **** 	"jne 3f\n\t"
 135:include/asm/string.h **** 	"testb %%al,%%al\n\t"
 136:include/asm/string.h **** 	"jne 1b\n"
 137:include/asm/string.h **** 	"2:\txorl %%eax,%%eax\n\t"
 138:include/asm/string.h **** 	"jmp 4f\n"
 139:include/asm/string.h **** 	"3:\tsbbl %%eax,%%eax\n\t"
 140:include/asm/string.h **** 	"orb $1,%%al\n"
 141:include/asm/string.h **** 	"4:"
 142:include/asm/string.h **** 	:"=a" (__res), "=&S" (d0), "=&D" (d1), "=&c" (d2)
 143:include/asm/string.h **** 	:"1" (cs),"2" (ct),"3" (count)
 144:include/asm/string.h **** 	:"memory");
 145:include/asm/string.h **** return __res;
 146:include/asm/string.h **** }
 147:include/asm/string.h **** 
 148:include/asm/string.h **** #define __HAVE_ARCH_STRCHR
 149:include/asm/string.h **** static inline char * strchr(const char * s, int c)
 150:include/asm/string.h **** {
 151:include/asm/string.h **** int d0;
 152:include/asm/string.h **** register char * __res;
 153:include/asm/string.h **** __asm__ __volatile__(
 154:include/asm/string.h **** 	"movb %%al,%%ah\n"
 155:include/asm/string.h **** 	"1:\tlodsb\n\t"
 156:include/asm/string.h **** 	"cmpb %%ah,%%al\n\t"
 157:include/asm/string.h **** 	"je 2f\n\t"
 158:include/asm/string.h **** 	"testb %%al,%%al\n\t"
 159:include/asm/string.h **** 	"jne 1b\n\t"
 160:include/asm/string.h **** 	"movl $1,%1\n"
 161:include/asm/string.h **** 	"2:\tmovl %1,%0\n\t"
 162:include/asm/string.h **** 	"decl %0"
 163:include/asm/string.h **** 	:"=a" (__res), "=&S" (d0)
 164:include/asm/string.h **** 	:"1" (s),"0" (c)
 165:include/asm/string.h **** 	:"memory");
 166:include/asm/string.h **** return __res;
 167:include/asm/string.h **** }
 168:include/asm/string.h **** 
 169:include/asm/string.h **** #define __HAVE_ARCH_STRRCHR
 170:include/asm/string.h **** static inline char * strrchr(const char * s, int c)
 171:include/asm/string.h **** {
 172:include/asm/string.h **** int d0, d1;
 173:include/asm/string.h **** register char * __res;
 174:include/asm/string.h **** __asm__ __volatile__(
 175:include/asm/string.h **** 	"movb %%al,%%ah\n"
 176:include/asm/string.h **** 	"1:\tlodsb\n\t"
 177:include/asm/string.h **** 	"cmpb %%ah,%%al\n\t"
 178:include/asm/string.h **** 	"jne 2f\n\t"
 179:include/asm/string.h **** 	"leal -1(%%esi),%0\n"
 180:include/asm/string.h **** 	"2:\ttestb %%al,%%al\n\t"
 181:include/asm/string.h **** 	"jne 1b"
 182:include/asm/string.h **** 	:"=g" (__res), "=&S" (d0), "=&a" (d1)
 183:include/asm/string.h **** 	:"0" (0),"1" (s),"2" (c)
 184:include/asm/string.h **** 	:"memory");
 185:include/asm/string.h **** return __res;
GAS LISTING  			page 16


 186:include/asm/string.h **** }
 187:include/asm/string.h **** 
 188:include/asm/string.h **** #define __HAVE_ARCH_STRLEN
 189:include/asm/string.h **** static inline size_t strlen(const char * s)
 190:include/asm/string.h **** {
 191:include/asm/string.h **** int d0;
 192:include/asm/string.h **** register int __res;
 193:include/asm/string.h **** __asm__ __volatile__(
 194:include/asm/string.h **** 	"repne\n\t"
 195:include/asm/string.h **** 	"scasb\n\t"
 196:include/asm/string.h **** 	"notl %0\n\t"
 197:include/asm/string.h **** 	"decl %0"
 198:include/asm/string.h **** 	:"=c" (__res), "=&D" (d0)
 199:include/asm/string.h **** 	:"1" (s),"a" (0), "0" (0xffffffffu)
 200:include/asm/string.h **** 	:"memory");
 201:include/asm/string.h **** return __res;
 202:include/asm/string.h **** }
 203:include/asm/string.h **** 
 204:include/asm/string.h **** static inline void * __memcpy(void * to, const void * from, size_t n)
 205:include/asm/string.h **** {
 206:include/asm/string.h **** int d0, d1, d2;
 207:include/asm/string.h **** __asm__ __volatile__(
 208:include/asm/string.h **** 	"rep ; movsl\n\t"
 209:include/asm/string.h **** 	"movl %4,%%ecx\n\t"
 210:include/asm/string.h **** 	"andl $3,%%ecx\n\t"
 211:include/asm/string.h **** #if 1	/* want to pay 2 byte penalty for a chance to skip microcoded rep? */
 212:include/asm/string.h **** 	"jz 1f\n\t"
 213:include/asm/string.h **** #endif
 214:include/asm/string.h **** 	"rep ; movsb\n\t"
 215:include/asm/string.h **** 	"1:"
 216:include/asm/string.h **** 	: "=&c" (d0), "=&D" (d1), "=&S" (d2)
 217:include/asm/string.h **** 	: "0" (n/4), "g" (n), "1" ((long) to), "2" ((long) from)
 218:include/asm/string.h **** 	: "memory");
 219:include/asm/string.h **** return (to);
 220:include/asm/string.h **** }
 221:include/asm/string.h **** 
 222:include/asm/string.h **** /*
 223:include/asm/string.h ****  * This looks ugly, but the compiler can optimize it totally,
 224:include/asm/string.h ****  * as the count is constant.
 225:include/asm/string.h ****  */
 226:include/asm/string.h **** static inline void * __constant_memcpy(void * to, const void * from, size_t n)
 227:include/asm/string.h **** {
 228:include/asm/string.h **** 	long esi, edi;
 229:include/asm/string.h **** 	if (!n) return to;
 230:include/asm/string.h **** #if 1	/* want to do small copies with non-string ops? */
 231:include/asm/string.h **** 	switch (n) {
 232:include/asm/string.h **** 		case 1: *(char*)to = *(char*)from; return to;
 233:include/asm/string.h **** 		case 2: *(short*)to = *(short*)from; return to;
 234:include/asm/string.h **** 		case 4: *(int*)to = *(int*)from; return to;
 235:include/asm/string.h **** #if 1	/* including those doable with two moves? */
 236:include/asm/string.h **** 		case 3: *(short*)to = *(short*)from;
 237:include/asm/string.h **** 			*((char*)to+2) = *((char*)from+2); return to;
 238:include/asm/string.h **** 		case 5: *(int*)to = *(int*)from;
 239:include/asm/string.h **** 			*((char*)to+4) = *((char*)from+4); return to;
 240:include/asm/string.h **** 		case 6: *(int*)to = *(int*)from;
 241:include/asm/string.h **** 			*((short*)to+2) = *((short*)from+2); return to;
 242:include/asm/string.h **** 		case 8: *(int*)to = *(int*)from;
GAS LISTING  			page 17


 243:include/asm/string.h **** 			*((int*)to+1) = *((int*)from+1); return to;
 244:include/asm/string.h **** #endif
 245:include/asm/string.h **** 	}
 246:include/asm/string.h **** #endif
 247:include/asm/string.h **** 	esi = (long) from;
 248:include/asm/string.h **** 	edi = (long) to;
 249:include/asm/string.h **** 	if (n >= 5*4) {
 250:include/asm/string.h **** 		/* large block: use rep prefix */
 251:include/asm/string.h **** 		int ecx;
 252:include/asm/string.h **** 		__asm__ __volatile__(
 253:include/asm/string.h **** 			"rep ; movsl"
 254:include/asm/string.h **** 			: "=&c" (ecx), "=&D" (edi), "=&S" (esi)
 255:include/asm/string.h **** 			: "0" (n/4), "1" (edi),"2" (esi)
 256:include/asm/string.h **** 			: "memory"
 257:include/asm/string.h **** 		);
 258:include/asm/string.h **** 	} else {
 259:include/asm/string.h **** 		/* small block: don't clobber ecx + smaller code */
 260:include/asm/string.h **** 		if (n >= 4*4) __asm__ __volatile__("movsl"
 261:include/asm/string.h **** 			:"=&D"(edi),"=&S"(esi):"0"(edi),"1"(esi):"memory");
 262:include/asm/string.h **** 		if (n >= 3*4) __asm__ __volatile__("movsl"
 263:include/asm/string.h **** 			:"=&D"(edi),"=&S"(esi):"0"(edi),"1"(esi):"memory");
 264:include/asm/string.h **** 		if (n >= 2*4) __asm__ __volatile__("movsl"
 265:include/asm/string.h **** 			:"=&D"(edi),"=&S"(esi):"0"(edi),"1"(esi):"memory");
 266:include/asm/string.h **** 		if (n >= 1*4) __asm__ __volatile__("movsl"
 267:include/asm/string.h **** 			:"=&D"(edi),"=&S"(esi):"0"(edi),"1"(esi):"memory");
 268:include/asm/string.h **** 	}
 269:include/asm/string.h **** 	switch (n % 4) {
 270:include/asm/string.h **** 		/* tail */
 271:include/asm/string.h **** 		case 0: return to;
 272:include/asm/string.h **** 		case 1: __asm__ __volatile__("movsb"
 273:include/asm/string.h **** 			:"=&D"(edi),"=&S"(esi):"0"(edi),"1"(esi):"memory");
 274:include/asm/string.h **** 			return to;
 275:include/asm/string.h **** 		case 2: __asm__ __volatile__("movsw"
 276:include/asm/string.h **** 			:"=&D"(edi),"=&S"(esi):"0"(edi),"1"(esi):"memory");
 277:include/asm/string.h **** 			return to;
 278:include/asm/string.h **** 		default: __asm__ __volatile__("movsw\n\tmovsb"
 279:include/asm/string.h **** 			:"=&D"(edi),"=&S"(esi):"0"(edi),"1"(esi):"memory");
 280:include/asm/string.h **** 			return to;
 281:include/asm/string.h **** 	}
 282:include/asm/string.h **** }
 283:include/asm/string.h **** 
 284:include/asm/string.h **** #define __HAVE_ARCH_MEMCPY
 285:include/asm/string.h **** 
 286:include/asm/string.h **** #ifdef CONFIG_X86_USE_3DNOW
 287:include/asm/string.h **** 
 288:include/asm/string.h **** #include <asm/mmx.h>
 289:include/asm/string.h **** 
 290:include/asm/string.h **** /*
 291:include/asm/string.h ****  *	This CPU favours 3DNow strongly (eg AMD Athlon)
 292:include/asm/string.h ****  */
 293:include/asm/string.h **** 
 294:include/asm/string.h **** static inline void * __constant_memcpy3d(void * to, const void * from, size_t len)
 295:include/asm/string.h **** {
 296:include/asm/string.h **** 	if (len < 512)
 297:include/asm/string.h **** 		return __constant_memcpy(to, from, len);
 298:include/asm/string.h **** 	return _mmx_memcpy(to, from, len);
 299:include/asm/string.h **** }
GAS LISTING  			page 18


 300:include/asm/string.h **** 
 301:include/asm/string.h **** static __inline__ void *__memcpy3d(void *to, const void *from, size_t len)
 302:include/asm/string.h **** {
 303:include/asm/string.h **** 	if (len < 512)
 304:include/asm/string.h **** 		return __memcpy(to, from, len);
 305:include/asm/string.h **** 	return _mmx_memcpy(to, from, len);
 306:include/asm/string.h **** }
 307:include/asm/string.h **** 
 308:include/asm/string.h **** #define memcpy(t, f, n) \
 309:include/asm/string.h **** (__builtin_constant_p(n) ? \
 310:include/asm/string.h ****  __constant_memcpy3d((t),(f),(n)) : \
 311:include/asm/string.h ****  __memcpy3d((t),(f),(n)))
 312:include/asm/string.h **** 
 313:include/asm/string.h **** #else
 314:include/asm/string.h **** 
 315:include/asm/string.h **** /*
 316:include/asm/string.h ****  *	No 3D Now!
 317:include/asm/string.h ****  */
 318:include/asm/string.h ****  
 319:include/asm/string.h **** #define memcpy(t, f, n) \
 320:include/asm/string.h **** (__builtin_constant_p(n) ? \
 321:include/asm/string.h ****  __constant_memcpy((t),(f),(n)) : \
 322:include/asm/string.h ****  __memcpy((t),(f),(n)))
 323:include/asm/string.h **** 
 324:include/asm/string.h **** #endif
 325:include/asm/string.h **** 
 326:include/asm/string.h **** #define __HAVE_ARCH_MEMMOVE
 327:include/asm/string.h **** void *memmove(void * dest,const void * src, size_t n);
 328:include/asm/string.h **** 
 329:include/asm/string.h **** #define memcmp __builtin_memcmp
 330:include/asm/string.h **** 
 331:include/asm/string.h **** #define __HAVE_ARCH_MEMCHR
 332:include/asm/string.h **** static inline void * memchr(const void * cs,int c,size_t count)
 333:include/asm/string.h **** {
 334:include/asm/string.h **** int d0;
 335:include/asm/string.h **** register void * __res;
 336:include/asm/string.h **** if (!count)
 337:include/asm/string.h **** 	return NULL;
 338:include/asm/string.h **** __asm__ __volatile__(
 339:include/asm/string.h **** 	"repne\n\t"
 340:include/asm/string.h **** 	"scasb\n\t"
 341:include/asm/string.h **** 	"je 1f\n\t"
 342:include/asm/string.h **** 	"movl $1,%0\n"
 343:include/asm/string.h **** 	"1:\tdecl %0"
 344:include/asm/string.h **** 	:"=D" (__res), "=&c" (d0)
 345:include/asm/string.h **** 	:"a" (c),"0" (cs),"1" (count)
 346:include/asm/string.h **** 	:"memory");
 347:include/asm/string.h **** return __res;
 348:include/asm/string.h **** }
 349:include/asm/string.h **** 
 350:include/asm/string.h **** static inline void * __memset_generic(void * s, char c,size_t count)
 351:include/asm/string.h **** {
 352:include/asm/string.h **** int d0, d1;
 353:include/asm/string.h **** __asm__ __volatile__(
 354:include/asm/string.h **** 	"rep\n\t"
 355:include/asm/string.h **** 	"stosb"
 356:include/asm/string.h **** 	: "=&c" (d0), "=&D" (d1)
GAS LISTING  			page 19


 357:include/asm/string.h **** 	:"a" (c),"1" (s),"0" (count)
 358:include/asm/string.h **** 	:"memory");
 359:include/asm/string.h **** return s;
 360:include/asm/string.h **** }
 361:include/asm/string.h **** 
 362:include/asm/string.h **** /* we might want to write optimized versions of these later */
 363:include/asm/string.h **** #define __constant_count_memset(s,c,count) __memset_generic((s),(c),(count))
 364:include/asm/string.h **** 
 365:include/asm/string.h **** /*
 366:include/asm/string.h ****  * memset(x,0,y) is a reasonably common thing to do, so we want to fill
 367:include/asm/string.h ****  * things 32 bits at a time even when we don't know the size of the
 368:include/asm/string.h ****  * area at compile-time..
 369:include/asm/string.h ****  */
 370:include/asm/string.h **** static inline void * __constant_c_memset(void * s, unsigned long c, size_t count)
 371:include/asm/string.h **** {
 372:include/asm/string.h **** int d0, d1;
 373:include/asm/string.h **** __asm__ __volatile__(
 374:include/asm/string.h **** 	"rep ; stosl\n\t"
 375:include/asm/string.h **** 	"testb $2,%b3\n\t"
 376:include/asm/string.h **** 	"je 1f\n\t"
 377:include/asm/string.h **** 	"stosw\n"
 378:include/asm/string.h **** 	"1:\ttestb $1,%b3\n\t"
 379:include/asm/string.h **** 	"je 2f\n\t"
 380:include/asm/string.h **** 	"stosb\n"
 381:include/asm/string.h **** 	"2:"
 382:include/asm/string.h **** 	:"=&c" (d0), "=&D" (d1)
 383:include/asm/string.h **** 	:"a" (c), "q" (count), "0" (count/4), "1" ((long) s)
 384:include/asm/string.h **** 	:"memory");
 385:include/asm/string.h **** return (s);	
 386:include/asm/string.h **** }
 387:include/asm/string.h **** 
 388:include/asm/string.h **** /* Added by Gertjan van Wingerde to make minix and sysv module work */
 389:include/asm/string.h **** #define __HAVE_ARCH_STRNLEN
 390:include/asm/string.h **** static inline size_t strnlen(const char * s, size_t count)
 391:include/asm/string.h **** {
 392:include/asm/string.h **** int d0;
 393:include/asm/string.h **** register int __res;
 394:include/asm/string.h **** __asm__ __volatile__(
 395:include/asm/string.h **** 	"movl %2,%0\n\t"
 396:include/asm/string.h **** 	"jmp 2f\n"
 397:include/asm/string.h **** 	"1:\tcmpb $0,(%0)\n\t"
 398:include/asm/string.h **** 	"je 3f\n\t"
 399:include/asm/string.h **** 	"incl %0\n"
 400:include/asm/string.h **** 	"2:\tdecl %1\n\t"
 401:include/asm/string.h **** 	"cmpl $-1,%1\n\t"
 402:include/asm/string.h **** 	"jne 1b\n"
 403:include/asm/string.h **** 	"3:\tsubl %2,%0"
 404:include/asm/string.h **** 	:"=a" (__res), "=&d" (d0)
 405:include/asm/string.h **** 	:"c" (s),"1" (count)
 406:include/asm/string.h **** 	:"memory");
 407:include/asm/string.h **** return __res;
 408:include/asm/string.h **** }
 409:include/asm/string.h **** /* end of additional stuff */
 410:include/asm/string.h **** 
 411:include/asm/string.h **** #define __HAVE_ARCH_STRSTR
 412:include/asm/string.h **** 
 413:include/asm/string.h **** extern char *strstr(const char *cs, const char *ct);
GAS LISTING  			page 20


 414:include/asm/string.h **** 
 415:include/asm/string.h **** /*
 416:include/asm/string.h ****  * This looks horribly ugly, but the compiler can optimize it totally,
 417:include/asm/string.h ****  * as we by now know that both pattern and count is constant..
 418:include/asm/string.h ****  */
 419:include/asm/string.h **** static inline void * __constant_c_and_count_memset(void * s, unsigned long pattern, size_t count)
 420:include/asm/string.h **** {
 421:include/asm/string.h **** 	switch (count) {
 422:include/asm/string.h **** 		case 0:
 423:include/asm/string.h **** 			return s;
 424:include/asm/string.h **** 		case 1:
 425:include/asm/string.h **** 			*(unsigned char *)s = pattern;
 426:include/asm/string.h **** 			return s;
 427:include/asm/string.h **** 		case 2:
 428:include/asm/string.h **** 			*(unsigned short *)s = pattern;
 429:include/asm/string.h **** 			return s;
 430:include/asm/string.h **** 		case 3:
 431:include/asm/string.h **** 			*(unsigned short *)s = pattern;
 432:include/asm/string.h **** 			*(2+(unsigned char *)s) = pattern;
 433:include/asm/string.h **** 			return s;
 434:include/asm/string.h **** 		case 4:
 435:include/asm/string.h **** 			*(unsigned long *)s = pattern;
 436:include/asm/string.h **** 			return s;
 437:include/asm/string.h **** 	}
 438:include/asm/string.h **** #define COMMON(x) \
 439:include/asm/string.h **** __asm__  __volatile__( \
 440:include/asm/string.h **** 	"rep ; stosl" \
 441:include/asm/string.h **** 	x \
 442:include/asm/string.h **** 	: "=&c" (d0), "=&D" (d1) \
 443:include/asm/string.h **** 	: "a" (pattern),"0" (count/4),"1" ((long) s) \
 444:include/asm/string.h **** 	: "memory")
 445:include/asm/string.h **** {
 446:include/asm/string.h **** 	int d0, d1;
 447:include/asm/string.h **** 	switch (count % 4) {
 448:include/asm/string.h **** 		case 0: COMMON(""); return s;
 167              	.loc 4 448 0
 168 0099 89C7     	movl %eax,%edi
 169 009b B9290000 	movl $41,%ecx
 169      00
 170 00a0 89F0     	movl %esi,%eax
 171              	
 172 00a2 F3AB     	rep
 173              	
 174              	.LBE15:
 175              	.LBE14:
 176              	.LBE13:
  82:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 		goto fail;
  83:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	memset(priv, 0, sizeof(*priv));
  84:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	priv->key_idx = key_idx;
 177              	.loc 1 84 0
 178 00a4 8B442414 	movl 20(%esp),%eax
 179 00a8 89432C   	movl %eax,44(%ebx)
  85:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 
  86:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	priv->tfm = crypto_alloc_tfm("aes", 0);
 180              	.loc 1 86 0
 181 00ab 6A00     	pushl $0
 182              	.LCFI17:
GAS LISTING  			page 21


 183 00ad 68000000 	pushl $.LC0
 183      00
 184              	.LCFI18:
 185              	.LCFI19:
 186 00b2 E8FCFFFF 	call crypto_alloc_tfm
 186      FF
 187 00b7 894330   	movl %eax,48(%ebx)
  87:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	if (priv->tfm == NULL) {
 188              	.loc 1 87 0
 189 00ba 5A       	popl %edx
 190              	.LCFI20:
 191 00bb 85C0     	testl %eax,%eax
 192 00bd 59       	popl %ecx
 193              	.LCFI21:
  88:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 		printk(KERN_DEBUG "ieee80211_crypt_ccmp: could not allocate "
  89:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 		       "crypto API aes\n");
  90:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 		goto fail;
  91:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	}
  92:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 
  93:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	return priv;
 194              	.loc 1 93 0
 195 00be 89DA     	movl %ebx,%edx
 196              	.loc 1 87 0
 197 00c0 7522     	jne .L6
 198              	.L39:
 199              	.loc 1 88 0
 200 00c2 68040000 	pushl $.LC1
 200      00
 201              	.LCFI22:
 202              	.LCFI23:
 203 00c7 E8FCFFFF 	call printk
 203      FF
  94:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 
  95:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c ****       fail:
  96:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	if (priv) {
  97:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 		if (priv->tfm)
 204              	.loc 1 97 0
 205 00cc 8B4330   	movl 48(%ebx),%eax
 206 00cf 85C0     	testl %eax,%eax
 207              	.loc 1 90 0
 208 00d1 5F       	popl %edi
 209              	.LCFI24:
 210              	.loc 1 97 0
 211 00d2 7407     	je .L55
  98:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 			crypto_free_tfm(priv->tfm);
 212              	.loc 1 98 0
 213 00d4 50       	pushl %eax
 214              	.LCFI25:
 215              	.LCFI26:
 216 00d5 E8FCFFFF 	call crypto_free_tfm
 216      FF
 217 00da 5E       	popl %esi
 218              	.LCFI27:
 219              	.L55:
  99:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 		kfree(priv);
 220              	.loc 1 99 0
 221 00db 53       	pushl %ebx
GAS LISTING  			page 22


 222              	.LCFI28:
 223              	.LCFI29:
 224 00dc E8FCFFFF 	call kfree
 224      FF
 225 00e1 59       	popl %ecx
 226              	.LCFI30:
 227              	.L54:
 100:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	}
 101:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 
 102:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	return NULL;
 228              	.loc 1 102 0
 229 00e2 31D2     	xorl %edx,%edx
 230              	.L6:
 103:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** }
 231              	.loc 1 103 0
 232 00e4 89D0     	movl %edx,%eax
 233 00e6 5A       	popl %edx
 234              	.LCFI31:
 235 00e7 5B       	popl %ebx
 236 00e8 5E       	popl %esi
 237 00e9 5F       	popl %edi
 238 00ea C3       	ret
 239              	.LFE688:
 242              	ieee80211_ccmp_deinit:
 243              	.LFB689:
 104:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 
 105:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** static void ieee80211_ccmp_deinit(void *priv)
 106:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** {
 244              	.loc 1 106 0
 245 00eb 53       	pushl %ebx
 246              	.LCFI32:
 247              	.loc 1 106 0
 248 00ec 8B5C2408 	movl 8(%esp),%ebx
 107:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	struct ieee80211_ccmp_data *_priv = priv;
 108:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	if (_priv && _priv->tfm)
 249              	.loc 1 108 0
 250 00f0 85DB     	testl %ebx,%ebx
 251 00f2 740E     	je .L58
 252 00f4 8B4330   	movl 48(%ebx),%eax
 253 00f7 85C0     	testl %eax,%eax
 254 00f9 7407     	je .L58
 109:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 		crypto_free_tfm(_priv->tfm);
 255              	.loc 1 109 0
 256 00fb 50       	pushl %eax
 257              	.LCFI33:
 258 00fc E8FCFFFF 	call crypto_free_tfm
 258      FF
 259 0101 58       	popl %eax
 260              	.LCFI34:
 261              	.L58:
 110:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	kfree(priv);
 262              	.loc 1 110 0
 263 0102 895C2408 	movl %ebx,8(%esp)
 264 0106 5B       	popl %ebx
 265              	.LCFI35:
 266 0107 E9FCFFFF 	jmp kfree
 266      FF
GAS LISTING  			page 23


 267              	.LFE689:
 270              	ccmp_init_blocks:
 271              	.LFB691:
 111:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** }
 112:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 
 113:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** static inline void xor_block(u8 * b, u8 * a, size_t len)
 114:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** {
 115:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	int i;
 116:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	for (i = 0; i < len; i++)
 117:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 		b[i] ^= a[i];
 118:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** }
 119:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 
 120:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** static void ccmp_init_blocks(struct crypto_tfm *tfm,
 121:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 			     struct ieee80211_hdr_4addr *hdr,
 122:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 			     u8 * pn, size_t dlen, u8 * b0, u8 * auth, u8 * s0)
 123:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** {
 272              	.loc 1 123 0
 273 010c 55       	pushl %ebp
 274              	.LCFI36:
 275 010d 57       	pushl %edi
 276              	.LCFI37:
 277 010e 56       	pushl %esi
 278              	.LCFI38:
 279 010f 53       	pushl %ebx
 280              	.LCFI39:
 281 0110 83EC24   	subl $36,%esp
 282              	.LCFI40:
 283              	.loc 1 123 0
 284 0113 8B6C243C 	movl 60(%esp),%ebp
 124:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	u8 *pos, qc = 0;
 125:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	size_t aad_len;
 126:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	u16 fc;
 127:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	int a4_included, qc_included;
 128:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	u8 aad[2 * AES_BLOCK_LEN];
 129:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 
 130:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	fc = le16_to_cpu(hdr->frame_ctl);
 131:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	a4_included = ((fc & (IEEE80211_FCTL_TODS | IEEE80211_FCTL_FROMDS)) ==
 285              	.loc 1 131 0
 286 0117 0FB74500 	movzwl (%ebp),%eax
 287 011b 25000300 	andl $768,%eax
 287      00
 288 0120 3D000300 	cmpl $768,%eax
 288      00
 289 0125 0F94C0   	sete %al
 290              	.loc 1 123 0
 291 0128 8B5C2448 	movl 72(%esp),%ebx
 292              	.loc 1 131 0
 293 012c 0FB6C0   	movzbl %al,%eax
 294 012f 890424   	movl %eax,(%esp)
 295              	.loc 1 123 0
 296 0132 8B4C2440 	movl 64(%esp),%ecx
 132:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 		       (IEEE80211_FCTL_TODS | IEEE80211_FCTL_FROMDS));
 133:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	qc_included = ((WLAN_FC_GET_TYPE(fc) == IEEE80211_FTYPE_DATA) &&
 134:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 		       (WLAN_FC_GET_STYPE(fc) & 0x08));
 135:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	aad_len = 22;
 136:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	if (a4_included)
 137:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 		aad_len += 6;
GAS LISTING  			page 24


 138:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	if (qc_included) {
 139:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 		pos = (u8 *) & hdr->addr4;
 140:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 		if (a4_included)
 141:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 			pos += 6;
 142:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 		qc = *pos & 0x0f;
 143:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 		aad_len += 2;
 144:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	}
 145:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 
 146:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	/* CCM Initial Block:
 147:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	 * Flag (Include authentication header, M=3 (8-octet MIC),
 148:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	 *       L=1 (2-octet Dlen))
 149:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	 * Nonce: 0x00 | A2 | PN
 150:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	 * Dlen */
 151:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	b0[0] = 0x59;
 297              	.loc 1 151 0
 298 0136 C60359   	movb $89,(%ebx)
 152:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	b0[1] = qc;
 299              	.loc 1 152 0
 300 0139 C6430100 	movb $0,1(%ebx)
 301              	.loc 1 137 0
 302 013d 83F801   	cmpl $1,%eax
 303              	.LBB16:
 304              	.LBB17:
 305              	.loc 4 240 0
 306 0140 8B450A   	movl 10(%ebp),%eax
 307 0143 894302   	movl %eax,2(%ebx)
 308              	.loc 4 241 0
 309 0146 668B450E 	movw 14(%ebp),%ax
 310 014a 66894306 	movw %ax,6(%ebx)
 311              	.LBE17:
 312              	.LBE16:
 313              	.LBB18:
 314              	.LBB19:
 315              	.loc 4 240 0
 316 014e 8B01     	movl (%ecx),%eax
 317 0150 894308   	movl %eax,8(%ebx)
 318              	.loc 4 241 0
 319 0153 668B4104 	movw 4(%ecx),%ax
 320 0157 6689430C 	movw %ax,12(%ebx)
 321              	.LBE19:
 322              	.LBE18:
 153:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	memcpy(b0 + 2, hdr->addr2, ETH_ALEN);
 154:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	memcpy(b0 + 8, pn, CCMP_PN_LEN);
 155:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	b0[14] = (dlen >> 8) & 0xff;
 323              	.loc 1 155 0
 324 015b 8B442444 	movl 68(%esp),%eax
 325              	.loc 1 137 0
 326 015f 19D2     	sbbl %edx,%edx
 327              	.loc 1 155 0
 328 0161 C1E808   	shrl $8,%eax
 329 0164 88430E   	movb %al,14(%ebx)
 330              	.loc 1 137 0
 331 0167 83E2FA   	andl $-6,%edx
 156:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	b0[15] = dlen & 0xff;
 332              	.loc 1 156 0
 333 016a 8A442444 	movb 68(%esp),%al
 334              	.loc 1 137 0
GAS LISTING  			page 25


 335 016e 83C21C   	addl $28,%edx
 336              	.loc 1 156 0
 337 0171 88430F   	movb %al,15(%ebx)
 157:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 
 158:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	/* AAD:
 159:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	 * FC with bits 4..6 and 11..13 masked to zero; 14 is always one
 160:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	 * A1 | A2 | A3
 161:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	 * SC with bits 4..15 (seq#) masked to zero
 162:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	 * A4 (if present)
 163:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	 * QC (if present)
 164:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	 */
 165:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	pos = (u8 *) hdr;
 166:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	aad[0] = 0;		/* aad_len >> 8 */
 338              	.loc 1 166 0
 339 0174 C6442404 	movb $0,4(%esp)
 339      00
 167:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	aad[1] = aad_len & 0xff;
 340              	.loc 1 167 0
 341 0179 88542405 	movb %dl,5(%esp)
 168:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	aad[2] = pos[0] & 0x8f;
 342              	.loc 1 168 0
 343 017d 8A4500   	movb (%ebp),%al
 344 0180 83E08F   	andl $-113,%eax
 345 0183 88442406 	movb %al,6(%esp)
 169:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	aad[3] = pos[1] & 0xc7;
 346              	.loc 1 169 0
 347 0187 8A4501   	movb 1(%ebp),%al
 348 018a 83E0C7   	andl $-57,%eax
 349 018d 88442407 	movb %al,7(%esp)
 350              	.LBB20:
 351              	.loc 4 227 0
 352 0191 8D7C2408 	leal 8(%esp),%edi
 353 0195 8D7504   	leal 4(%ebp),%esi
 354              	.LBB21:
 355              	.loc 4 260 0
 356              	
 357 0198 A5       	movsl
 358              	.loc 4 262 0
 359 0199 A5       	movsl
 360              	.loc 4 264 0
 361 019a A5       	movsl
 362              	.loc 4 266 0
 363 019b A5       	movsl
 364              	.loc 4 269 0
 365              	
 366 019c B9020000 	movl $2,%ecx
 366      00
 367              	.loc 4 275 0
 368              	
 369 01a1 66A5     	movsw
 370              	
 371              	.LBE21:
 372              	.LBE20:
 170:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	memcpy(aad + 4, hdr->addr1, 3 * ETH_ALEN);
 171:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	pos = (u8 *) & hdr->seq_ctl;
 172:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	aad[22] = pos[0] & 0x0f;
 373              	.loc 1 172 0
GAS LISTING  			page 26


 374 01a3 8A4516   	movb 22(%ebp),%al
 375 01a6 83E00F   	andl $15,%eax
 376 01a9 8844241A 	movb %al,26(%esp)
 173:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	aad[23] = 0;		/* all bits masked */
 377              	.loc 1 173 0
 378 01ad C644241B 	movb $0,27(%esp)
 378      00
 379              	.LBB22:
 380              	.loc 4 420 0
 381 01b2 8D7C241C 	leal 28(%esp),%edi
 382              	.LBB23:
 383              	.LBB24:
 384              	.loc 4 448 0
 385 01b6 31C0     	xorl %eax,%eax
 386              	
 387 01b8 F3AB     	rep
 388              	
 389              	.LBE24:
 390              	.LBE23:
 391              	.LBE22:
 174:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	memset(aad + 24, 0, 8);
 175:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	if (a4_included)
 392              	.loc 1 175 0
 393 01ba 833C2400 	cmpl $0,(%esp)
 394 01be 7410     	je .L142
 395              	.LBB25:
 396              	.LBB26:
 397              	.loc 4 240 0
 398 01c0 8B4518   	movl 24(%ebp),%eax
 399 01c3 8944241C 	movl %eax,28(%esp)
 400              	.loc 4 241 0
 401 01c7 668B451C 	movw 28(%ebp),%ax
 402 01cb 66894424 	movw %ax,32(%esp)
 402      20
 403              	.L142:
 404              	.LBE26:
 405              	.LBE25:
 176:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 		memcpy(aad + 24, hdr->addr4, ETH_ALEN);
 177:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	if (qc_included) {
 178:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 		aad[a4_included ? 30 : 24] = qc;
 179:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 		/* rest of QC masked */
 180:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	}
 181:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 
 182:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	/* Start with the first block and AAD */
 183:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	ieee80211_ccmp_aes_encrypt(tfm, b0, auth);
 406              	.loc 1 183 0
 407 01d0 FF74244C 	pushl 76(%esp)
 408              	.LCFI41:
 409 01d4 53       	pushl %ebx
 410              	.LCFI42:
 411 01d5 FF742440 	pushl 64(%esp)
 412              	.LCFI43:
 413 01d9 E822FEFF 	call ieee80211_ccmp_aes_encrypt
 413      FF
 414              	.loc 1 114 0
 415 01de 83C40C   	addl $12,%esp
 416              	.LCFI44:
GAS LISTING  			page 27


 417              	.LBB27:
 418 01e1 8D4C2404 	leal 4(%esp),%ecx
 419              	.LBB28:
 420              	.loc 1 116 0
 421 01e5 31D2     	xorl %edx,%edx
 422              	.L171:
 423              	.loc 1 117 0
 424 01e7 8A0411   	movb (%ecx,%edx),%al
 425 01ea 8B74244C 	movl 76(%esp),%esi
 426 01ee 300416   	xorb %al,(%esi,%edx)
 427              	.loc 1 116 0
 428 01f1 42       	incl %edx
 429 01f2 83FA10   	cmpl $16,%edx
 430 01f5 72F0     	jb .L171
 431              	.LBE28:
 432              	.LBE27:
 184:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	xor_block(auth, aad, AES_BLOCK_LEN);
 185:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	ieee80211_ccmp_aes_encrypt(tfm, auth, auth);
 433              	.loc 1 185 0
 434 01f7 56       	pushl %esi
 435              	.LCFI45:
 436 01f8 56       	pushl %esi
 437              	.LCFI46:
 438 01f9 FF742440 	pushl 64(%esp)
 439              	.LCFI47:
 440 01fd E8FEFDFF 	call ieee80211_ccmp_aes_encrypt
 440      FF
 441              	.loc 1 114 0
 442 0202 83C40C   	addl $12,%esp
 443              	.LCFI48:
 444              	.LBB29:
 445 0205 8D4C2414 	leal 20(%esp),%ecx
 446              	.LBB30:
 447              	.loc 1 116 0
 448 0209 31D2     	xorl %edx,%edx
 449              	.L176:
 450              	.loc 1 117 0
 451 020b 8A0411   	movb (%ecx,%edx),%al
 452 020e 8B74244C 	movl 76(%esp),%esi
 453 0212 300416   	xorb %al,(%esi,%edx)
 454              	.loc 1 116 0
 455 0215 42       	incl %edx
 456 0216 83FA10   	cmpl $16,%edx
 457 0219 72F0     	jb .L176
 458              	.LBE30:
 459              	.LBE29:
 186:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	xor_block(auth, &aad[AES_BLOCK_LEN], AES_BLOCK_LEN);
 187:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	ieee80211_ccmp_aes_encrypt(tfm, auth, auth);
 460              	.loc 1 187 0
 461 021b 56       	pushl %esi
 462              	.LCFI49:
 463 021c 56       	pushl %esi
 464              	.LCFI50:
 465 021d FF742440 	pushl 64(%esp)
 466              	.LCFI51:
 467 0221 E8DAFDFF 	call ieee80211_ccmp_aes_encrypt
 467      FF
GAS LISTING  			page 28


 188:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	b0[0] &= 0x07;
 468              	.loc 1 188 0
 469 0226 802307   	andb $7,(%ebx)
 189:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	b0[14] = b0[15] = 0;
 470              	.loc 1 189 0
 471 0229 C6430F00 	movb $0,15(%ebx)
 472 022d C6430E00 	movb $0,14(%ebx)
 190:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	ieee80211_ccmp_aes_encrypt(tfm, b0, s0);
 473              	.loc 1 190 0
 474 0231 FF74245C 	pushl 92(%esp)
 475              	.LCFI52:
 476 0235 53       	pushl %ebx
 477              	.LCFI53:
 478 0236 FF74244C 	pushl 76(%esp)
 479              	.LCFI54:
 480              	.LCFI55:
 481 023a E8C1FDFF 	call ieee80211_ccmp_aes_encrypt
 481      FF
 482 023f 83C43C   	addl $60,%esp
 483 0242 5B       	popl %ebx
 484 0243 5E       	popl %esi
 485 0244 5F       	popl %edi
 486 0245 5D       	popl %ebp
 487 0246 C3       	ret
 488              	.LCFI56:
 489              	.LFE691:
 492              	ieee80211_ccmp_hdr:
 493              	.LFB692:
 191:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** }
 192:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 
 193:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** static int ieee80211_ccmp_hdr(struct sk_buff *skb, int hdr_len,
 194:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 			      u8 *aeskey, int keylen, void *priv)
 195:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** {
 494              	.loc 1 195 0
 495 0247 55       	pushl %ebp
 496              	.LCFI57:
 497 0248 57       	pushl %edi
 498              	.LCFI58:
 499 0249 56       	pushl %esi
 500              	.LCFI59:
 501 024a 53       	pushl %ebx
 502              	.LCFI60:
 503              	.loc 1 195 0
 504 024b 8B6C2414 	movl 20(%esp),%ebp
 505              	.LBB31:
 506              	.LBB32:
 507              	.file 5 "include/linux/skbuff.h"
   1:include/linux/skbuff.h **** /*
   2:include/linux/skbuff.h ****  *	Definitions for the 'struct sk_buff' memory handlers.
   3:include/linux/skbuff.h ****  *
   4:include/linux/skbuff.h ****  *	Authors:
   5:include/linux/skbuff.h ****  *		Alan Cox, <gw4pts@gw4pts.ampr.org>
   6:include/linux/skbuff.h ****  *		Florian La Roche, <rzsfl@rz.uni-sb.de>
   7:include/linux/skbuff.h ****  *
   8:include/linux/skbuff.h ****  *	This program is free software; you can redistribute it and/or
   9:include/linux/skbuff.h ****  *	modify it under the terms of the GNU General Public License
  10:include/linux/skbuff.h ****  *	as published by the Free Software Foundation; either version
GAS LISTING  			page 29


  11:include/linux/skbuff.h ****  *	2 of the License, or (at your option) any later version.
  12:include/linux/skbuff.h ****  */
  13:include/linux/skbuff.h **** 
  14:include/linux/skbuff.h **** #ifndef _LINUX_SKBUFF_H
  15:include/linux/skbuff.h **** #define _LINUX_SKBUFF_H
  16:include/linux/skbuff.h **** 
  17:include/linux/skbuff.h **** #include <linux/config.h>
  18:include/linux/skbuff.h **** #include <linux/kernel.h>
  19:include/linux/skbuff.h **** #include <linux/compiler.h>
  20:include/linux/skbuff.h **** #include <linux/time.h>
  21:include/linux/skbuff.h **** #include <linux/cache.h>
  22:include/linux/skbuff.h **** 
  23:include/linux/skbuff.h **** #include <asm/atomic.h>
  24:include/linux/skbuff.h **** #include <asm/types.h>
  25:include/linux/skbuff.h **** #include <linux/spinlock.h>
  26:include/linux/skbuff.h **** #include <linux/mm.h>
  27:include/linux/skbuff.h **** #include <linux/highmem.h>
  28:include/linux/skbuff.h **** #include <linux/poll.h>
  29:include/linux/skbuff.h **** #include <linux/net.h>
  30:include/linux/skbuff.h **** #include <net/checksum.h>
  31:include/linux/skbuff.h **** 
  32:include/linux/skbuff.h **** #define HAVE_ALLOC_SKB		/* For the drivers to know */
  33:include/linux/skbuff.h **** #define HAVE_ALIGNABLE_SKB	/* Ditto 8)		   */
  34:include/linux/skbuff.h **** #define SLAB_SKB 		/* Slabified skbuffs 	   */
  35:include/linux/skbuff.h **** 
  36:include/linux/skbuff.h **** #define CHECKSUM_NONE 0
  37:include/linux/skbuff.h **** #define CHECKSUM_HW 1
  38:include/linux/skbuff.h **** #define CHECKSUM_UNNECESSARY 2
  39:include/linux/skbuff.h **** 
  40:include/linux/skbuff.h **** #define SKB_DATA_ALIGN(X)	(((X) + (SMP_CACHE_BYTES - 1)) & \
  41:include/linux/skbuff.h **** 				 ~(SMP_CACHE_BYTES - 1))
  42:include/linux/skbuff.h **** #define SKB_MAX_ORDER(X, ORDER)	(((PAGE_SIZE << (ORDER)) - (X) - \
  43:include/linux/skbuff.h **** 				  sizeof(struct skb_shared_info)) & \
  44:include/linux/skbuff.h **** 				  ~(SMP_CACHE_BYTES - 1))
  45:include/linux/skbuff.h **** #define SKB_MAX_HEAD(X)		(SKB_MAX_ORDER((X), 0))
  46:include/linux/skbuff.h **** #define SKB_MAX_ALLOC		(SKB_MAX_ORDER(0, 2))
  47:include/linux/skbuff.h **** 
  48:include/linux/skbuff.h **** /* A. Checksumming of received packets by device.
  49:include/linux/skbuff.h ****  *
  50:include/linux/skbuff.h ****  *	NONE: device failed to checksum this packet.
  51:include/linux/skbuff.h ****  *		skb->csum is undefined.
  52:include/linux/skbuff.h ****  *
  53:include/linux/skbuff.h ****  *	UNNECESSARY: device parsed packet and wouldbe verified checksum.
  54:include/linux/skbuff.h ****  *		skb->csum is undefined.
  55:include/linux/skbuff.h ****  *	      It is bad option, but, unfortunately, many of vendors do this.
  56:include/linux/skbuff.h ****  *	      Apparently with secret goal to sell you new device, when you
  57:include/linux/skbuff.h ****  *	      will add new protocol to your host. F.e. IPv6. 8)
  58:include/linux/skbuff.h ****  *
  59:include/linux/skbuff.h ****  *	HW: the most generic way. Device supplied checksum of _all_
  60:include/linux/skbuff.h ****  *	    the packet as seen by netif_rx in skb->csum.
  61:include/linux/skbuff.h ****  *	    NOTE: Even if device supports only some protocols, but
  62:include/linux/skbuff.h ****  *	    is able to produce some skb->csum, it MUST use HW,
  63:include/linux/skbuff.h ****  *	    not UNNECESSARY.
  64:include/linux/skbuff.h ****  *
  65:include/linux/skbuff.h ****  * B. Checksumming on output.
  66:include/linux/skbuff.h ****  *
  67:include/linux/skbuff.h ****  *	NONE: skb is checksummed by protocol or csum is not required.
GAS LISTING  			page 30


  68:include/linux/skbuff.h ****  *
  69:include/linux/skbuff.h ****  *	HW: device is required to csum packet as seen by hard_start_xmit
  70:include/linux/skbuff.h ****  *	from skb->h.raw to the end and to record the checksum
  71:include/linux/skbuff.h ****  *	at skb->h.raw+skb->csum.
  72:include/linux/skbuff.h ****  *
  73:include/linux/skbuff.h ****  *	Device must show its capabilities in dev->features, set
  74:include/linux/skbuff.h ****  *	at device setup time.
  75:include/linux/skbuff.h ****  *	NETIF_F_HW_CSUM	- it is clever device, it is able to checksum
  76:include/linux/skbuff.h ****  *			  everything.
  77:include/linux/skbuff.h ****  *	NETIF_F_NO_CSUM - loopback or reliable single hop media.
  78:include/linux/skbuff.h ****  *	NETIF_F_IP_CSUM - device is dumb. It is able to csum only
  79:include/linux/skbuff.h ****  *			  TCP/UDP over IPv4. Sigh. Vendors like this
  80:include/linux/skbuff.h ****  *			  way by an unknown reason. Though, see comment above
  81:include/linux/skbuff.h ****  *			  about CHECKSUM_UNNECESSARY. 8)
  82:include/linux/skbuff.h ****  *
  83:include/linux/skbuff.h ****  *	Any questions? No questions, good. 		--ANK
  84:include/linux/skbuff.h ****  */
  85:include/linux/skbuff.h **** 
  86:include/linux/skbuff.h **** struct net_device;
  87:include/linux/skbuff.h **** 
  88:include/linux/skbuff.h **** #ifdef CONFIG_NETFILTER
  89:include/linux/skbuff.h **** struct nf_conntrack {
  90:include/linux/skbuff.h **** 	atomic_t use;
  91:include/linux/skbuff.h **** 	void (*destroy)(struct nf_conntrack *);
  92:include/linux/skbuff.h **** };
  93:include/linux/skbuff.h **** 
  94:include/linux/skbuff.h **** #ifdef CONFIG_BRIDGE_NETFILTER
  95:include/linux/skbuff.h **** struct nf_bridge_info {
  96:include/linux/skbuff.h **** 	atomic_t use;
  97:include/linux/skbuff.h **** 	struct net_device *physindev;
  98:include/linux/skbuff.h **** 	struct net_device *physoutdev;
  99:include/linux/skbuff.h **** #if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)
 100:include/linux/skbuff.h **** 	struct net_device *netoutdev;
 101:include/linux/skbuff.h **** #endif
 102:include/linux/skbuff.h **** 	unsigned int mask;
 103:include/linux/skbuff.h **** 	unsigned long data[32 / sizeof(unsigned long)];
 104:include/linux/skbuff.h **** };
 105:include/linux/skbuff.h **** #endif
 106:include/linux/skbuff.h **** 
 107:include/linux/skbuff.h **** #endif
 108:include/linux/skbuff.h **** 
 109:include/linux/skbuff.h **** struct sk_buff_head {
 110:include/linux/skbuff.h **** 	/* These two members must be first. */
 111:include/linux/skbuff.h **** 	struct sk_buff	*next;
 112:include/linux/skbuff.h **** 	struct sk_buff	*prev;
 113:include/linux/skbuff.h **** 
 114:include/linux/skbuff.h **** 	__u32		qlen;
 115:include/linux/skbuff.h **** 	spinlock_t	lock;
 116:include/linux/skbuff.h **** };
 117:include/linux/skbuff.h **** 
 118:include/linux/skbuff.h **** struct sk_buff;
 119:include/linux/skbuff.h **** 
 120:include/linux/skbuff.h **** /* To allow 64K frame to be packed as single skb without frag_list */
 121:include/linux/skbuff.h **** #define MAX_SKB_FRAGS (65536/PAGE_SIZE + 2)
 122:include/linux/skbuff.h **** 
 123:include/linux/skbuff.h **** typedef struct skb_frag_struct skb_frag_t;
 124:include/linux/skbuff.h **** 
GAS LISTING  			page 31


 125:include/linux/skbuff.h **** struct skb_frag_struct {
 126:include/linux/skbuff.h **** 	struct page *page;
 127:include/linux/skbuff.h **** 	__u16 page_offset;
 128:include/linux/skbuff.h **** 	__u16 size;
 129:include/linux/skbuff.h **** };
 130:include/linux/skbuff.h **** 
 131:include/linux/skbuff.h **** /* This data is invariant across clones and lives at
 132:include/linux/skbuff.h ****  * the end of the header data, ie. at skb->end.
 133:include/linux/skbuff.h ****  */
 134:include/linux/skbuff.h **** struct skb_shared_info {
 135:include/linux/skbuff.h **** 	atomic_t	dataref;
 136:include/linux/skbuff.h **** 	unsigned int	nr_frags;
 137:include/linux/skbuff.h **** 	unsigned short	tso_size;
 138:include/linux/skbuff.h **** 	unsigned short	tso_segs;
 139:include/linux/skbuff.h **** 	struct sk_buff	*frag_list;
 140:include/linux/skbuff.h **** 	skb_frag_t	frags[MAX_SKB_FRAGS];
 141:include/linux/skbuff.h **** };
 142:include/linux/skbuff.h **** 
 143:include/linux/skbuff.h **** /* We divide dataref into two halves.  The higher 16 bits hold references
 144:include/linux/skbuff.h ****  * to the payload part of skb->data.  The lower 16 bits hold references to
 145:include/linux/skbuff.h ****  * the entire skb->data.  It is up to the users of the skb to agree on
 146:include/linux/skbuff.h ****  * where the payload starts.
 147:include/linux/skbuff.h ****  *
 148:include/linux/skbuff.h ****  * All users must obey the rule that the skb->data reference count must be
 149:include/linux/skbuff.h ****  * greater than or equal to the payload reference count.
 150:include/linux/skbuff.h ****  *
 151:include/linux/skbuff.h ****  * Holding a reference to the payload part means that the user does not
 152:include/linux/skbuff.h ****  * care about modifications to the header part of skb->data.
 153:include/linux/skbuff.h ****  */
 154:include/linux/skbuff.h **** #define SKB_DATAREF_SHIFT 16
 155:include/linux/skbuff.h **** #define SKB_DATAREF_MASK ((1 << SKB_DATAREF_SHIFT) - 1)
 156:include/linux/skbuff.h **** 
 157:include/linux/skbuff.h **** /** 
 158:include/linux/skbuff.h ****  *	struct sk_buff - socket buffer
 159:include/linux/skbuff.h ****  *	@next: Next buffer in list
 160:include/linux/skbuff.h ****  *	@prev: Previous buffer in list
 161:include/linux/skbuff.h ****  *	@list: List we are on
 162:include/linux/skbuff.h ****  *	@sk: Socket we are owned by
 163:include/linux/skbuff.h ****  *	@stamp: Time we arrived
 164:include/linux/skbuff.h ****  *	@dev: Device we arrived on/are leaving by
 165:include/linux/skbuff.h ****  *	@input_dev: Device we arrived on
 166:include/linux/skbuff.h ****  *      @real_dev: The real device we are using
 167:include/linux/skbuff.h ****  *	@h: Transport layer header
 168:include/linux/skbuff.h ****  *	@nh: Network layer header
 169:include/linux/skbuff.h ****  *	@mac: Link layer header
 170:include/linux/skbuff.h ****  *	@dst: destination entry
 171:include/linux/skbuff.h ****  *	@sp: the security path, used for xfrm
 172:include/linux/skbuff.h ****  *	@cb: Control buffer. Free for use by every layer. Put private vars here
 173:include/linux/skbuff.h ****  *	@len: Length of actual data
 174:include/linux/skbuff.h ****  *	@data_len: Data length
 175:include/linux/skbuff.h ****  *	@mac_len: Length of link layer header
 176:include/linux/skbuff.h ****  *	@csum: Checksum
 177:include/linux/skbuff.h ****  *	@local_df: allow local fragmentation
 178:include/linux/skbuff.h ****  *	@cloned: Head may be cloned (check refcnt to be sure)
 179:include/linux/skbuff.h ****  *	@nohdr: Payload reference only, must not modify header
 180:include/linux/skbuff.h ****  *	@pkt_type: Packet class
 181:include/linux/skbuff.h ****  *	@ip_summed: Driver fed us an IP checksum
GAS LISTING  			page 32


 182:include/linux/skbuff.h ****  *	@priority: Packet queueing priority
 183:include/linux/skbuff.h ****  *	@users: User count - see {datagram,tcp}.c
 184:include/linux/skbuff.h ****  *	@protocol: Packet protocol from driver
 185:include/linux/skbuff.h ****  *	@security: Security level of packet
 186:include/linux/skbuff.h ****  *	@truesize: Buffer size 
 187:include/linux/skbuff.h ****  *	@head: Head of buffer
 188:include/linux/skbuff.h ****  *	@data: Data head pointer
 189:include/linux/skbuff.h ****  *	@tail: Tail pointer
 190:include/linux/skbuff.h ****  *	@end: End pointer
 191:include/linux/skbuff.h ****  *	@destructor: Destruct function
 192:include/linux/skbuff.h ****  *	@nfmark: Can be used for communication between hooks
 193:include/linux/skbuff.h ****  *	@nfcache: Cache info
 194:include/linux/skbuff.h ****  *	@nfct: Associated connection, if any
 195:include/linux/skbuff.h ****  *	@nfctinfo: Relationship of this skb to the connection
 196:include/linux/skbuff.h ****  *	@nf_debug: Netfilter debugging
 197:include/linux/skbuff.h ****  *	@nf_bridge: Saved data about a bridged frame - see br_netfilter.c
 198:include/linux/skbuff.h ****  *      @private: Data which is private to the HIPPI implementation
 199:include/linux/skbuff.h ****  *	@tc_index: Traffic control index
 200:include/linux/skbuff.h ****  *	@tc_verd: traffic control verdict
 201:include/linux/skbuff.h ****  *	@tc_classid: traffic control classid
 202:include/linux/skbuff.h ****  */
 203:include/linux/skbuff.h **** 
 204:include/linux/skbuff.h **** struct sk_buff {
 205:include/linux/skbuff.h **** 	/* These two members must be first. */
 206:include/linux/skbuff.h **** 	struct sk_buff		*next;
 207:include/linux/skbuff.h **** 	struct sk_buff		*prev;
 208:include/linux/skbuff.h **** 
 209:include/linux/skbuff.h **** 	struct sk_buff_head	*list;
 210:include/linux/skbuff.h **** 	struct sock		*sk;
 211:include/linux/skbuff.h **** 	struct timeval		stamp;
 212:include/linux/skbuff.h **** 	struct net_device	*dev;
 213:include/linux/skbuff.h **** 	struct net_device	*input_dev;
 214:include/linux/skbuff.h **** 	struct net_device	*real_dev;
 215:include/linux/skbuff.h **** 
 216:include/linux/skbuff.h **** 	union {
 217:include/linux/skbuff.h **** 		struct tcphdr	*th;
 218:include/linux/skbuff.h **** 		struct udphdr	*uh;
 219:include/linux/skbuff.h **** 		struct icmphdr	*icmph;
 220:include/linux/skbuff.h **** 		struct igmphdr	*igmph;
 221:include/linux/skbuff.h **** 		struct iphdr	*ipiph;
 222:include/linux/skbuff.h **** 		struct ipv6hdr	*ipv6h;
 223:include/linux/skbuff.h **** 		unsigned char	*raw;
 224:include/linux/skbuff.h **** 	} h;
 225:include/linux/skbuff.h **** 
 226:include/linux/skbuff.h **** 	union {
 227:include/linux/skbuff.h **** 		struct iphdr	*iph;
 228:include/linux/skbuff.h **** 		struct ipv6hdr	*ipv6h;
 229:include/linux/skbuff.h **** 		struct arphdr	*arph;
 230:include/linux/skbuff.h **** 		unsigned char	*raw;
 231:include/linux/skbuff.h **** 	} nh;
 232:include/linux/skbuff.h **** 
 233:include/linux/skbuff.h **** 	union {
 234:include/linux/skbuff.h **** 	  	unsigned char 	*raw;
 235:include/linux/skbuff.h **** 	} mac;
 236:include/linux/skbuff.h **** 
 237:include/linux/skbuff.h **** 	struct  dst_entry	*dst;
 238:include/linux/skbuff.h **** 	struct	sec_path	*sp;
GAS LISTING  			page 33


 239:include/linux/skbuff.h **** 
 240:include/linux/skbuff.h **** 	/*
 241:include/linux/skbuff.h **** 	 * This is the control buffer. It is free to use for every
 242:include/linux/skbuff.h **** 	 * layer. Please put your private variables there. If you
 243:include/linux/skbuff.h **** 	 * want to keep them across layers you have to do a skb_clone()
 244:include/linux/skbuff.h **** 	 * first. This is owned by whoever has the skb queued ATM.
 245:include/linux/skbuff.h **** 	 */
 246:include/linux/skbuff.h **** 	char			cb[40];
 247:include/linux/skbuff.h **** 
 248:include/linux/skbuff.h **** 	unsigned int		len,
 249:include/linux/skbuff.h **** 				data_len,
 250:include/linux/skbuff.h **** 				mac_len,
 251:include/linux/skbuff.h **** 				csum;
 252:include/linux/skbuff.h **** 	unsigned char		local_df,
 253:include/linux/skbuff.h **** 				cloned:1,
 254:include/linux/skbuff.h **** 				nohdr:1,
 255:include/linux/skbuff.h **** 				pkt_type,
 256:include/linux/skbuff.h **** 				ip_summed;
 257:include/linux/skbuff.h **** 	__u32			priority;
 258:include/linux/skbuff.h **** 	unsigned short		protocol,
 259:include/linux/skbuff.h **** 				security;
 260:include/linux/skbuff.h **** 
 261:include/linux/skbuff.h **** 	void			(*destructor)(struct sk_buff *skb);
 262:include/linux/skbuff.h **** #ifdef CONFIG_NETFILTER
 263:include/linux/skbuff.h ****         unsigned long		nfmark;
 264:include/linux/skbuff.h **** 	__u32			nfcache;
 265:include/linux/skbuff.h **** 	__u32			nfctinfo;
 266:include/linux/skbuff.h **** 	struct nf_conntrack	*nfct;
 267:include/linux/skbuff.h **** #ifdef CONFIG_NETFILTER_DEBUG
 268:include/linux/skbuff.h ****         unsigned int		nf_debug;
 269:include/linux/skbuff.h **** #endif
 270:include/linux/skbuff.h **** #ifdef CONFIG_BRIDGE_NETFILTER
 271:include/linux/skbuff.h **** 	struct nf_bridge_info	*nf_bridge;
 272:include/linux/skbuff.h **** #endif
 273:include/linux/skbuff.h **** #endif /* CONFIG_NETFILTER */
 274:include/linux/skbuff.h **** #if defined(CONFIG_HIPPI)
 275:include/linux/skbuff.h **** 	union {
 276:include/linux/skbuff.h **** 		__u32		ifield;
 277:include/linux/skbuff.h **** 	} private;
 278:include/linux/skbuff.h **** #endif
 279:include/linux/skbuff.h **** #ifdef CONFIG_NET_SCHED
 280:include/linux/skbuff.h ****        __u32			tc_index;        /* traffic control index */
 281:include/linux/skbuff.h **** #ifdef CONFIG_NET_CLS_ACT
 282:include/linux/skbuff.h **** 	__u32           tc_verd;               /* traffic control verdict */
 283:include/linux/skbuff.h **** 	__u32           tc_classid;            /* traffic control classid */
 284:include/linux/skbuff.h **** #endif
 285:include/linux/skbuff.h **** 
 286:include/linux/skbuff.h **** #endif
 287:include/linux/skbuff.h **** 
 288:include/linux/skbuff.h **** 
 289:include/linux/skbuff.h **** 	/* These elements must be at the end, see alloc_skb() for details.  */
 290:include/linux/skbuff.h **** 	unsigned int		truesize;
 291:include/linux/skbuff.h **** 	atomic_t		users;
 292:include/linux/skbuff.h **** 	unsigned char		*head,
 293:include/linux/skbuff.h **** 				*data,
 294:include/linux/skbuff.h **** 				*tail,
 295:include/linux/skbuff.h **** 				*end;
GAS LISTING  			page 34


 296:include/linux/skbuff.h **** };
 297:include/linux/skbuff.h **** 
 298:include/linux/skbuff.h **** #ifdef __KERNEL__
 299:include/linux/skbuff.h **** /*
 300:include/linux/skbuff.h ****  *	Handling routines are only of interest to the kernel
 301:include/linux/skbuff.h ****  */
 302:include/linux/skbuff.h **** #include <linux/slab.h>
 303:include/linux/skbuff.h **** 
 304:include/linux/skbuff.h **** #include <asm/system.h>
 305:include/linux/skbuff.h **** 
 306:include/linux/skbuff.h **** extern void	       __kfree_skb(struct sk_buff *skb);
 307:include/linux/skbuff.h **** extern struct sk_buff *alloc_skb(unsigned int size, int priority);
 308:include/linux/skbuff.h **** extern struct sk_buff *alloc_skb_from_cache(kmem_cache_t *cp,
 309:include/linux/skbuff.h **** 					    unsigned int size, int priority);
 310:include/linux/skbuff.h **** extern void	       kfree_skbmem(struct sk_buff *skb);
 311:include/linux/skbuff.h **** extern struct sk_buff *skb_clone(struct sk_buff *skb, int priority);
 312:include/linux/skbuff.h **** extern struct sk_buff *skb_copy(const struct sk_buff *skb, int priority);
 313:include/linux/skbuff.h **** extern struct sk_buff *pskb_copy(struct sk_buff *skb, int gfp_mask);
 314:include/linux/skbuff.h **** extern int	       pskb_expand_head(struct sk_buff *skb,
 315:include/linux/skbuff.h **** 					int nhead, int ntail, int gfp_mask);
 316:include/linux/skbuff.h **** extern struct sk_buff *skb_realloc_headroom(struct sk_buff *skb,
 317:include/linux/skbuff.h **** 					    unsigned int headroom);
 318:include/linux/skbuff.h **** extern struct sk_buff *skb_copy_expand(const struct sk_buff *skb,
 319:include/linux/skbuff.h **** 				       int newheadroom, int newtailroom,
 320:include/linux/skbuff.h **** 				       int priority);
 321:include/linux/skbuff.h **** extern struct sk_buff *		skb_pad(struct sk_buff *skb, int pad);
 322:include/linux/skbuff.h **** #define dev_kfree_skb(a)	kfree_skb(a)
 323:include/linux/skbuff.h **** extern void	      skb_over_panic(struct sk_buff *skb, int len,
 324:include/linux/skbuff.h **** 				     void *here);
 325:include/linux/skbuff.h **** extern void	      skb_under_panic(struct sk_buff *skb, int len,
 326:include/linux/skbuff.h **** 				      void *here);
 327:include/linux/skbuff.h **** 
 328:include/linux/skbuff.h **** /* Internal */
 329:include/linux/skbuff.h **** #define skb_shinfo(SKB)		((struct skb_shared_info *)((SKB)->end))
 330:include/linux/skbuff.h **** 
 331:include/linux/skbuff.h **** /**
 332:include/linux/skbuff.h ****  *	skb_queue_empty - check if a queue is empty
 333:include/linux/skbuff.h ****  *	@list: queue head
 334:include/linux/skbuff.h ****  *
 335:include/linux/skbuff.h ****  *	Returns true if the queue is empty, false otherwise.
 336:include/linux/skbuff.h ****  */
 337:include/linux/skbuff.h **** static inline int skb_queue_empty(const struct sk_buff_head *list)
 338:include/linux/skbuff.h **** {
 339:include/linux/skbuff.h **** 	return list->next == (struct sk_buff *)list;
 340:include/linux/skbuff.h **** }
 341:include/linux/skbuff.h **** 
 342:include/linux/skbuff.h **** /**
 343:include/linux/skbuff.h ****  *	skb_get - reference buffer
 344:include/linux/skbuff.h ****  *	@skb: buffer to reference
 345:include/linux/skbuff.h ****  *
 346:include/linux/skbuff.h ****  *	Makes another reference to a socket buffer and returns a pointer
 347:include/linux/skbuff.h ****  *	to the buffer.
 348:include/linux/skbuff.h ****  */
 349:include/linux/skbuff.h **** static inline struct sk_buff *skb_get(struct sk_buff *skb)
 350:include/linux/skbuff.h **** {
 351:include/linux/skbuff.h **** 	atomic_inc(&skb->users);
 352:include/linux/skbuff.h **** 	return skb;
GAS LISTING  			page 35


 353:include/linux/skbuff.h **** }
 354:include/linux/skbuff.h **** 
 355:include/linux/skbuff.h **** /*
 356:include/linux/skbuff.h ****  * If users == 1, we are the only owner and are can avoid redundant
 357:include/linux/skbuff.h ****  * atomic change.
 358:include/linux/skbuff.h ****  */
 359:include/linux/skbuff.h **** 
 360:include/linux/skbuff.h **** /**
 361:include/linux/skbuff.h ****  *	kfree_skb - free an sk_buff
 362:include/linux/skbuff.h ****  *	@skb: buffer to free
 363:include/linux/skbuff.h ****  *
 364:include/linux/skbuff.h ****  *	Drop a reference to the buffer and free it if the usage count has
 365:include/linux/skbuff.h ****  *	hit zero.
 366:include/linux/skbuff.h ****  */
 367:include/linux/skbuff.h **** static inline void kfree_skb(struct sk_buff *skb)
 368:include/linux/skbuff.h **** {
 369:include/linux/skbuff.h **** 	if (likely(atomic_read(&skb->users) == 1))
 370:include/linux/skbuff.h **** 		smp_rmb();
 371:include/linux/skbuff.h **** 	else if (likely(!atomic_dec_and_test(&skb->users)))
 372:include/linux/skbuff.h **** 		return;
 373:include/linux/skbuff.h **** 	__kfree_skb(skb);
 374:include/linux/skbuff.h **** }
 375:include/linux/skbuff.h **** 
 376:include/linux/skbuff.h **** /**
 377:include/linux/skbuff.h ****  *	skb_cloned - is the buffer a clone
 378:include/linux/skbuff.h ****  *	@skb: buffer to check
 379:include/linux/skbuff.h ****  *
 380:include/linux/skbuff.h ****  *	Returns true if the buffer was generated with skb_clone() and is
 381:include/linux/skbuff.h ****  *	one of multiple shared copies of the buffer. Cloned buffers are
 382:include/linux/skbuff.h ****  *	shared data so must not be written to under normal circumstances.
 383:include/linux/skbuff.h ****  */
 384:include/linux/skbuff.h **** static inline int skb_cloned(const struct sk_buff *skb)
 385:include/linux/skbuff.h **** {
 386:include/linux/skbuff.h **** 	return skb->cloned &&
 387:include/linux/skbuff.h **** 	       (atomic_read(&skb_shinfo(skb)->dataref) & SKB_DATAREF_MASK) != 1;
 388:include/linux/skbuff.h **** }
 389:include/linux/skbuff.h **** 
 390:include/linux/skbuff.h **** /**
 391:include/linux/skbuff.h ****  *	skb_header_cloned - is the header a clone
 392:include/linux/skbuff.h ****  *	@skb: buffer to check
 393:include/linux/skbuff.h ****  *
 394:include/linux/skbuff.h ****  *	Returns true if modifying the header part of the buffer requires
 395:include/linux/skbuff.h ****  *	the data to be copied.
 396:include/linux/skbuff.h ****  */
 397:include/linux/skbuff.h **** static inline int skb_header_cloned(const struct sk_buff *skb)
 398:include/linux/skbuff.h **** {
 399:include/linux/skbuff.h **** 	int dataref;
 400:include/linux/skbuff.h **** 
 401:include/linux/skbuff.h **** 	if (!skb->cloned)
 402:include/linux/skbuff.h **** 		return 0;
 403:include/linux/skbuff.h **** 
 404:include/linux/skbuff.h **** 	dataref = atomic_read(&skb_shinfo(skb)->dataref);
 405:include/linux/skbuff.h **** 	dataref = (dataref & SKB_DATAREF_MASK) - (dataref >> SKB_DATAREF_SHIFT);
 406:include/linux/skbuff.h **** 	return dataref != 1;
 407:include/linux/skbuff.h **** }
 408:include/linux/skbuff.h **** 
 409:include/linux/skbuff.h **** /**
GAS LISTING  			page 36


 410:include/linux/skbuff.h ****  *	skb_header_release - release reference to header
 411:include/linux/skbuff.h ****  *	@skb: buffer to operate on
 412:include/linux/skbuff.h ****  *
 413:include/linux/skbuff.h ****  *	Drop a reference to the header part of the buffer.  This is done
 414:include/linux/skbuff.h ****  *	by acquiring a payload reference.  You must not read from the header
 415:include/linux/skbuff.h ****  *	part of skb->data after this.
 416:include/linux/skbuff.h ****  */
 417:include/linux/skbuff.h **** static inline void skb_header_release(struct sk_buff *skb)
 418:include/linux/skbuff.h **** {
 419:include/linux/skbuff.h **** 	BUG_ON(skb->nohdr);
 420:include/linux/skbuff.h **** 	skb->nohdr = 1;
 421:include/linux/skbuff.h **** 	atomic_add(1 << SKB_DATAREF_SHIFT, &skb_shinfo(skb)->dataref);
 422:include/linux/skbuff.h **** }
 423:include/linux/skbuff.h **** 
 424:include/linux/skbuff.h **** /**
 425:include/linux/skbuff.h ****  *	skb_shared - is the buffer shared
 426:include/linux/skbuff.h ****  *	@skb: buffer to check
 427:include/linux/skbuff.h ****  *
 428:include/linux/skbuff.h ****  *	Returns true if more than one person has a reference to this
 429:include/linux/skbuff.h ****  *	buffer.
 430:include/linux/skbuff.h ****  */
 431:include/linux/skbuff.h **** static inline int skb_shared(const struct sk_buff *skb)
 432:include/linux/skbuff.h **** {
 433:include/linux/skbuff.h **** 	return atomic_read(&skb->users) != 1;
 434:include/linux/skbuff.h **** }
 435:include/linux/skbuff.h **** 
 436:include/linux/skbuff.h **** /**
 437:include/linux/skbuff.h ****  *	skb_share_check - check if buffer is shared and if so clone it
 438:include/linux/skbuff.h ****  *	@skb: buffer to check
 439:include/linux/skbuff.h ****  *	@pri: priority for memory allocation
 440:include/linux/skbuff.h ****  *
 441:include/linux/skbuff.h ****  *	If the buffer is shared the buffer is cloned and the old copy
 442:include/linux/skbuff.h ****  *	drops a reference. A new clone with a single reference is returned.
 443:include/linux/skbuff.h ****  *	If the buffer is not shared the original buffer is returned. When
 444:include/linux/skbuff.h ****  *	being called from interrupt status or with spinlocks held pri must
 445:include/linux/skbuff.h ****  *	be GFP_ATOMIC.
 446:include/linux/skbuff.h ****  *
 447:include/linux/skbuff.h ****  *	NULL is returned on a memory allocation failure.
 448:include/linux/skbuff.h ****  */
 449:include/linux/skbuff.h **** static inline struct sk_buff *skb_share_check(struct sk_buff *skb, int pri)
 450:include/linux/skbuff.h **** {
 451:include/linux/skbuff.h **** 	might_sleep_if(pri & __GFP_WAIT);
 452:include/linux/skbuff.h **** 	if (skb_shared(skb)) {
 453:include/linux/skbuff.h **** 		struct sk_buff *nskb = skb_clone(skb, pri);
 454:include/linux/skbuff.h **** 		kfree_skb(skb);
 455:include/linux/skbuff.h **** 		skb = nskb;
 456:include/linux/skbuff.h **** 	}
 457:include/linux/skbuff.h **** 	return skb;
 458:include/linux/skbuff.h **** }
 459:include/linux/skbuff.h **** 
 460:include/linux/skbuff.h **** /*
 461:include/linux/skbuff.h ****  *	Copy shared buffers into a new sk_buff. We effectively do COW on
 462:include/linux/skbuff.h ****  *	packets to handle cases where we have a local reader and forward
 463:include/linux/skbuff.h ****  *	and a couple of other messy ones. The normal one is tcpdumping
 464:include/linux/skbuff.h ****  *	a packet thats being forwarded.
 465:include/linux/skbuff.h ****  */
 466:include/linux/skbuff.h **** 
GAS LISTING  			page 37


 467:include/linux/skbuff.h **** /**
 468:include/linux/skbuff.h ****  *	skb_unshare - make a copy of a shared buffer
 469:include/linux/skbuff.h ****  *	@skb: buffer to check
 470:include/linux/skbuff.h ****  *	@pri: priority for memory allocation
 471:include/linux/skbuff.h ****  *
 472:include/linux/skbuff.h ****  *	If the socket buffer is a clone then this function creates a new
 473:include/linux/skbuff.h ****  *	copy of the data, drops a reference count on the old copy and returns
 474:include/linux/skbuff.h ****  *	the new copy with the reference count at 1. If the buffer is not a clone
 475:include/linux/skbuff.h ****  *	the original buffer is returned. When called with a spinlock held or
 476:include/linux/skbuff.h ****  *	from interrupt state @pri must be %GFP_ATOMIC
 477:include/linux/skbuff.h ****  *
 478:include/linux/skbuff.h ****  *	%NULL is returned on a memory allocation failure.
 479:include/linux/skbuff.h ****  */
 480:include/linux/skbuff.h **** static inline struct sk_buff *skb_unshare(struct sk_buff *skb, int pri)
 481:include/linux/skbuff.h **** {
 482:include/linux/skbuff.h **** 	might_sleep_if(pri & __GFP_WAIT);
 483:include/linux/skbuff.h **** 	if (skb_cloned(skb)) {
 484:include/linux/skbuff.h **** 		struct sk_buff *nskb = skb_copy(skb, pri);
 485:include/linux/skbuff.h **** 		kfree_skb(skb);	/* Free our shared copy */
 486:include/linux/skbuff.h **** 		skb = nskb;
 487:include/linux/skbuff.h **** 	}
 488:include/linux/skbuff.h **** 	return skb;
 489:include/linux/skbuff.h **** }
 490:include/linux/skbuff.h **** 
 491:include/linux/skbuff.h **** /**
 492:include/linux/skbuff.h ****  *	skb_peek
 493:include/linux/skbuff.h ****  *	@list_: list to peek at
 494:include/linux/skbuff.h ****  *
 495:include/linux/skbuff.h ****  *	Peek an &sk_buff. Unlike most other operations you _MUST_
 496:include/linux/skbuff.h ****  *	be careful with this one. A peek leaves the buffer on the
 497:include/linux/skbuff.h ****  *	list and someone else may run off with it. You must hold
 498:include/linux/skbuff.h ****  *	the appropriate locks or have a private queue to do this.
 499:include/linux/skbuff.h ****  *
 500:include/linux/skbuff.h ****  *	Returns %NULL for an empty list or a pointer to the head element.
 501:include/linux/skbuff.h ****  *	The reference count is not incremented and the reference is therefore
 502:include/linux/skbuff.h ****  *	volatile. Use with caution.
 503:include/linux/skbuff.h ****  */
 504:include/linux/skbuff.h **** static inline struct sk_buff *skb_peek(struct sk_buff_head *list_)
 505:include/linux/skbuff.h **** {
 506:include/linux/skbuff.h **** 	struct sk_buff *list = ((struct sk_buff *)list_)->next;
 507:include/linux/skbuff.h **** 	if (list == (struct sk_buff *)list_)
 508:include/linux/skbuff.h **** 		list = NULL;
 509:include/linux/skbuff.h **** 	return list;
 510:include/linux/skbuff.h **** }
 511:include/linux/skbuff.h **** 
 512:include/linux/skbuff.h **** /**
 513:include/linux/skbuff.h ****  *	skb_peek_tail
 514:include/linux/skbuff.h ****  *	@list_: list to peek at
 515:include/linux/skbuff.h ****  *
 516:include/linux/skbuff.h ****  *	Peek an &sk_buff. Unlike most other operations you _MUST_
 517:include/linux/skbuff.h ****  *	be careful with this one. A peek leaves the buffer on the
 518:include/linux/skbuff.h ****  *	list and someone else may run off with it. You must hold
 519:include/linux/skbuff.h ****  *	the appropriate locks or have a private queue to do this.
 520:include/linux/skbuff.h ****  *
 521:include/linux/skbuff.h ****  *	Returns %NULL for an empty list or a pointer to the tail element.
 522:include/linux/skbuff.h ****  *	The reference count is not incremented and the reference is therefore
 523:include/linux/skbuff.h ****  *	volatile. Use with caution.
GAS LISTING  			page 38


 524:include/linux/skbuff.h ****  */
 525:include/linux/skbuff.h **** static inline struct sk_buff *skb_peek_tail(struct sk_buff_head *list_)
 526:include/linux/skbuff.h **** {
 527:include/linux/skbuff.h **** 	struct sk_buff *list = ((struct sk_buff *)list_)->prev;
 528:include/linux/skbuff.h **** 	if (list == (struct sk_buff *)list_)
 529:include/linux/skbuff.h **** 		list = NULL;
 530:include/linux/skbuff.h **** 	return list;
 531:include/linux/skbuff.h **** }
 532:include/linux/skbuff.h **** 
 533:include/linux/skbuff.h **** /**
 534:include/linux/skbuff.h ****  *	skb_queue_len	- get queue length
 535:include/linux/skbuff.h ****  *	@list_: list to measure
 536:include/linux/skbuff.h ****  *
 537:include/linux/skbuff.h ****  *	Return the length of an &sk_buff queue.
 538:include/linux/skbuff.h ****  */
 539:include/linux/skbuff.h **** static inline __u32 skb_queue_len(const struct sk_buff_head *list_)
 540:include/linux/skbuff.h **** {
 541:include/linux/skbuff.h **** 	return list_->qlen;
 542:include/linux/skbuff.h **** }
 543:include/linux/skbuff.h **** 
 544:include/linux/skbuff.h **** static inline void skb_queue_head_init(struct sk_buff_head *list)
 545:include/linux/skbuff.h **** {
 546:include/linux/skbuff.h **** 	spin_lock_init(&list->lock);
 547:include/linux/skbuff.h **** 	list->prev = list->next = (struct sk_buff *)list;
 548:include/linux/skbuff.h **** 	list->qlen = 0;
 549:include/linux/skbuff.h **** }
 550:include/linux/skbuff.h **** 
 551:include/linux/skbuff.h **** /*
 552:include/linux/skbuff.h ****  *	Insert an sk_buff at the start of a list.
 553:include/linux/skbuff.h ****  *
 554:include/linux/skbuff.h ****  *	The "__skb_xxxx()" functions are the non-atomic ones that
 555:include/linux/skbuff.h ****  *	can only be called with interrupts disabled.
 556:include/linux/skbuff.h ****  */
 557:include/linux/skbuff.h **** 
 558:include/linux/skbuff.h **** /**
 559:include/linux/skbuff.h ****  *	__skb_queue_head - queue a buffer at the list head
 560:include/linux/skbuff.h ****  *	@list: list to use
 561:include/linux/skbuff.h ****  *	@newsk: buffer to queue
 562:include/linux/skbuff.h ****  *
 563:include/linux/skbuff.h ****  *	Queue a buffer at the start of a list. This function takes no locks
 564:include/linux/skbuff.h ****  *	and you must therefore hold required locks before calling it.
 565:include/linux/skbuff.h ****  *
 566:include/linux/skbuff.h ****  *	A buffer cannot be placed on two lists at the same time.
 567:include/linux/skbuff.h ****  */
 568:include/linux/skbuff.h **** extern void skb_queue_head(struct sk_buff_head *list, struct sk_buff *newsk);
 569:include/linux/skbuff.h **** static inline void __skb_queue_head(struct sk_buff_head *list,
 570:include/linux/skbuff.h **** 				    struct sk_buff *newsk)
 571:include/linux/skbuff.h **** {
 572:include/linux/skbuff.h **** 	struct sk_buff *prev, *next;
 573:include/linux/skbuff.h **** 
 574:include/linux/skbuff.h **** 	newsk->list = list;
 575:include/linux/skbuff.h **** 	list->qlen++;
 576:include/linux/skbuff.h **** 	prev = (struct sk_buff *)list;
 577:include/linux/skbuff.h **** 	next = prev->next;
 578:include/linux/skbuff.h **** 	newsk->next = next;
 579:include/linux/skbuff.h **** 	newsk->prev = prev;
 580:include/linux/skbuff.h **** 	next->prev  = prev->next = newsk;
GAS LISTING  			page 39


 581:include/linux/skbuff.h **** }
 582:include/linux/skbuff.h **** 
 583:include/linux/skbuff.h **** /**
 584:include/linux/skbuff.h ****  *	__skb_queue_tail - queue a buffer at the list tail
 585:include/linux/skbuff.h ****  *	@list: list to use
 586:include/linux/skbuff.h ****  *	@newsk: buffer to queue
 587:include/linux/skbuff.h ****  *
 588:include/linux/skbuff.h ****  *	Queue a buffer at the end of a list. This function takes no locks
 589:include/linux/skbuff.h ****  *	and you must therefore hold required locks before calling it.
 590:include/linux/skbuff.h ****  *
 591:include/linux/skbuff.h ****  *	A buffer cannot be placed on two lists at the same time.
 592:include/linux/skbuff.h ****  */
 593:include/linux/skbuff.h **** extern void skb_queue_tail(struct sk_buff_head *list, struct sk_buff *newsk);
 594:include/linux/skbuff.h **** static inline void __skb_queue_tail(struct sk_buff_head *list,
 595:include/linux/skbuff.h **** 				   struct sk_buff *newsk)
 596:include/linux/skbuff.h **** {
 597:include/linux/skbuff.h **** 	struct sk_buff *prev, *next;
 598:include/linux/skbuff.h **** 
 599:include/linux/skbuff.h **** 	newsk->list = list;
 600:include/linux/skbuff.h **** 	list->qlen++;
 601:include/linux/skbuff.h **** 	next = (struct sk_buff *)list;
 602:include/linux/skbuff.h **** 	prev = next->prev;
 603:include/linux/skbuff.h **** 	newsk->next = next;
 604:include/linux/skbuff.h **** 	newsk->prev = prev;
 605:include/linux/skbuff.h **** 	next->prev  = prev->next = newsk;
 606:include/linux/skbuff.h **** }
 607:include/linux/skbuff.h **** 
 608:include/linux/skbuff.h **** 
 609:include/linux/skbuff.h **** /**
 610:include/linux/skbuff.h ****  *	__skb_dequeue - remove from the head of the queue
 611:include/linux/skbuff.h ****  *	@list: list to dequeue from
 612:include/linux/skbuff.h ****  *
 613:include/linux/skbuff.h ****  *	Remove the head of the list. This function does not take any locks
 614:include/linux/skbuff.h ****  *	so must be used with appropriate locks held only. The head item is
 615:include/linux/skbuff.h ****  *	returned or %NULL if the list is empty.
 616:include/linux/skbuff.h ****  */
 617:include/linux/skbuff.h **** extern struct sk_buff *skb_dequeue(struct sk_buff_head *list);
 618:include/linux/skbuff.h **** static inline struct sk_buff *__skb_dequeue(struct sk_buff_head *list)
 619:include/linux/skbuff.h **** {
 620:include/linux/skbuff.h **** 	struct sk_buff *next, *prev, *result;
 621:include/linux/skbuff.h **** 
 622:include/linux/skbuff.h **** 	prev = (struct sk_buff *) list;
 623:include/linux/skbuff.h **** 	next = prev->next;
 624:include/linux/skbuff.h **** 	result = NULL;
 625:include/linux/skbuff.h **** 	if (next != prev) {
 626:include/linux/skbuff.h **** 		result	     = next;
 627:include/linux/skbuff.h **** 		next	     = next->next;
 628:include/linux/skbuff.h **** 		list->qlen--;
 629:include/linux/skbuff.h **** 		next->prev   = prev;
 630:include/linux/skbuff.h **** 		prev->next   = next;
 631:include/linux/skbuff.h **** 		result->next = result->prev = NULL;
 632:include/linux/skbuff.h **** 		result->list = NULL;
 633:include/linux/skbuff.h **** 	}
 634:include/linux/skbuff.h **** 	return result;
 635:include/linux/skbuff.h **** }
 636:include/linux/skbuff.h **** 
 637:include/linux/skbuff.h **** 
GAS LISTING  			page 40


 638:include/linux/skbuff.h **** /*
 639:include/linux/skbuff.h ****  *	Insert a packet on a list.
 640:include/linux/skbuff.h ****  */
 641:include/linux/skbuff.h **** extern void        skb_insert(struct sk_buff *old, struct sk_buff *newsk);
 642:include/linux/skbuff.h **** static inline void __skb_insert(struct sk_buff *newsk,
 643:include/linux/skbuff.h **** 				struct sk_buff *prev, struct sk_buff *next,
 644:include/linux/skbuff.h **** 				struct sk_buff_head *list)
 645:include/linux/skbuff.h **** {
 646:include/linux/skbuff.h **** 	newsk->next = next;
 647:include/linux/skbuff.h **** 	newsk->prev = prev;
 648:include/linux/skbuff.h **** 	next->prev  = prev->next = newsk;
 649:include/linux/skbuff.h **** 	newsk->list = list;
 650:include/linux/skbuff.h **** 	list->qlen++;
 651:include/linux/skbuff.h **** }
 652:include/linux/skbuff.h **** 
 653:include/linux/skbuff.h **** /*
 654:include/linux/skbuff.h ****  *	Place a packet after a given packet in a list.
 655:include/linux/skbuff.h ****  */
 656:include/linux/skbuff.h **** extern void	   skb_append(struct sk_buff *old, struct sk_buff *newsk);
 657:include/linux/skbuff.h **** static inline void __skb_append(struct sk_buff *old, struct sk_buff *newsk)
 658:include/linux/skbuff.h **** {
 659:include/linux/skbuff.h **** 	__skb_insert(newsk, old, old->next, old->list);
 660:include/linux/skbuff.h **** }
 661:include/linux/skbuff.h **** 
 662:include/linux/skbuff.h **** /*
 663:include/linux/skbuff.h ****  * remove sk_buff from list. _Must_ be called atomically, and with
 664:include/linux/skbuff.h ****  * the list known..
 665:include/linux/skbuff.h ****  */
 666:include/linux/skbuff.h **** extern void	   skb_unlink(struct sk_buff *skb);
 667:include/linux/skbuff.h **** static inline void __skb_unlink(struct sk_buff *skb, struct sk_buff_head *list)
 668:include/linux/skbuff.h **** {
 669:include/linux/skbuff.h **** 	struct sk_buff *next, *prev;
 670:include/linux/skbuff.h **** 
 671:include/linux/skbuff.h **** 	list->qlen--;
 672:include/linux/skbuff.h **** 	next	   = skb->next;
 673:include/linux/skbuff.h **** 	prev	   = skb->prev;
 674:include/linux/skbuff.h **** 	skb->next  = skb->prev = NULL;
 675:include/linux/skbuff.h **** 	skb->list  = NULL;
 676:include/linux/skbuff.h **** 	next->prev = prev;
 677:include/linux/skbuff.h **** 	prev->next = next;
 678:include/linux/skbuff.h **** }
 679:include/linux/skbuff.h **** 
 680:include/linux/skbuff.h **** 
 681:include/linux/skbuff.h **** /* XXX: more streamlined implementation */
 682:include/linux/skbuff.h **** 
 683:include/linux/skbuff.h **** /**
 684:include/linux/skbuff.h ****  *	__skb_dequeue_tail - remove from the tail of the queue
 685:include/linux/skbuff.h ****  *	@list: list to dequeue from
 686:include/linux/skbuff.h ****  *
 687:include/linux/skbuff.h ****  *	Remove the tail of the list. This function does not take any locks
 688:include/linux/skbuff.h ****  *	so must be used with appropriate locks held only. The tail item is
 689:include/linux/skbuff.h ****  *	returned or %NULL if the list is empty.
 690:include/linux/skbuff.h ****  */
 691:include/linux/skbuff.h **** extern struct sk_buff *skb_dequeue_tail(struct sk_buff_head *list);
 692:include/linux/skbuff.h **** static inline struct sk_buff *__skb_dequeue_tail(struct sk_buff_head *list)
 693:include/linux/skbuff.h **** {
 694:include/linux/skbuff.h **** 	struct sk_buff *skb = skb_peek_tail(list);
GAS LISTING  			page 41


 695:include/linux/skbuff.h **** 	if (skb)
 696:include/linux/skbuff.h **** 		__skb_unlink(skb, list);
 697:include/linux/skbuff.h **** 	return skb;
 698:include/linux/skbuff.h **** }
 699:include/linux/skbuff.h **** 
 700:include/linux/skbuff.h **** 
 701:include/linux/skbuff.h **** static inline int skb_is_nonlinear(const struct sk_buff *skb)
 702:include/linux/skbuff.h **** {
 703:include/linux/skbuff.h **** 	return skb->data_len;
 704:include/linux/skbuff.h **** }
 705:include/linux/skbuff.h **** 
 706:include/linux/skbuff.h **** static inline unsigned int skb_headlen(const struct sk_buff *skb)
 707:include/linux/skbuff.h **** {
 708:include/linux/skbuff.h **** 	return skb->len - skb->data_len;
 709:include/linux/skbuff.h **** }
 710:include/linux/skbuff.h **** 
 711:include/linux/skbuff.h **** static inline int skb_pagelen(const struct sk_buff *skb)
 712:include/linux/skbuff.h **** {
 713:include/linux/skbuff.h **** 	int i, len = 0;
 714:include/linux/skbuff.h **** 
 715:include/linux/skbuff.h **** 	for (i = (int)skb_shinfo(skb)->nr_frags - 1; i >= 0; i--)
 716:include/linux/skbuff.h **** 		len += skb_shinfo(skb)->frags[i].size;
 717:include/linux/skbuff.h **** 	return len + skb_headlen(skb);
 718:include/linux/skbuff.h **** }
 719:include/linux/skbuff.h **** 
 720:include/linux/skbuff.h **** static inline void skb_fill_page_desc(struct sk_buff *skb, int i,
 721:include/linux/skbuff.h **** 				      struct page *page, int off, int size)
 722:include/linux/skbuff.h **** {
 723:include/linux/skbuff.h **** 	skb_frag_t *frag = &skb_shinfo(skb)->frags[i];
 724:include/linux/skbuff.h **** 
 725:include/linux/skbuff.h **** 	frag->page		  = page;
 726:include/linux/skbuff.h **** 	frag->page_offset	  = off;
 727:include/linux/skbuff.h **** 	frag->size		  = size;
 728:include/linux/skbuff.h **** 	skb_shinfo(skb)->nr_frags = i + 1;
 729:include/linux/skbuff.h **** }
 730:include/linux/skbuff.h **** 
 731:include/linux/skbuff.h **** #define SKB_PAGE_ASSERT(skb) 	BUG_ON(skb_shinfo(skb)->nr_frags)
 732:include/linux/skbuff.h **** #define SKB_FRAG_ASSERT(skb) 	BUG_ON(skb_shinfo(skb)->frag_list)
 733:include/linux/skbuff.h **** #define SKB_LINEAR_ASSERT(skb)  BUG_ON(skb_is_nonlinear(skb))
 734:include/linux/skbuff.h **** 
 735:include/linux/skbuff.h **** /*
 736:include/linux/skbuff.h ****  *	Add data to an sk_buff
 737:include/linux/skbuff.h ****  */
 738:include/linux/skbuff.h **** static inline unsigned char *__skb_put(struct sk_buff *skb, unsigned int len)
 739:include/linux/skbuff.h **** {
 740:include/linux/skbuff.h **** 	unsigned char *tmp = skb->tail;
 741:include/linux/skbuff.h **** 	SKB_LINEAR_ASSERT(skb);
 742:include/linux/skbuff.h **** 	skb->tail += len;
 743:include/linux/skbuff.h **** 	skb->len  += len;
 744:include/linux/skbuff.h **** 	return tmp;
 745:include/linux/skbuff.h **** }
 746:include/linux/skbuff.h **** 
 747:include/linux/skbuff.h **** /**
 748:include/linux/skbuff.h ****  *	skb_put - add data to a buffer
 749:include/linux/skbuff.h ****  *	@skb: buffer to use
 750:include/linux/skbuff.h ****  *	@len: amount of data to add
 751:include/linux/skbuff.h ****  *
GAS LISTING  			page 42


 752:include/linux/skbuff.h ****  *	This function extends the used data area of the buffer. If this would
 753:include/linux/skbuff.h ****  *	exceed the total buffer size the kernel will panic. A pointer to the
 754:include/linux/skbuff.h ****  *	first byte of the extra data is returned.
 755:include/linux/skbuff.h ****  */
 756:include/linux/skbuff.h **** static inline unsigned char *skb_put(struct sk_buff *skb, unsigned int len)
 757:include/linux/skbuff.h **** {
 758:include/linux/skbuff.h **** 	unsigned char *tmp = skb->tail;
 759:include/linux/skbuff.h **** 	SKB_LINEAR_ASSERT(skb);
 760:include/linux/skbuff.h **** 	skb->tail += len;
 761:include/linux/skbuff.h **** 	skb->len  += len;
 762:include/linux/skbuff.h **** 	if (unlikely(skb->tail>skb->end))
 763:include/linux/skbuff.h **** 		skb_over_panic(skb, len, current_text_addr());
 764:include/linux/skbuff.h **** 	return tmp;
 765:include/linux/skbuff.h **** }
 766:include/linux/skbuff.h **** 
 767:include/linux/skbuff.h **** static inline unsigned char *__skb_push(struct sk_buff *skb, unsigned int len)
 768:include/linux/skbuff.h **** {
 769:include/linux/skbuff.h **** 	skb->data -= len;
 770:include/linux/skbuff.h **** 	skb->len  += len;
 771:include/linux/skbuff.h **** 	return skb->data;
 772:include/linux/skbuff.h **** }
 773:include/linux/skbuff.h **** 
 774:include/linux/skbuff.h **** /**
 775:include/linux/skbuff.h ****  *	skb_push - add data to the start of a buffer
 776:include/linux/skbuff.h ****  *	@skb: buffer to use
 777:include/linux/skbuff.h ****  *	@len: amount of data to add
 778:include/linux/skbuff.h ****  *
 779:include/linux/skbuff.h ****  *	This function extends the used data area of the buffer at the buffer
 780:include/linux/skbuff.h ****  *	start. If this would exceed the total buffer headroom the kernel will
 781:include/linux/skbuff.h ****  *	panic. A pointer to the first byte of the extra data is returned.
 782:include/linux/skbuff.h ****  */
 783:include/linux/skbuff.h **** static inline unsigned char *skb_push(struct sk_buff *skb, unsigned int len)
 784:include/linux/skbuff.h **** {
 785:include/linux/skbuff.h **** 	skb->data -= len;
 786:include/linux/skbuff.h **** 	skb->len  += len;
 787:include/linux/skbuff.h **** 	if (unlikely(skb->data<skb->head))
 788:include/linux/skbuff.h **** 		skb_under_panic(skb, len, current_text_addr());
 789:include/linux/skbuff.h **** 	return skb->data;
 790:include/linux/skbuff.h **** }
 791:include/linux/skbuff.h **** 
 792:include/linux/skbuff.h **** static inline unsigned char *__skb_pull(struct sk_buff *skb, unsigned int len)
 793:include/linux/skbuff.h **** {
 794:include/linux/skbuff.h **** 	skb->len -= len;
 795:include/linux/skbuff.h **** 	BUG_ON(skb->len < skb->data_len);
 796:include/linux/skbuff.h **** 	return skb->data += len;
 797:include/linux/skbuff.h **** }
 798:include/linux/skbuff.h **** 
 799:include/linux/skbuff.h **** /**
 800:include/linux/skbuff.h ****  *	skb_pull - remove data from the start of a buffer
 801:include/linux/skbuff.h ****  *	@skb: buffer to use
 802:include/linux/skbuff.h ****  *	@len: amount of data to remove
 803:include/linux/skbuff.h ****  *
 804:include/linux/skbuff.h ****  *	This function removes data from the start of a buffer, returning
 805:include/linux/skbuff.h ****  *	the memory to the headroom. A pointer to the next data in the buffer
 806:include/linux/skbuff.h ****  *	is returned. Once the data has been pulled future pushes will overwrite
 807:include/linux/skbuff.h ****  *	the old data.
 808:include/linux/skbuff.h ****  */
GAS LISTING  			page 43


 809:include/linux/skbuff.h **** static inline unsigned char *skb_pull(struct sk_buff *skb, unsigned int len)
 810:include/linux/skbuff.h **** {
 811:include/linux/skbuff.h **** 	return unlikely(len > skb->len) ? NULL : __skb_pull(skb, len);
 812:include/linux/skbuff.h **** }
 813:include/linux/skbuff.h **** 
 814:include/linux/skbuff.h **** extern unsigned char *__pskb_pull_tail(struct sk_buff *skb, int delta);
 815:include/linux/skbuff.h **** 
 816:include/linux/skbuff.h **** static inline unsigned char *__pskb_pull(struct sk_buff *skb, unsigned int len)
 817:include/linux/skbuff.h **** {
 818:include/linux/skbuff.h **** 	if (len > skb_headlen(skb) &&
 819:include/linux/skbuff.h **** 	    !__pskb_pull_tail(skb, len-skb_headlen(skb)))
 820:include/linux/skbuff.h **** 		return NULL;
 821:include/linux/skbuff.h **** 	skb->len -= len;
 822:include/linux/skbuff.h **** 	return skb->data += len;
 823:include/linux/skbuff.h **** }
 824:include/linux/skbuff.h **** 
 825:include/linux/skbuff.h **** static inline unsigned char *pskb_pull(struct sk_buff *skb, unsigned int len)
 826:include/linux/skbuff.h **** {
 827:include/linux/skbuff.h **** 	return unlikely(len > skb->len) ? NULL : __pskb_pull(skb, len);
 828:include/linux/skbuff.h **** }
 829:include/linux/skbuff.h **** 
 830:include/linux/skbuff.h **** static inline int pskb_may_pull(struct sk_buff *skb, unsigned int len)
 831:include/linux/skbuff.h **** {
 832:include/linux/skbuff.h **** 	if (likely(len <= skb_headlen(skb)))
 833:include/linux/skbuff.h **** 		return 1;
 834:include/linux/skbuff.h **** 	if (unlikely(len > skb->len))
 835:include/linux/skbuff.h **** 		return 0;
 836:include/linux/skbuff.h **** 	return __pskb_pull_tail(skb, len-skb_headlen(skb)) != NULL;
 837:include/linux/skbuff.h **** }
 838:include/linux/skbuff.h **** 
 839:include/linux/skbuff.h **** /**
 840:include/linux/skbuff.h ****  *	skb_headroom - bytes at buffer head
 841:include/linux/skbuff.h ****  *	@skb: buffer to check
 842:include/linux/skbuff.h ****  *
 843:include/linux/skbuff.h ****  *	Return the number of bytes of free space at the head of an &sk_buff.
 844:include/linux/skbuff.h ****  */
 845:include/linux/skbuff.h **** static inline int skb_headroom(const struct sk_buff *skb)
 846:include/linux/skbuff.h **** {
 847:include/linux/skbuff.h **** 	return skb->data - skb->head;
 508              	.loc 5 847 0
 509 024f 8B85A800 	movl 168(%ebp),%eax
 509      0000
 510 0255 2B85A400 	subl 164(%ebp),%eax
 510      0000
 511              	.LBE32:
 512              	.LBE31:
 513              	.loc 5 846 0
 514 025b 83F807   	cmpl $7,%eax
 515              	.loc 1 195 0
 516 025e 8B7C241C 	movl 28(%esp),%edi
 517 0262 8B5C2424 	movl 36(%esp),%ebx
 518              	.loc 5 846 0
 519 0266 7E09     	jle .L185
 520 0268 8B442418 	movl 24(%esp),%eax
 521 026c 394560   	cmpl %eax,96(%ebp)
 522 026f 7308     	jae .L184
 523              	.L185:
GAS LISTING  			page 44


 196:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	struct ieee80211_ccmp_data *key = priv;
 197:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	int i;
 198:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	u8 *pos;
 199:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 
 200:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	if (skb_headroom(skb) < CCMP_HDR_LEN || skb->len < hdr_len)
 201:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 		return -1;
 524              	.loc 1 201 0
 525 0271 83C8FF   	orl $-1,%eax
 526 0274 E9A50000 	jmp .L183
 526      00
 527              	.L184:
 202:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 
 203:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	if (aeskey != NULL && keylen >= CCMP_TK_LEN)
 528              	.loc 1 203 0
 529 0279 85FF     	testl %edi,%edi
 530 027b 740D     	je .L187
 531 027d 837C2420 	cmpl $15,32(%esp)
 531      0F
 532 0282 7E06     	jle .L187
 533              	.LBB33:
 534              	.LBB34:
 535              	.loc 4 260 0
 536 0284 89DE     	movl %ebx,%esi
 537              	
 538 0286 A5       	movsl
 539              	.loc 4 262 0
 540 0287 A5       	movsl
 541              	.loc 4 264 0
 542 0288 A5       	movsl
 543              	.loc 4 266 0
 544 0289 A5       	movsl
 545              	
 546              	.L187:
 547              	.LBE34:
 548              	.LBE33:
 549              	.LBB35:
 550              	.LBB36:
 551              	.loc 5 785 0
 552 028a 8B85A800 	movl 168(%ebp),%eax
 552      0000
 553 0290 83E808   	subl $8,%eax
 554              	.loc 5 786 0
 555 0293 83456008 	addl $8,96(%ebp)
 556              	.loc 5 787 0
 557 0297 3B85A400 	cmpl 164(%ebp),%eax
 557      0000
 558              	.loc 5 785 0
 559 029d 8985A800 	movl %eax,168(%ebp)
 559      0000
 560              	.loc 5 787 0
 561 02a3 7311     	jae .L210
 562              	.LBB37:
 563              	.loc 5 788 0
 564              	
 565 02a5 B8AA0200 	movl $1f,%eax
 565      00
 566              	1:
GAS LISTING  			page 45


 567              	
 568              	.LBE37:
 569 02aa 50       	pushl %eax
 570              	.LCFI61:
 571 02ab 6A08     	pushl $8
 572              	.LCFI62:
 573 02ad 55       	pushl %ebp
 574              	.LCFI63:
 575 02ae E8FCFFFF 	call skb_under_panic
 575      FF
 576 02b3 83C40C   	addl $12,%esp
 577              	.LCFI64:
 578              	.L210:
 579 02b6 8BB5A800 	movl 168(%ebp),%esi
 579      0000
 580              	.LBE36:
 581              	.LBE35:
 204:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 		memcpy(aeskey, key->key, CCMP_TK_LEN);
 205:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 
 206:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	pos = skb_push(skb, CCMP_HDR_LEN);
 207:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	memmove(pos, pos + CCMP_HDR_LEN, hdr_len);
 582              	.loc 1 207 0
 583 02bc 8D4608   	leal 8(%esi),%eax
 584 02bf FF742418 	pushl 24(%esp)
 585              	.LCFI65:
 586 02c3 50       	pushl %eax
 587              	.LCFI66:
 588 02c4 56       	pushl %esi
 589              	.LCFI67:
 590 02c5 E8FCFFFF 	call memmove
 590      FF
 208:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	pos += hdr_len;
 591              	.loc 1 208 0
 592 02ca 03742424 	addl 36(%esp),%esi
 209:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 
 210:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	i = CCMP_PN_LEN - 1;
 593              	.loc 1 210 0
 594 02ce BA050000 	movl $5,%edx
 594      00
 211:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	while (i >= 0) {
 595              	.loc 1 211 0
 596 02d3 83C40C   	addl $12,%esp
 597              	.LCFI68:
 598              	.L215:
 212:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 		key->tx_pn[i]++;
 599              	.loc 1 212 0
 600 02d6 8A441A14 	movb 20(%edx,%ebx),%al
 601 02da 40       	incl %eax
 213:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 		if (key->tx_pn[i] != 0)
 602              	.loc 1 213 0
 603 02db 84C0     	testb %al,%al
 604              	.loc 1 212 0
 605 02dd 88441A14 	movb %al,20(%edx,%ebx)
 606              	.loc 1 213 0
 607 02e1 7503     	jne .L213
 214:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 			break;
 215:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 		i--;
GAS LISTING  			page 46


 608              	.loc 1 215 0
 609 02e3 4A       	decl %edx
 610 02e4 79F0     	jns .L215
 611              	.L213:
 216:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	}
 217:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 
 218:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	*pos++ = key->tx_pn[5];
 612              	.loc 1 218 0
 613 02e6 8A4319   	movb 25(%ebx),%al
 614 02e9 8806     	movb %al,(%esi)
 219:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	*pos++ = key->tx_pn[4];
 615              	.loc 1 219 0
 616 02eb 8A4318   	movb 24(%ebx),%al
 617              	.loc 1 218 0
 618 02ee 46       	incl %esi
 619              	.loc 1 219 0
 620 02ef 8806     	movb %al,(%esi)
 621 02f1 46       	incl %esi
 220:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	*pos++ = 0;
 622              	.loc 1 220 0
 623 02f2 C60600   	movb $0,(%esi)
 221:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	*pos++ = (key->key_idx << 6) | (1 << 5) /* Ext IV included */ ;
 624              	.loc 1 221 0
 625 02f5 8B432C   	movl 44(%ebx),%eax
 626 02f8 C1E006   	sall $6,%eax
 627              	.loc 1 220 0
 628 02fb 46       	incl %esi
 629              	.loc 1 221 0
 630 02fc 83C820   	orl $32,%eax
 631 02ff 8806     	movb %al,(%esi)
 222:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	*pos++ = key->tx_pn[3];
 632              	.loc 1 222 0
 633 0301 8A4317   	movb 23(%ebx),%al
 634              	.loc 1 221 0
 635 0304 46       	incl %esi
 636              	.loc 1 222 0
 637 0305 8806     	movb %al,(%esi)
 223:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	*pos++ = key->tx_pn[2];
 638              	.loc 1 223 0
 639 0307 8A4316   	movb 22(%ebx),%al
 640              	.loc 1 222 0
 641 030a 46       	incl %esi
 642              	.loc 1 223 0
 643 030b 8806     	movb %al,(%esi)
 224:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	*pos++ = key->tx_pn[1];
 644              	.loc 1 224 0
 645 030d 8A4315   	movb 21(%ebx),%al
 646              	.loc 1 223 0
 647 0310 46       	incl %esi
 648              	.loc 1 224 0
 649 0311 8806     	movb %al,(%esi)
 225:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	*pos++ = key->tx_pn[0];
 650              	.loc 1 225 0
 651 0313 8A4314   	movb 20(%ebx),%al
 652 0316 884601   	movb %al,1(%esi)
 226:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 
 227:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	return CCMP_HDR_LEN;
GAS LISTING  			page 47


 653              	.loc 1 227 0
 654 0319 B8080000 	movl $8,%eax
 654      00
 655              	.L183:
 228:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** }
 656              	.loc 1 228 0
 657 031e 5B       	popl %ebx
 658 031f 5E       	popl %esi
 659 0320 5F       	popl %edi
 660 0321 5D       	popl %ebp
 661 0322 C3       	ret
 662              	.LFE692:
 665              	ieee80211_ccmp_encrypt:
 666              	.LFB693:
 229:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 
 230:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** static int ieee80211_ccmp_encrypt(struct sk_buff *skb, int hdr_len, void *priv)
 231:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** {
 667              	.loc 1 231 0
 668 0323 55       	pushl %ebp
 669              	.LCFI69:
 670 0324 57       	pushl %edi
 671              	.LCFI70:
 672 0325 56       	pushl %esi
 673              	.LCFI71:
 674 0326 53       	pushl %ebx
 675              	.LCFI72:
 676 0327 83EC1C   	subl $28,%esp
 677              	.LCFI73:
 232:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	struct ieee80211_ccmp_data *key = priv;
 233:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	int data_len, i, blocks, last, len;
 234:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	u8 *pos, *mic;
 235:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	struct ieee80211_hdr_4addr *hdr;
 236:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	u8 *b0 = key->tx_b0;
 678              	.loc 1 236 0
 679 032a 8B442438 	movl 56(%esp),%eax
 680 032e 83C034   	addl $52,%eax
 681 0331 89442414 	movl %eax,20(%esp)
 237:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	u8 *b = key->tx_b;
 682              	.loc 1 237 0
 683 0335 8B542438 	movl 56(%esp),%edx
 238:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	u8 *e = key->tx_e;
 684              	.loc 1 238 0
 685 0339 8B4C2438 	movl 56(%esp),%ecx
 239:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	u8 *s0 = key->tx_s0;
 686              	.loc 1 239 0
 687 033d 8B442438 	movl 56(%esp),%eax
 688              	.loc 1 237 0
 689 0341 83C244   	addl $68,%edx
 690              	.loc 1 238 0
 691 0344 83C154   	addl $84,%ecx
 692              	.loc 1 239 0
 693 0347 83C064   	addl $100,%eax
 694              	.loc 1 231 0
 695 034a 8B7C2430 	movl 48(%esp),%edi
 696              	.loc 1 237 0
 697 034e 89542410 	movl %edx,16(%esp)
 698              	.loc 1 238 0
GAS LISTING  			page 48


 699 0352 894C240C 	movl %ecx,12(%esp)
 700              	.loc 1 239 0
 701 0356 89442408 	movl %eax,8(%esp)
 702              	.LBB38:
 703              	.LBB39:
 704              	.loc 5 702 0
 705 035a 837F6400 	cmpl $0,100(%edi)
 706              	.LBE39:
 707              	.LBE38:
 708              	.loc 1 231 0
 709 035e 8B742434 	movl 52(%esp),%esi
 710              	.LBB40:
 711              	.LBB41:
 712              	.loc 5 702 0
 713 0362 7518     	jne .L219
 714 0364 8B87B000 	movl 176(%edi),%eax
 714      0000
 715 036a 2B87AC00 	subl 172(%edi),%eax
 715      0000
 716              	.LBE41:
 717              	.LBE40:
 848:include/linux/skbuff.h **** }
 849:include/linux/skbuff.h **** 
 850:include/linux/skbuff.h **** /**
 851:include/linux/skbuff.h ****  *	skb_tailroom - bytes at buffer end
 852:include/linux/skbuff.h ****  *	@skb: buffer to check
 853:include/linux/skbuff.h ****  *
 854:include/linux/skbuff.h ****  *	Return the number of bytes of free space at the tail of an sk_buff
 855:include/linux/skbuff.h ****  */
 856:include/linux/skbuff.h **** static inline int skb_tailroom(const struct sk_buff *skb)
 857:include/linux/skbuff.h **** {
 718              	.loc 5 857 0
 719 0370 83F807   	cmpl $7,%eax
 720 0373 7E07     	jle .L219
 721 0375 8B4760   	movl 96(%edi),%eax
 722 0378 39F0     	cmpl %esi,%eax
 723 037a 7308     	jae .L218
 724              	.L219:
 240:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 
 241:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	if (skb_tailroom(skb) < CCMP_MIC_LEN || skb->len < hdr_len)
 242:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 		return -1;
 725              	.loc 1 242 0
 726 037c 83C8FF   	orl $-1,%eax
 727 037f E9580100 	jmp .L217
 727      00
 728              	.L218:
 243:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 
 244:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	data_len = skb->len - hdr_len;
 245:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	len = ieee80211_ccmp_hdr(skb, hdr_len, NULL, 0, priv);
 729              	.loc 1 245 0
 730 0384 FF742438 	pushl 56(%esp)
 731              	.LCFI74:
 732 0388 6A00     	pushl $0
 733              	.LCFI75:
 734 038a 6A00     	pushl $0
 735              	.LCFI76:
 736 038c 56       	pushl %esi
GAS LISTING  			page 49


 737              	.LCFI77:
 738 038d 57       	pushl %edi
 739              	.LCFI78:
 740              	.loc 1 244 0
 741 038e 89C5     	movl %eax,%ebp
 742              	.loc 1 245 0
 743 0390 E8B2FEFF 	call ieee80211_ccmp_hdr
 743      FF
 744 0395 89C3     	movl %eax,%ebx
 745              	.loc 1 244 0
 746 0397 29F5     	subl %esi,%ebp
 246:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	if (len < 0)
 747              	.loc 1 246 0
 748 0399 83C414   	addl $20,%esp
 749              	.LCFI79:
 247:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 		return -1;
 750              	.loc 1 247 0
 751 039c 83C8FF   	orl $-1,%eax
 752              	.loc 1 246 0
 753 039f 85DB     	testl %ebx,%ebx
 754 03a1 0F883501 	js .L217
 754      0000
 248:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 
 249:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	pos = skb->data + hdr_len + CCMP_HDR_LEN;
 755              	.loc 1 249 0
 756 03a7 03B7A800 	addl 168(%edi),%esi
 756      0000
 757 03ad 83C608   	addl $8,%esi
 758 03b0 89742418 	movl %esi,24(%esp)
 759              	.LBB42:
 760              	.LBB43:
 761              	.loc 5 758 0
 762 03b4 8B97AC00 	movl 172(%edi),%edx
 762      0000
 763 03ba 89542404 	movl %edx,4(%esp)
 764              	.loc 5 702 0
 765 03be 837F6400 	cmpl $0,100(%edi)
 766 03c2 7402     	je .L225
 767              	.loc 5 759 0
 768              	
 769 03c4 0F0B     	ud2
 770              	
 771              	
 772              	.L225:
 773              	.loc 5 760 0
 774 03c6 8B442404 	movl 4(%esp),%eax
 775 03ca 83C008   	addl $8,%eax
 776              	.loc 5 761 0
 777 03cd 83476008 	addl $8,96(%edi)
 778              	.loc 5 762 0
 779 03d1 3B87B000 	cmpl 176(%edi),%eax
 779      0000
 780              	.loc 5 760 0
 781 03d7 8987AC00 	movl %eax,172(%edi)
 781      0000
 782              	.loc 5 762 0
 783 03dd 7611     	jbe .L228
GAS LISTING  			page 50


 784              	.LBB44:
 785              	.loc 5 763 0
 786              	
 787 03df B8E40300 	movl $1f,%eax
 787      00
 788              	1:
 789              	
 790              	.LBE44:
 791 03e4 50       	pushl %eax
 792              	.LCFI80:
 793 03e5 6A08     	pushl $8
 794              	.LCFI81:
 795 03e7 57       	pushl %edi
 796              	.LCFI82:
 797 03e8 E8FCFFFF 	call skb_over_panic
 797      FF
 798 03ed 83C40C   	addl $12,%esp
 799              	.LCFI83:
 800              	.L228:
 801              	.LBE43:
 802              	.LBE42:
 250:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	mic = skb_put(skb, CCMP_MIC_LEN);
 251:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	hdr = (struct ieee80211_hdr_4addr *)skb->data;
 252:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	ccmp_init_blocks(key->tfm, hdr, key->tx_pn, data_len, b0, b, s0);
 803              	.loc 1 252 0
 804 03f0 FF742408 	pushl 8(%esp)
 805              	.LCFI84:
 806 03f4 FF742414 	pushl 20(%esp)
 807              	.LCFI85:
 808 03f8 FF74241C 	pushl 28(%esp)
 809              	.LCFI86:
 810 03fc 55       	pushl %ebp
 811              	.LCFI87:
 812 03fd 8B442448 	movl 72(%esp),%eax
 813 0401 83C014   	addl $20,%eax
 814 0404 50       	pushl %eax
 815              	.LCFI88:
 816 0405 FFB7A800 	pushl 168(%edi)
 816      0000
 817              	.LCFI89:
 818 040b 8B4C2450 	movl 80(%esp),%ecx
 819 040f FF7130   	pushl 48(%ecx)
 820              	.LCFI90:
 821 0412 E8F5FCFF 	call ccmp_init_blocks
 821      FF
 253:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 
 254:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	blocks = (data_len + AES_BLOCK_LEN - 1) / AES_BLOCK_LEN;
 822              	.loc 1 254 0
 823 0417 8D550F   	leal 15(%ebp),%edx
 824 041a 89D0     	movl %edx,%eax
 825 041c B9100000 	movl $16,%ecx
 825      00
 826 0421 99       	cltd
 827 0422 F7F9     	idivl %ecx
 828 0424 89C7     	movl %eax,%edi
 255:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	last = data_len % AES_BLOCK_LEN;
 829              	.loc 1 255 0
GAS LISTING  			page 51


 830 0426 89E8     	movl %ebp,%eax
 831 0428 99       	cltd
 832 0429 F7F9     	idivl %ecx
 833 042b 89D5     	movl %edx,%ebp
 256:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 
 257:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	for (i = 1; i <= blocks; i++) {
 834              	.loc 1 257 0
 835 042d BE010000 	movl $1,%esi
 835      00
 836 0432 83C41C   	addl $28,%esp
 837              	.LCFI91:
 838              	.L259:
 839 0435 39FE     	cmpl %edi,%esi
 840 0437 0F8F8000 	jg .L251
 840      0000
 258:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 		len = (i == blocks && last) ? last : AES_BLOCK_LEN;
 841              	.loc 1 258 0
 842 043d 39FE     	cmpl %edi,%esi
 843 043f 7506     	jne .L233
 844 0441 85ED     	testl %ebp,%ebp
 845 0443 89EB     	movl %ebp,%ebx
 846 0445 7505     	jne .L234
 847              	.L233:
 848 0447 BB100000 	movl $16,%ebx
 848      00
 849              	.L234:
 850              	.LBB45:
 851              	.LBB46:
 852              	.loc 1 116 0
 853 044c 31D2     	xorl %edx,%edx
 854              	.L260:
 855 044e 39DA     	cmpl %ebx,%edx
 856 0450 7311     	jae .L253
 857              	.loc 1 117 0
 858 0452 8B4C2418 	movl 24(%esp),%ecx
 859 0456 8A0411   	movb (%ecx,%edx),%al
 860 0459 8B4C2410 	movl 16(%esp),%ecx
 861 045d 300411   	xorb %al,(%ecx,%edx)
 862              	.loc 1 116 0
 863 0460 42       	incl %edx
 864 0461 EBEB     	jmp .L260
 865              	.L253:
 866              	.LBE46:
 867              	.LBE45:
 259:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 		/* Authentication */
 260:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 		xor_block(b, pos, len);
 261:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 		ieee80211_ccmp_aes_encrypt(key->tfm, b, b);
 868              	.loc 1 261 0
 869 0463 FF742410 	pushl 16(%esp)
 870              	.LCFI92:
 871 0467 FF742414 	pushl 20(%esp)
 872              	.LCFI93:
 873 046b 8B442440 	movl 64(%esp),%eax
 874 046f FF7030   	pushl 48(%eax)
 875              	.LCFI94:
 876 0472 E889FBFF 	call ieee80211_ccmp_aes_encrypt
 876      FF
GAS LISTING  			page 52


 262:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 		/* Encryption, with counter */
 263:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 		b0[14] = (i >> 8) & 0xff;
 877              	.loc 1 263 0
 878 0477 89F0     	movl %esi,%eax
 879 0479 8B542420 	movl 32(%esp),%edx
 880 047d C1F808   	sarl $8,%eax
 264:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 		b0[15] = i & 0xff;
 881              	.loc 1 264 0
 882 0480 89F1     	movl %esi,%ecx
 883              	.loc 1 263 0
 884 0482 88420E   	movb %al,14(%edx)
 885              	.loc 1 264 0
 886 0485 884A0F   	movb %cl,15(%edx)
 265:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 		ieee80211_ccmp_aes_encrypt(key->tfm, b0, e);
 887              	.loc 1 265 0
 888 0488 FF742418 	pushl 24(%esp)
 889              	.LCFI95:
 890 048c 52       	pushl %edx
 891              	.LCFI96:
 892 048d 8B44244C 	movl 76(%esp),%eax
 893 0491 FF7030   	pushl 48(%eax)
 894              	.LCFI97:
 895              	.LCFI98:
 896 0494 E867FBFF 	call ieee80211_ccmp_aes_encrypt
 896      FF
 897              	.loc 1 114 0
 898 0499 83C418   	addl $24,%esp
 899              	.LCFI99:
 900              	.LBB47:
 901              	.LBB48:
 902              	.loc 1 116 0
 903 049c 31D2     	xorl %edx,%edx
 904              	.L261:
 905 049e 39DA     	cmpl %ebx,%edx
 906 04a0 7311     	jae .L255
 907              	.loc 1 117 0
 908 04a2 8B4C240C 	movl 12(%esp),%ecx
 909 04a6 8A0411   	movb (%ecx,%edx),%al
 910 04a9 8B4C2418 	movl 24(%esp),%ecx
 911 04ad 300411   	xorb %al,(%ecx,%edx)
 912              	.loc 1 116 0
 913 04b0 42       	incl %edx
 914 04b1 EBEB     	jmp .L261
 915              	.L255:
 916              	.LBE48:
 917              	.LBE47:
 266:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 		xor_block(pos, e, len);
 267:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 		pos += len;
 918              	.loc 1 267 0
 919 04b3 015C2418 	addl %ebx,24(%esp)
 920              	.loc 1 257 0
 921 04b7 46       	incl %esi
 922 04b8 E978FFFF 	jmp .L259
 922      FF
 923              	.L251:
 268:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	}
 269:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 
GAS LISTING  			page 53


 270:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	for (i = 0; i < CCMP_MIC_LEN; i++)
 924              	.loc 1 270 0
 925 04bd 31F6     	xorl %esi,%esi
 926              	.L249:
 271:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 		mic[i] = b[i] ^ s0[i];
 927              	.loc 1 271 0
 928 04bf 8B542408 	movl 8(%esp),%edx
 929 04c3 8A0432   	movb (%edx,%esi),%al
 930 04c6 8B4C2410 	movl 16(%esp),%ecx
 931 04ca 320431   	xorb (%ecx,%esi),%al
 932 04cd 8B542404 	movl 4(%esp),%edx
 933 04d1 880432   	movb %al,(%edx,%esi)
 934              	.loc 1 270 0
 935 04d4 46       	incl %esi
 936 04d5 83FE07   	cmpl $7,%esi
 937 04d8 7EE5     	jle .L249
 272:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 
 273:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	return 0;
 938              	.loc 1 273 0
 939 04da 31C0     	xorl %eax,%eax
 940              	.L217:
 274:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** }
 941              	.loc 1 274 0
 942 04dc 83C41C   	addl $28,%esp
 943 04df 5B       	popl %ebx
 944 04e0 5E       	popl %esi
 945 04e1 5F       	popl %edi
 946 04e2 5D       	popl %ebp
 947 04e3 C3       	ret
 948              	.LFE693:
 950              	.section .rodata.str1.1
 951              	.LC2:
 952 0040 3C373E43 	.string "<7>CCMP: received packet without ExtIV flag from %02x:%02x:%02x:%02x:%02x:%02x\n"
 952      434D503A 
 952      20726563 
 952      65697665 
 952      64207061 
 953              	.LC3:
 954 0090 3C373E43 	.string "<7>CCMP: RX tkey->key_idx=%d frame keyidx=%d priv=%p\n"
 954      434D503A 
 954      20525820 
 954      746B6579 
 954      2D3E6B65 
 955              	.LC4:
 956 00c6 3C373E43 	.string "<7>CCMP: received packet from %02x:%02x:%02x:%02x:%02x:%02x with keyid=%d that does not have a configured key\n"
 956      434D503A 
 956      20726563 
 956      65697665 
 956      64207061 
 957              	.LC5:
 958 0135 3C373E43 	.string "<7>CCMP: replay detected: STA=%02x:%02x:%02x:%02x:%02x:%02x previous PN %02x%02x%02x%02x%02x%02x received PN %02x%02x%02x%02x%02x%02x\n"
 958      434D503A 
 958      20726570 
 958      6C617920 
 958      64657465 
 959              	.LC6:
 960 01bc 3C373E43 	.string "<7>CCMP: decrypt failed: STA=%02x:%02x:%02x:%02x:%02x:%02x\n"
GAS LISTING  			page 54


 960      434D503A 
 960      20646563 
 960      72797074 
 960      20666169 
 961              	.text
 963              	ieee80211_ccmp_decrypt:
 964              	.LFB694:
 275:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 
 276:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** static int ieee80211_ccmp_decrypt(struct sk_buff *skb, int hdr_len, void *priv)
 277:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** {
 965              	.loc 1 277 0
 966 04e4 55       	pushl %ebp
 967              	.LCFI100:
 968 04e5 57       	pushl %edi
 969              	.LCFI101:
 970 04e6 56       	pushl %esi
 971              	.LCFI102:
 972 04e7 53       	pushl %ebx
 973              	.LCFI103:
 974 04e8 83EC2C   	subl $44,%esp
 975              	.LCFI104:
 278:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	struct ieee80211_ccmp_data *key = priv;
 279:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	u8 keyidx, *pos;
 280:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	struct ieee80211_hdr_4addr *hdr;
 281:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	u8 *b0 = key->rx_b0;
 976              	.loc 1 281 0
 977 04eb 8B442448 	movl 72(%esp),%eax
 282:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	u8 *b = key->rx_b;
 978              	.loc 1 282 0
 979 04ef 8B542448 	movl 72(%esp),%edx
 283:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	u8 *a = key->rx_a;
 980              	.loc 1 283 0
 981 04f3 8B4C2448 	movl 72(%esp),%ecx
 982              	.loc 1 281 0
 983 04f7 83C074   	addl $116,%eax
 984              	.loc 1 282 0
 985 04fa 81C28400 	addl $132,%edx
 985      0000
 986              	.loc 1 283 0
 987 0500 81C19400 	addl $148,%ecx
 987      0000
 988              	.loc 1 282 0
 989 0506 89542410 	movl %edx,16(%esp)
 990              	.loc 1 283 0
 991 050a 894C240C 	movl %ecx,12(%esp)
 992              	.loc 1 281 0
 993 050e 89442414 	movl %eax,20(%esp)
 284:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	u8 pn[6];
 285:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	int i, blocks, last, len;
 286:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	size_t data_len = skb->len - hdr_len - CCMP_HDR_LEN - CCMP_MIC_LEN;
 994              	.loc 1 286 0
 995 0512 8B542440 	movl 64(%esp),%edx
 996 0516 8B4260   	movl 96(%edx),%eax
 997 0519 89C2     	movl %eax,%edx
 287:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	u8 *mic = skb->data + skb->len - CCMP_MIC_LEN;
 998              	.loc 1 287 0
 999 051b 8B4C2440 	movl 64(%esp),%ecx
GAS LISTING  			page 55


 1000              	.loc 1 286 0
 1001 051f 2B542444 	subl 68(%esp),%edx
 1002              	.loc 1 287 0
 1003 0523 8BB1A800 	movl 168(%ecx),%esi
 1003      0000
 1004              	.loc 1 286 0
 1005 0529 8D6AF0   	leal -16(%edx),%ebp
 1006              	.loc 1 287 0
 1007 052c 8D5406F8 	leal -8(%esi,%eax),%edx
 1008 0530 89542404 	movl %edx,4(%esp)
 288:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 
 289:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	if (skb->len < hdr_len + CCMP_HDR_LEN + CCMP_MIC_LEN) {
 1009              	.loc 1 289 0
 1010 0534 8B542444 	movl 68(%esp),%edx
 1011 0538 83C210   	addl $16,%edx
 1012 053b 39D0     	cmpl %edx,%eax
 1013 053d 730F     	jae .L263
 290:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 		key->dot11RSNAStatsCCMPFormatErrors++;
 1014              	.loc 1 290 0
 1015 053f 8B4C2448 	movl 72(%esp),%ecx
 1016 0543 FF4120   	incl 32(%ecx)
 291:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 		return -1;
 1017              	.loc 1 291 0
 1018 0546 83C8FF   	orl $-1,%eax
 1019 0549 E9630300 	jmp .L262
 1019      00
 1020              	.L263:
 292:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	}
 293:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 
 294:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	hdr = (struct ieee80211_hdr_4addr *)skb->data;
 295:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	pos = skb->data + hdr_len;
 1021              	.loc 1 295 0
 1022 054e 8B442444 	movl 68(%esp),%eax
 1023 0552 8D3C06   	leal (%esi,%eax),%edi
 296:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	keyidx = pos[3];
 1024              	.loc 1 296 0
 1025 0555 8A5703   	movb 3(%edi),%dl
 1026 0558 8854241B 	movb %dl,27(%esp)
 297:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	if (!(keyidx & (1 << 5))) {
 1027              	.loc 1 297 0
 1028 055c 80E220   	andb $32,%dl
 1029 055f 7545     	jne .L264
 298:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 		if (net_ratelimit()) {
 1030              	.loc 1 298 0
 1031 0561 E8FCFFFF 	call net_ratelimit
 1031      FF
 1032 0566 85C0     	testl %eax,%eax
 1033 0568 742B     	je .L265
 299:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 			printk(KERN_DEBUG "CCMP: received packet without ExtIV"
 1034              	.loc 1 299 0
 1035 056a 0FB6460F 	movzbl 15(%esi),%eax
 1036 056e 50       	pushl %eax
 1037              	.LCFI105:
 1038 056f 0FB6460E 	movzbl 14(%esi),%eax
 1039 0573 50       	pushl %eax
 1040              	.LCFI106:
 1041 0574 0FB6460D 	movzbl 13(%esi),%eax
GAS LISTING  			page 56


 1042 0578 50       	pushl %eax
 1043              	.LCFI107:
 1044 0579 0FB6460C 	movzbl 12(%esi),%eax
 1045 057d 50       	pushl %eax
 1046              	.LCFI108:
 1047 057e 0FB6460B 	movzbl 11(%esi),%eax
 1048 0582 50       	pushl %eax
 1049              	.LCFI109:
 1050 0583 0FB6460A 	movzbl 10(%esi),%eax
 1051 0587 50       	pushl %eax
 1052              	.LCFI110:
 1053 0588 68400000 	pushl $.LC2
 1053      00
 1054              	.LCFI111:
 1055 058d E8FCFFFF 	call printk
 1055      FF
 1056 0592 83C41C   	addl $28,%esp
 1057              	.LCFI112:
 1058              	.L265:
 300:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 			       " flag from " MAC_FMT "\n", MAC_ARG(hdr->addr2));
 301:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 		}
 302:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 		key->dot11RSNAStatsCCMPFormatErrors++;
 1059              	.loc 1 302 0
 1060 0595 8B4C2448 	movl 72(%esp),%ecx
 1061 0599 FF4120   	incl 32(%ecx)
 303:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 		return -2;
 1062              	.loc 1 303 0
 1063 059c B8FEFFFF 	movl $-2,%eax
 1063      FF
 1064 05a1 E90B0300 	jmp .L262
 1064      00
 1065              	.L264:
 304:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	}
 305:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	keyidx >>= 6;
 1066              	.loc 1 305 0
 1067 05a6 C06C241B 	shrb $6,27(%esp)
 1067      06
 306:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	if (key->key_idx != keyidx) {
 1068              	.loc 1 306 0
 1069 05ab 8B542448 	movl 72(%esp),%edx
 1070 05af 0FB64424 	movzbl 27(%esp),%eax
 1070      1B
 1071 05b4 8B5A2C   	movl 44(%edx),%ebx
 1072 05b7 39C3     	cmpl %eax,%ebx
 1073 05b9 741A     	je .L266
 307:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 		printk(KERN_DEBUG "CCMP: RX tkey->key_idx=%d frame "
 1074              	.loc 1 307 0
 1075 05bb 52       	pushl %edx
 1076              	.LCFI113:
 1077 05bc 50       	pushl %eax
 1078              	.LCFI114:
 1079 05bd 53       	pushl %ebx
 1080              	.LCFI115:
 1081 05be 68900000 	pushl $.LC3
 1081      00
 1082              	.LCFI116:
 1083 05c3 E8FCFFFF 	call printk
GAS LISTING  			page 57


 1083      FF
 308:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 		       "keyidx=%d priv=%p\n", key->key_idx, keyidx, priv);
 309:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 		return -6;
 1084              	.loc 1 309 0
 1085 05c8 83C410   	addl $16,%esp
 1086              	.LCFI117:
 1087 05cb B8FAFFFF 	movl $-6,%eax
 1087      FF
 1088 05d0 E9DC0200 	jmp .L262
 1088      00
 1089              	.L266:
 310:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	}
 311:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	if (!key->key_set) {
 1090              	.loc 1 311 0
 1091 05d5 8B4C2448 	movl 72(%esp),%ecx
 1092 05d9 83791000 	cmpl $0,16(%ecx)
 1093 05dd 753F     	jne .L267
 312:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 		if (net_ratelimit()) {
 1094              	.loc 1 312 0
 1095 05df E8FCFFFF 	call net_ratelimit
 1095      FF
 1096 05e4 85C0     	testl %eax,%eax
 1097 05e6 742C     	je .L268
 313:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 			printk(KERN_DEBUG "CCMP: received packet from " MAC_FMT
 1098              	.loc 1 313 0
 1099 05e8 53       	pushl %ebx
 1100              	.LCFI118:
 1101 05e9 0FB6460F 	movzbl 15(%esi),%eax
 1102 05ed 50       	pushl %eax
 1103              	.LCFI119:
 1104 05ee 0FB6460E 	movzbl 14(%esi),%eax
 1105 05f2 50       	pushl %eax
 1106              	.LCFI120:
 1107 05f3 0FB6460D 	movzbl 13(%esi),%eax
 1108 05f7 50       	pushl %eax
 1109              	.LCFI121:
 1110 05f8 0FB6460C 	movzbl 12(%esi),%eax
 1111 05fc 50       	pushl %eax
 1112              	.LCFI122:
 1113 05fd 0FB6460B 	movzbl 11(%esi),%eax
 1114 0601 50       	pushl %eax
 1115              	.LCFI123:
 1116 0602 0FB6460A 	movzbl 10(%esi),%eax
 1117 0606 50       	pushl %eax
 1118              	.LCFI124:
 1119 0607 68C60000 	pushl $.LC4
 1119      00
 1120              	.LCFI125:
 1121 060c E8FCFFFF 	call printk
 1121      FF
 1122 0611 83C420   	addl $32,%esp
 1123              	.LCFI126:
 1124              	.L268:
 314:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 			       " with keyid=%d that does not have a configured"
 315:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 			       " key\n", MAC_ARG(hdr->addr2), keyidx);
 316:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 		}
 317:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 		return -3;
GAS LISTING  			page 58


 1125              	.loc 1 317 0
 1126 0614 B8FDFFFF 	movl $-3,%eax
 1126      FF
 1127 0619 E9930200 	jmp .L262
 1127      00
 1128              	.L267:
 318:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	}
 319:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 
 320:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	pn[0] = pos[7];
 1129              	.loc 1 320 0
 1130 061e 8A4707   	movb 7(%edi),%al
 1131 0621 8844241C 	movb %al,28(%esp)
 321:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	pn[1] = pos[6];
 1132              	.loc 1 321 0
 1133 0625 8A4706   	movb 6(%edi),%al
 1134 0628 8844241D 	movb %al,29(%esp)
 322:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	pn[2] = pos[5];
 1135              	.loc 1 322 0
 1136 062c 8A4705   	movb 5(%edi),%al
 1137 062f 8844241E 	movb %al,30(%esp)
 323:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	pn[3] = pos[4];
 1138              	.loc 1 323 0
 1139 0633 8A4704   	movb 4(%edi),%al
 1140 0636 8844241F 	movb %al,31(%esp)
 324:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	pn[4] = pos[1];
 1141              	.loc 1 324 0
 1142 063a 8A4701   	movb 1(%edi),%al
 1143 063d 88442420 	movb %al,32(%esp)
 325:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	pn[5] = pos[0];
 1144              	.loc 1 325 0
 1145 0641 8A07     	movb (%edi),%al
 1146 0643 88442421 	movb %al,33(%esp)
 326:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	pos += 8;
 327:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 
 328:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	if (memcmp(pn, key->rx_pn, CCMP_PN_LEN) <= 0) {
 1147              	.loc 1 328 0
 1148 0647 8B442448 	movl 72(%esp),%eax
 1149 064b 8D5C241C 	leal 28(%esp),%ebx
 1150 064f 83C01A   	addl $26,%eax
 1151 0652 6A06     	pushl $6
 1152              	.LCFI127:
 1153 0654 50       	pushl %eax
 1154              	.LCFI128:
 1155 0655 53       	pushl %ebx
 1156              	.LCFI129:
 1157 0656 E8FCFFFF 	call memcmp
 1157      FF
 1158              	.loc 1 326 0
 1159 065b 83C708   	addl $8,%edi
 1160              	.loc 1 328 0
 1161 065e 83C40C   	addl $12,%esp
 1162              	.LCFI130:
 1163 0661 85C0     	testl %eax,%eax
 1164 0663 0F8F8B00 	jg .L269
 1164      0000
 329:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 		if (net_ratelimit()) {
 1165              	.loc 1 329 0
GAS LISTING  			page 59


 1166 0669 E8FCFFFF 	call net_ratelimit
 1166      FF
 1167 066e 85C0     	testl %eax,%eax
 1168 0670 7471     	je .L270
 330:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 			printk(KERN_DEBUG "CCMP: replay detected: STA=" MAC_FMT
 1169              	.loc 1 330 0
 1170 0672 0FB64424 	movzbl 33(%esp),%eax
 1170      21
 1171 0677 50       	pushl %eax
 1172              	.LCFI131:
 1173 0678 0FB64424 	movzbl 36(%esp),%eax
 1173      24
 1174 067d 50       	pushl %eax
 1175              	.LCFI132:
 1176 067e 0FB64424 	movzbl 39(%esp),%eax
 1176      27
 1177 0683 50       	pushl %eax
 1178              	.LCFI133:
 1179 0684 0FB64424 	movzbl 42(%esp),%eax
 1179      2A
 1180 0689 50       	pushl %eax
 1181              	.LCFI134:
 1182 068a 0FB64424 	movzbl 45(%esp),%eax
 1182      2D
 1183 068f 50       	pushl %eax
 1184              	.LCFI135:
 1185 0690 0FB64424 	movzbl 48(%esp),%eax
 1185      30
 1186 0695 50       	pushl %eax
 1187              	.LCFI136:
 1188 0696 8B542460 	movl 96(%esp),%edx
 1189 069a 0FB6421F 	movzbl 31(%edx),%eax
 1190 069e 50       	pushl %eax
 1191              	.LCFI137:
 1192 069f 0FB6421E 	movzbl 30(%edx),%eax
 1193 06a3 50       	pushl %eax
 1194              	.LCFI138:
 1195 06a4 0FB6421D 	movzbl 29(%edx),%eax
 1196 06a8 50       	pushl %eax
 1197              	.LCFI139:
 1198 06a9 0FB6421C 	movzbl 28(%edx),%eax
 1199 06ad 50       	pushl %eax
 1200              	.LCFI140:
 1201 06ae 0FB6421B 	movzbl 27(%edx),%eax
 1202 06b2 50       	pushl %eax
 1203              	.LCFI141:
 1204 06b3 0FB6421A 	movzbl 26(%edx),%eax
 1205 06b7 50       	pushl %eax
 1206              	.LCFI142:
 1207 06b8 0FB6460F 	movzbl 15(%esi),%eax
 1208 06bc 50       	pushl %eax
 1209              	.LCFI143:
 1210 06bd 0FB6460E 	movzbl 14(%esi),%eax
 1211 06c1 50       	pushl %eax
 1212              	.LCFI144:
 1213 06c2 0FB6460D 	movzbl 13(%esi),%eax
 1214 06c6 50       	pushl %eax
GAS LISTING  			page 60


 1215              	.LCFI145:
 1216 06c7 0FB6460C 	movzbl 12(%esi),%eax
 1217 06cb 50       	pushl %eax
 1218              	.LCFI146:
 1219 06cc 0FB6460B 	movzbl 11(%esi),%eax
 1220 06d0 50       	pushl %eax
 1221              	.LCFI147:
 1222 06d1 0FB6460A 	movzbl 10(%esi),%eax
 1223 06d5 50       	pushl %eax
 1224              	.LCFI148:
 1225 06d6 68350100 	pushl $.LC5
 1225      00
 1226              	.LCFI149:
 1227 06db E8FCFFFF 	call printk
 1227      FF
 1228 06e0 83C44C   	addl $76,%esp
 1229              	.LCFI150:
 1230              	.L270:
 331:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 			       " previous PN %02x%02x%02x%02x%02x%02x "
 332:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 			       "received PN %02x%02x%02x%02x%02x%02x\n",
 333:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 			       MAC_ARG(hdr->addr2), MAC_ARG(key->rx_pn),
 334:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 			       MAC_ARG(pn));
 335:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 		}
 336:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 		key->dot11RSNAStatsCCMPReplays++;
 1231              	.loc 1 336 0
 1232 06e3 8B4C2448 	movl 72(%esp),%ecx
 1233 06e7 FF4124   	incl 36(%ecx)
 337:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 		return -4;
 1234              	.loc 1 337 0
 1235 06ea B8FCFFFF 	movl $-4,%eax
 1235      FF
 1236 06ef E9BD0100 	jmp .L262
 1236      00
 1237              	.L269:
 338:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	}
 339:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 
 340:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	ccmp_init_blocks(key->tfm, hdr, pn, data_len, b0, a, b);
 1238              	.loc 1 340 0
 1239 06f4 FF742410 	pushl 16(%esp)
 1240              	.LCFI151:
 1241 06f8 FF742410 	pushl 16(%esp)
 1242              	.LCFI152:
 1243 06fc FF74241C 	pushl 28(%esp)
 1244              	.LCFI153:
 1245 0700 55       	pushl %ebp
 1246              	.LCFI154:
 1247 0701 53       	pushl %ebx
 1248              	.LCFI155:
 1249 0702 56       	pushl %esi
 1250              	.LCFI156:
 1251 0703 8B442460 	movl 96(%esp),%eax
 1252 0707 FF7030   	pushl 48(%eax)
 1253              	.LCFI157:
 1254 070a E8FDF9FF 	call ccmp_init_blocks
 1254      FF
 1255              	.loc 1 114 0
 1256 070f 83C41C   	addl $28,%esp
GAS LISTING  			page 61


 1257              	.LCFI158:
 1258              	.LBB49:
 1259              	.LBB50:
 1260              	.loc 1 116 0
 1261 0712 31D2     	xorl %edx,%edx
 1262              	.L274:
 1263              	.loc 1 117 0
 1264 0714 8B4C2410 	movl 16(%esp),%ecx
 1265 0718 8A0411   	movb (%ecx,%edx),%al
 1266 071b 8B4C2404 	movl 4(%esp),%ecx
 1267 071f 300411   	xorb %al,(%ecx,%edx)
 1268              	.loc 1 116 0
 1269 0722 42       	incl %edx
 1270 0723 83FA08   	cmpl $8,%edx
 1271 0726 72EC     	jb .L274
 1272              	.LBE50:
 1273              	.LBE49:
 341:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	xor_block(mic, b, CCMP_MIC_LEN);
 342:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 
 343:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	blocks = (data_len + AES_BLOCK_LEN - 1) / AES_BLOCK_LEN;
 1274              	.loc 1 343 0
 1275 0728 8D450F   	leal 15(%ebp),%eax
 344:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	last = data_len % AES_BLOCK_LEN;
 1276              	.loc 1 344 0
 1277 072b 83E50F   	andl $15,%ebp
 1278              	.loc 1 343 0
 1279 072e C1E804   	shrl $4,%eax
 1280              	.loc 1 344 0
 1281 0731 892C24   	movl %ebp,(%esp)
 345:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 
 346:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	for (i = 1; i <= blocks; i++) {
 1282              	.loc 1 346 0
 1283 0734 BD010000 	movl $1,%ebp
 1283      00
 1284              	.loc 1 343 0
 1285 0739 89442408 	movl %eax,8(%esp)
 1286              	.loc 1 346 0
 1287 073d 39C5     	cmpl %eax,%ebp
 1288              	.L335:
 1289 073f 7F7D     	jg .L330
 347:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 		len = (i == blocks && last) ? last : AES_BLOCK_LEN;
 1290              	.loc 1 347 0
 1291 0741 3B6C2408 	cmpl 8(%esp),%ebp
 1292 0745 7507     	jne .L279
 1293 0747 8B1C24   	movl (%esp),%ebx
 1294 074a 85DB     	testl %ebx,%ebx
 1295 074c 7505     	jne .L280
 1296              	.L279:
 1297 074e BB100000 	movl $16,%ebx
 1297      00
 1298              	.L280:
 348:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 		/* Decrypt, with counter */
 349:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 		b0[14] = (i >> 8) & 0xff;
 1299              	.loc 1 349 0
 1300 0753 89E8     	movl %ebp,%eax
 1301 0755 8B542414 	movl 20(%esp),%edx
 1302 0759 C1F808   	sarl $8,%eax
GAS LISTING  			page 62


 350:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 		b0[15] = i & 0xff;
 1303              	.loc 1 350 0
 1304 075c 89E9     	movl %ebp,%ecx
 1305              	.loc 1 349 0
 1306 075e 88420E   	movb %al,14(%edx)
 1307              	.loc 1 350 0
 1308 0761 884A0F   	movb %cl,15(%edx)
 351:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 		ieee80211_ccmp_aes_encrypt(key->tfm, b0, b);
 1309              	.loc 1 351 0
 1310 0764 FF742410 	pushl 16(%esp)
 1311              	.LCFI159:
 1312 0768 52       	pushl %edx
 1313              	.LCFI160:
 1314 0769 8B442450 	movl 80(%esp),%eax
 1315 076d FF7030   	pushl 48(%eax)
 1316              	.LCFI161:
 1317 0770 E88BF8FF 	call ieee80211_ccmp_aes_encrypt
 1317      FF
 1318              	.loc 1 114 0
 1319 0775 83C40C   	addl $12,%esp
 1320              	.LCFI162:
 1321              	.LBB51:
 1322              	.LBB52:
 1323              	.loc 1 116 0
 1324 0778 31D2     	xorl %edx,%edx
 1325              	.L336:
 1326 077a 39DA     	cmpl %ebx,%edx
 1327 077c 730D     	jae .L332
 1328              	.loc 1 117 0
 1329 077e 8B4C2410 	movl 16(%esp),%ecx
 1330 0782 8A0411   	movb (%ecx,%edx),%al
 1331 0785 300417   	xorb %al,(%edi,%edx)
 1332              	.loc 1 116 0
 1333 0788 42       	incl %edx
 1334 0789 EBEF     	jmp .L336
 1335              	.L332:
 1336              	.LBE52:
 1337              	.LBE51:
 1338              	.LBB53:
 1339              	.LBB54:
 1340 078b 31D2     	xorl %edx,%edx
 1341              	.L337:
 1342 078d 39DA     	cmpl %ebx,%edx
 1343 078f 730D     	jae .L334
 1344              	.loc 1 117 0
 1345 0791 8A0417   	movb (%edi,%edx),%al
 1346 0794 8B4C240C 	movl 12(%esp),%ecx
 1347 0798 300411   	xorb %al,(%ecx,%edx)
 1348              	.loc 1 116 0
 1349 079b 42       	incl %edx
 1350 079c EBEF     	jmp .L337
 1351              	.L334:
 1352              	.LBE54:
 1353              	.LBE53:
 352:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 		xor_block(pos, b, len);
 353:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 		/* Authentication */
 354:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 		xor_block(a, pos, len);
GAS LISTING  			page 63


 355:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 		ieee80211_ccmp_aes_encrypt(key->tfm, a, a);
 1354              	.loc 1 355 0
 1355 079e FF74240C 	pushl 12(%esp)
 1356              	.LCFI163:
 1357 07a2 FF742410 	pushl 16(%esp)
 1358              	.LCFI164:
 1359 07a6 8B442450 	movl 80(%esp),%eax
 1360 07aa FF7030   	pushl 48(%eax)
 1361              	.LCFI165:
 1362 07ad E84EF8FF 	call ieee80211_ccmp_aes_encrypt
 1362      FF
 1363              	.loc 1 346 0
 1364 07b2 83C40C   	addl $12,%esp
 1365              	.LCFI166:
 1366 07b5 45       	incl %ebp
 356:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 		pos += len;
 1367              	.loc 1 356 0
 1368 07b6 01DF     	addl %ebx,%edi
 1369              	.loc 1 346 0
 1370 07b8 3B6C2408 	cmpl 8(%esp),%ebp
 1371 07bc EB81     	jmp .L335
 1372              	.L330:
 357:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	}
 358:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 
 359:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	if (memcmp(mic, a, CCMP_MIC_LEN) != 0) {
 1373              	.loc 1 359 0
 1374 07be 6A08     	pushl $8
 1375              	.LCFI167:
 1376 07c0 FF742410 	pushl 16(%esp)
 1377              	.LCFI168:
 1378 07c4 FF74240C 	pushl 12(%esp)
 1379              	.LCFI169:
 1380 07c8 E8FCFFFF 	call memcmp
 1380      FF
 1381 07cd 83C40C   	addl $12,%esp
 1382              	.LCFI170:
 1383 07d0 85C0     	testl %eax,%eax
 1384 07d2 7445     	je .L292
 360:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 		if (net_ratelimit()) {
 1385              	.loc 1 360 0
 1386 07d4 E8FCFFFF 	call net_ratelimit
 1386      FF
 1387 07d9 85C0     	testl %eax,%eax
 1388 07db 742B     	je .L293
 361:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 			printk(KERN_DEBUG "CCMP: decrypt failed: STA="
 1389              	.loc 1 361 0
 1390 07dd 0FB6460F 	movzbl 15(%esi),%eax
 1391 07e1 50       	pushl %eax
 1392              	.LCFI171:
 1393 07e2 0FB6460E 	movzbl 14(%esi),%eax
 1394 07e6 50       	pushl %eax
 1395              	.LCFI172:
 1396 07e7 0FB6460D 	movzbl 13(%esi),%eax
 1397 07eb 50       	pushl %eax
 1398              	.LCFI173:
 1399 07ec 0FB6460C 	movzbl 12(%esi),%eax
 1400 07f0 50       	pushl %eax
GAS LISTING  			page 64


 1401              	.LCFI174:
 1402 07f1 0FB6460B 	movzbl 11(%esi),%eax
 1403 07f5 50       	pushl %eax
 1404              	.LCFI175:
 1405 07f6 0FB6460A 	movzbl 10(%esi),%eax
 1406 07fa 50       	pushl %eax
 1407              	.LCFI176:
 1408 07fb 68BC0100 	pushl $.LC6
 1408      00
 1409              	.LCFI177:
 1410 0800 E8FCFFFF 	call printk
 1410      FF
 1411 0805 83C41C   	addl $28,%esp
 1412              	.LCFI178:
 1413              	.L293:
 362:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 			       MAC_FMT "\n", MAC_ARG(hdr->addr2));
 363:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 		}
 364:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 		key->dot11RSNAStatsCCMPDecryptErrors++;
 1414              	.loc 1 364 0
 1415 0808 8B542448 	movl 72(%esp),%edx
 1416 080c FF4228   	incl 40(%edx)
 365:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 		return -5;
 1417              	.loc 1 365 0
 1418 080f B8FBFFFF 	movl $-5,%eax
 1418      FF
 1419 0814 E9980000 	jmp .L262
 1419      00
 1420              	.L292:
 1421              	.LBB55:
 1422              	.LBB56:
 1423              	.loc 4 240 0
 1424 0819 8B44241C 	movl 28(%esp),%eax
 1425 081d 8B4C2448 	movl 72(%esp),%ecx
 1426 0821 89411A   	movl %eax,26(%ecx)
 1427              	.loc 4 241 0
 1428 0824 8B442420 	movl 32(%esp),%eax
 1429 0828 6689411E 	movw %ax,30(%ecx)
 1430              	.LBE56:
 1431              	.LBE55:
 366:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	}
 367:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 
 368:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	memcpy(key->rx_pn, pn, CCMP_PN_LEN);
 369:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 
 370:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	/* Remove hdr and MIC */
 371:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	memmove(skb->data + CCMP_HDR_LEN, skb->data, hdr_len);
 1432              	.loc 1 371 0
 1433 082c FF742444 	pushl 68(%esp)
 1434              	.LCFI179:
 1435 0830 8B442444 	movl 68(%esp),%eax
 1436 0834 FFB0A800 	pushl 168(%eax)
 1436      0000
 1437              	.LCFI180:
 1438 083a 8B542448 	movl 72(%esp),%edx
 1439 083e 8B82A800 	movl 168(%edx),%eax
 1439      0000
 1440 0844 83C008   	addl $8,%eax
 1441 0847 50       	pushl %eax
GAS LISTING  			page 65


 1442              	.LCFI181:
 1443 0848 E8FCFFFF 	call memmove
 1443      FF
 1444              	.loc 5 810 0
 1445 084d 83C40C   	addl $12,%esp
 1446              	.LCFI182:
 1447              	.LBB57:
 1448              	.LBB58:
 1449              	.loc 5 811 0
 1450 0850 8B4C2440 	movl 64(%esp),%ecx
 1451 0854 8B4160   	movl 96(%ecx),%eax
 1452 0857 83F807   	cmpl $7,%eax
 1453 085a 7618     	jbe .L321
 1454              	.LBB59:
 1455              	.LBB60:
 1456              	.loc 5 794 0
 1457 085c 83E808   	subl $8,%eax
 1458              	.loc 5 795 0
 1459 085f 3B4164   	cmpl 100(%ecx),%eax
 1460              	.loc 5 794 0
 1461 0862 894160   	movl %eax,96(%ecx)
 1462              	.loc 5 795 0
 1463 0865 7302     	jae .L318
 1464              	
 1465 0867 0F0B     	ud2
 1466              	
 1467              	
 1468              	.L318:
 1469 0869 8B442440 	movl 64(%esp),%eax
 1470 086d 8380A800 	addl $8,168(%eax)
 1470      000008
 1471              	.L321:
 1472              	.LBE60:
 1473              	.LBE59:
 1474              	.LBE58:
 1475              	.LBE57:
 1476              	.LBB61:
 858:include/linux/skbuff.h **** 	return skb_is_nonlinear(skb) ? 0 : skb->end - skb->tail;
 859:include/linux/skbuff.h **** }
 860:include/linux/skbuff.h **** 
 861:include/linux/skbuff.h **** /**
 862:include/linux/skbuff.h ****  *	skb_reserve - adjust headroom
 863:include/linux/skbuff.h ****  *	@skb: buffer to alter
 864:include/linux/skbuff.h ****  *	@len: bytes to move
 865:include/linux/skbuff.h ****  *
 866:include/linux/skbuff.h ****  *	Increase the headroom of an empty &sk_buff by reducing the tail
 867:include/linux/skbuff.h ****  *	room. This is only allowed for an empty buffer.
 868:include/linux/skbuff.h ****  */
 869:include/linux/skbuff.h **** static inline void skb_reserve(struct sk_buff *skb, unsigned int len)
 870:include/linux/skbuff.h **** {
 871:include/linux/skbuff.h **** 	skb->data += len;
 872:include/linux/skbuff.h **** 	skb->tail += len;
 873:include/linux/skbuff.h **** }
 874:include/linux/skbuff.h **** 
 875:include/linux/skbuff.h **** /*
 876:include/linux/skbuff.h ****  * CPUs often take a performance hit when accessing unaligned memory
 877:include/linux/skbuff.h ****  * locations. The actual performance hit varies, it can be small if the
GAS LISTING  			page 66


 878:include/linux/skbuff.h ****  * hardware handles it or large if we have to take an exception and fix it
 879:include/linux/skbuff.h ****  * in software.
 880:include/linux/skbuff.h ****  *
 881:include/linux/skbuff.h ****  * Since an ethernet header is 14 bytes network drivers often end up with
 882:include/linux/skbuff.h ****  * the IP header at an unaligned offset. The IP header can be aligned by
 883:include/linux/skbuff.h ****  * shifting the start of the packet by 2 bytes. Drivers should do this
 884:include/linux/skbuff.h ****  * with:
 885:include/linux/skbuff.h ****  *
 886:include/linux/skbuff.h ****  * skb_reserve(NET_IP_ALIGN);
 887:include/linux/skbuff.h ****  *
 888:include/linux/skbuff.h ****  * The downside to this alignment of the IP header is that the DMA is now
 889:include/linux/skbuff.h ****  * unaligned. On some architectures the cost of an unaligned DMA is high
 890:include/linux/skbuff.h ****  * and this cost outweighs the gains made by aligning the IP header.
 891:include/linux/skbuff.h ****  * 
 892:include/linux/skbuff.h ****  * Since this trade off varies between architectures, we allow NET_IP_ALIGN
 893:include/linux/skbuff.h ****  * to be overridden.
 894:include/linux/skbuff.h ****  */
 895:include/linux/skbuff.h **** #ifndef NET_IP_ALIGN
 896:include/linux/skbuff.h **** #define NET_IP_ALIGN	2
 897:include/linux/skbuff.h **** #endif
 898:include/linux/skbuff.h **** 
 899:include/linux/skbuff.h **** extern int ___pskb_trim(struct sk_buff *skb, unsigned int len, int realloc);
 900:include/linux/skbuff.h **** 
 901:include/linux/skbuff.h **** static inline void __skb_trim(struct sk_buff *skb, unsigned int len)
 902:include/linux/skbuff.h **** {
 903:include/linux/skbuff.h **** 	if (!skb->data_len) {
 904:include/linux/skbuff.h **** 		skb->len  = len;
 905:include/linux/skbuff.h **** 		skb->tail = skb->data + len;
 906:include/linux/skbuff.h **** 	} else
 907:include/linux/skbuff.h **** 		___pskb_trim(skb, len, 0);
 908:include/linux/skbuff.h **** }
 909:include/linux/skbuff.h **** 
 910:include/linux/skbuff.h **** /**
 911:include/linux/skbuff.h ****  *	skb_trim - remove end from a buffer
 912:include/linux/skbuff.h ****  *	@skb: buffer to alter
 913:include/linux/skbuff.h ****  *	@len: new length
 914:include/linux/skbuff.h ****  *
 915:include/linux/skbuff.h ****  *	Cut the length of a buffer down by removing data from the tail. If
 916:include/linux/skbuff.h ****  *	the buffer is already under the length specified it is not modified.
 917:include/linux/skbuff.h ****  */
 918:include/linux/skbuff.h **** static inline void skb_trim(struct sk_buff *skb, unsigned int len)
 919:include/linux/skbuff.h **** {
 1477              	.loc 5 919 0
 1478 0874 8B542440 	movl 64(%esp),%edx
 1479 0878 8B4260   	movl 96(%edx),%eax
 1480 087b 8D50F8   	leal -8(%eax),%edx
 1481              	.LBB62:
 920:include/linux/skbuff.h **** 	if (skb->len > len)
 1482              	.loc 5 920 0
 1483 087e 39D0     	cmpl %edx,%eax
 1484 0880 762A     	jbe .L326
 1485              	.LBB63:
 1486              	.LBB64:
 1487              	.loc 5 903 0
 1488 0882 8B4C2440 	movl 64(%esp),%ecx
 1489 0886 83796400 	cmpl $0,100(%ecx)
 1490 088a 7511     	jne .L323
GAS LISTING  			page 67


 1491              	.loc 5 904 0
 1492 088c 895160   	movl %edx,96(%ecx)
 1493              	.loc 5 905 0
 1494 088f 0391A800 	addl 168(%ecx),%edx
 1494      0000
 1495 0895 8991AC00 	movl %edx,172(%ecx)
 1495      0000
 1496 089b EB0F     	jmp .L326
 1497              	.L323:
 1498              	.loc 5 907 0
 1499 089d 6A00     	pushl $0
 1500              	.LCFI183:
 1501 089f 52       	pushl %edx
 1502              	.LCFI184:
 1503 08a0 FF742448 	pushl 72(%esp)
 1504              	.LCFI185:
 1505 08a4 E8FCFFFF 	call ___pskb_trim
 1505      FF
 1506 08a9 83C40C   	addl $12,%esp
 1507              	.LCFI186:
 1508              	.L326:
 1509              	.LBE64:
 1510              	.LBE63:
 1511              	.LBE62:
 1512              	.LBE61:
 372:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	skb_pull(skb, CCMP_HDR_LEN);
 373:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	skb_trim(skb, skb->len - CCMP_MIC_LEN);
 374:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 
 375:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	return keyidx;
 1513              	.loc 1 375 0
 1514 08ac 0FB64424 	movzbl 27(%esp),%eax
 1514      1B
 1515              	.L262:
 376:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** }
 1516              	.loc 1 376 0
 1517 08b1 83C42C   	addl $44,%esp
 1518 08b4 5B       	popl %ebx
 1519 08b5 5E       	popl %esi
 1520 08b6 5F       	popl %edi
 1521 08b7 5D       	popl %ebp
 1522 08b8 C3       	ret
 1523              	.LFE694:
 1526              	ieee80211_ccmp_set_key:
 1527              	.LFB695:
 377:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 
 378:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** static int ieee80211_ccmp_set_key(void *key, int len, u8 * seq, void *priv)
 379:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** {
 1528              	.loc 1 379 0
 1529 08b9 55       	pushl %ebp
 1530              	.LCFI187:
 1531 08ba 57       	pushl %edi
 1532              	.LCFI188:
 1533 08bb 56       	pushl %esi
 1534              	.LCFI189:
 1535 08bc 53       	pushl %ebx
 1536              	.LCFI190:
 1537              	.loc 1 379 0
GAS LISTING  			page 68


 1538 08bd 8B6C2420 	movl 32(%esp),%ebp
 1539 08c1 8B742414 	movl 20(%esp),%esi
 380:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	struct ieee80211_ccmp_data *data = priv;
 381:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	int keyidx;
 382:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	struct crypto_tfm *tfm = data->tfm;
 1540              	.loc 1 382 0
 1541 08c5 8B5D30   	movl 48(%ebp),%ebx
 383:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 
 384:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	keyidx = data->key_idx;
 1542              	.loc 1 384 0
 1543 08c8 8B552C   	movl 44(%ebp),%edx
 1544              	.LBB65:
 1545              	.loc 4 420 0
 1546 08cb 31C0     	xorl %eax,%eax
 1547              	.LBB66:
 1548              	.LBB67:
 1549              	.loc 4 448 0
 1550 08cd B9290000 	movl $41,%ecx
 1550      00
 1551 08d2 89EF     	movl %ebp,%edi
 1552              	
 1553 08d4 F3AB     	rep
 1554              	
 1555              	.LBE67:
 1556              	.LBE66:
 1557              	.LBE65:
 385:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	memset(data, 0, sizeof(*data));
 386:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	data->key_idx = keyidx;
 1558              	.loc 1 386 0
 1559 08d6 89552C   	movl %edx,44(%ebp)
 387:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	data->tfm = tfm;
 1560              	.loc 1 387 0
 1561 08d9 895D30   	movl %ebx,48(%ebp)
 388:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	if (len == CCMP_TK_LEN) {
 1562              	.loc 1 388 0
 1563 08dc 837C2418 	cmpl $16,24(%esp)
 1563      10
 1564 08e1 7555     	jne .L352
 1565              	.LBB68:
 1566              	.LBB69:
 1567              	.loc 4 260 0
 1568 08e3 89EF     	movl %ebp,%edi
 1569              	
 1570 08e5 A5       	movsl
 1571              	.loc 4 262 0
 1572 08e6 A5       	movsl
 1573              	.loc 4 264 0
 1574 08e7 A5       	movsl
 1575              	.loc 4 266 0
 1576 08e8 A5       	movsl
 1577              	
 1578              	.LBE69:
 1579              	.LBE68:
 389:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 		memcpy(data->key, key, CCMP_TK_LEN);
 390:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 		data->key_set = 1;
 1580              	.loc 1 390 0
 1581 08e9 C7451001 	movl $1,16(%ebp)
GAS LISTING  			page 69


 1581      000000
 391:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 		if (seq) {
 1582              	.loc 1 391 0
 1583 08f0 837C241C 	cmpl $0,28(%esp)
 1583      00
 1584 08f5 7427     	je .L375
 392:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 			data->rx_pn[0] = seq[5];
 1585              	.loc 1 392 0
 1586 08f7 8B54241C 	movl 28(%esp),%edx
 1587 08fb 8A4205   	movb 5(%edx),%al
 1588 08fe 88451A   	movb %al,26(%ebp)
 393:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 			data->rx_pn[1] = seq[4];
 1589              	.loc 1 393 0
 1590 0901 8A4204   	movb 4(%edx),%al
 1591 0904 88451B   	movb %al,27(%ebp)
 394:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 			data->rx_pn[2] = seq[3];
 1592              	.loc 1 394 0
 1593 0907 8A4203   	movb 3(%edx),%al
 1594 090a 88451C   	movb %al,28(%ebp)
 395:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 			data->rx_pn[3] = seq[2];
 1595              	.loc 1 395 0
 1596 090d 8A4202   	movb 2(%edx),%al
 1597 0910 88451D   	movb %al,29(%ebp)
 396:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 			data->rx_pn[4] = seq[1];
 1598              	.loc 1 396 0
 1599 0913 8A4201   	movb 1(%edx),%al
 1600 0916 88451E   	movb %al,30(%ebp)
 397:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 			data->rx_pn[5] = seq[0];
 1601              	.loc 1 397 0
 1602 0919 8A02     	movb (%edx),%al
 1603 091b 88451F   	movb %al,31(%ebp)
 1604              	.L375:
 1605              	.LBB70:
 1606              	.loc 2 311 0
 1607 091e 8B5530   	movl 48(%ebp),%edx
 1608              	.LBB71:
 1609              	.LBB72:
 1610              	.LBB73:
 1611              	.loc 2 237 0
 1612 0921 8B4228   	movl 40(%edx),%eax
 1613              	.LBE73:
 1614              	.LBE72:
 1615              	.loc 2 236 0
 1616 0924 80780801 	cmpb $1,8(%eax)
 1617 0928 7402     	je .L376
 1618              	.loc 2 312 0
 1619              	
 1620 092a 0F0B     	ud2
 1621              	
 1622              	
 1623              	.L376:
 1624 092c 6A10     	pushl $16
 1625              	.LCFI191:
 1626 092e 55       	pushl %ebp
 1627              	.LCFI192:
 1628 092f 52       	pushl %edx
 1629              	.LCFI193:
GAS LISTING  			page 70


 1630 0930 FF5210   	call *16(%edx)
 1631 0933 83C40C   	addl $12,%esp
 1632              	.LCFI194:
 1633              	.LBE71:
 1634              	.LBE70:
 1635              	.loc 2 311 0
 1636 0936 EB11     	jmp .L380
 1637              	.L352:
 398:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 		}
 399:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 		crypto_cipher_setkey(data->tfm, data->key, CCMP_TK_LEN);
 400:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	} else if (len == 0)
 401:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 		data->key_set = 0;
 402:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	else
 403:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 		return -1;
 1638              	.loc 1 403 0
 1639 0938 83C8FF   	orl $-1,%eax
 1640              	.loc 1 400 0
 1641 093b 837C2418 	cmpl $0,24(%esp)
 1641      00
 1642 0940 7509     	jne .L338
 1643              	.loc 1 401 0
 1644 0942 C7451000 	movl $0,16(%ebp)
 1644      000000
 1645              	.L380:
 404:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 
 405:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	return 0;
 1646              	.loc 1 405 0
 1647 0949 31C0     	xorl %eax,%eax
 1648              	.L338:
 406:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** }
 1649              	.loc 1 406 0
 1650 094b 5B       	popl %ebx
 1651 094c 5E       	popl %esi
 1652 094d 5F       	popl %edi
 1653 094e 5D       	popl %ebp
 1654 094f C3       	ret
 1655              	.LFE695:
 1658              	ieee80211_ccmp_get_key:
 1659              	.LFB696:
 407:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 
 408:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** static int ieee80211_ccmp_get_key(void *key, int len, u8 * seq, void *priv)
 409:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** {
 1660              	.loc 1 409 0
 1661 0950 57       	pushl %edi
 1662              	.LCFI195:
 1663 0951 56       	pushl %esi
 1664              	.LCFI196:
 410:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	struct ieee80211_ccmp_data *data = priv;
 411:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 
 412:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	if (len < CCMP_TK_LEN)
 413:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 		return -1;
 1665              	.loc 1 413 0
 1666 0952 83C8FF   	orl $-1,%eax
 1667              	.loc 1 412 0
 1668 0955 837C2410 	cmpl $15,16(%esp)
 1668      0F
 1669              	.loc 1 409 0
GAS LISTING  			page 71


 1670 095a 8B7C240C 	movl 12(%esp),%edi
 1671 095e 8B4C2414 	movl 20(%esp),%ecx
 1672 0962 8B542418 	movl 24(%esp),%edx
 1673              	.loc 1 412 0
 1674 0966 7E3A     	jle .L383
 414:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 
 415:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	if (!data->key_set)
 416:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 		return 0;
 1675              	.loc 1 416 0
 1676 0968 31C0     	xorl %eax,%eax
 1677              	.loc 1 415 0
 1678 096a 837A1000 	cmpl $0,16(%edx)
 1679 096e 7432     	je .L383
 1680              	.LBB74:
 1681              	.LBB75:
 1682              	.loc 4 260 0
 1683 0970 89D6     	movl %edx,%esi
 1684              	
 1685 0972 A5       	movsl
 1686              	.loc 4 262 0
 1687 0973 A5       	movsl
 1688              	.loc 4 264 0
 1689 0974 A5       	movsl
 1690              	.loc 4 266 0
 1691 0975 A5       	movsl
 1692              	
 1693              	.LBE75:
 1694              	.LBE74:
 417:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	memcpy(key, data->key, CCMP_TK_LEN);
 418:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 
 419:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	if (seq) {
 1695              	.loc 1 419 0
 1696 0976 85C9     	testl %ecx,%ecx
 1697 0978 7423     	je .L408
 420:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 		seq[0] = data->tx_pn[5];
 1698              	.loc 1 420 0
 1699 097a 8A4219   	movb 25(%edx),%al
 1700 097d 8801     	movb %al,(%ecx)
 421:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 		seq[1] = data->tx_pn[4];
 1701              	.loc 1 421 0
 1702 097f 8A4218   	movb 24(%edx),%al
 1703 0982 884101   	movb %al,1(%ecx)
 422:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 		seq[2] = data->tx_pn[3];
 1704              	.loc 1 422 0
 1705 0985 8A4217   	movb 23(%edx),%al
 1706 0988 884102   	movb %al,2(%ecx)
 423:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 		seq[3] = data->tx_pn[2];
 1707              	.loc 1 423 0
 1708 098b 8A4216   	movb 22(%edx),%al
 1709 098e 884103   	movb %al,3(%ecx)
 424:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 		seq[4] = data->tx_pn[1];
 1710              	.loc 1 424 0
 1711 0991 8A4215   	movb 21(%edx),%al
 1712 0994 884104   	movb %al,4(%ecx)
 425:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 		seq[5] = data->tx_pn[0];
 1713              	.loc 1 425 0
 1714 0997 8A4214   	movb 20(%edx),%al
GAS LISTING  			page 72


 1715 099a 884105   	movb %al,5(%ecx)
 1716              	.L408:
 426:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	}
 427:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 
 428:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	return CCMP_TK_LEN;
 1717              	.loc 1 428 0
 1718 099d B8100000 	movl $16,%eax
 1718      00
 1719              	.L383:
 429:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** }
 1720              	.loc 1 429 0
 1721 09a2 5E       	popl %esi
 1722 09a3 5F       	popl %edi
 1723 09a4 C3       	ret
 1724              	.LFE696:
 1726              	.section .rodata.str1.1
 1727              	.LC7:
 1728 01f8 6B65795B 	.string "key[%d] alg=CCMP key_set=%d tx_pn=%02x%02x%02x%02x%02x%02x rx_pn=%02x%02x%02x%02x%02x%02x format_errors=%d replays=%d decrypt_errors=%d\n"
 1728      25645D20 
 1728      616C673D 
 1728      43434D50 
 1728      206B6579 
 1729              	.text
 1731              	ieee80211_ccmp_print_stats:
 1732              	.LFB697:
 430:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 
 431:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** static char *ieee80211_ccmp_print_stats(char *p, void *priv)
 432:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** {
 1733              	.loc 1 432 0
 1734 09a5 53       	pushl %ebx
 1735              	.LCFI197:
 1736              	.loc 1 432 0
 1737 09a6 8B44240C 	movl 12(%esp),%eax
 1738 09aa 8B5C2408 	movl 8(%esp),%ebx
 433:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	struct ieee80211_ccmp_data *ccmp = priv;
 434:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	p += sprintf(p, "key[%d] alg=CCMP key_set=%d "
 1739              	.loc 1 434 0
 1740 09ae FF7028   	pushl 40(%eax)
 1741              	.LCFI198:
 1742 09b1 FF7024   	pushl 36(%eax)
 1743              	.LCFI199:
 1744 09b4 FF7020   	pushl 32(%eax)
 1745              	.LCFI200:
 1746 09b7 0FB6501F 	movzbl 31(%eax),%edx
 1747 09bb 52       	pushl %edx
 1748              	.LCFI201:
 1749 09bc 0FB6501E 	movzbl 30(%eax),%edx
 1750 09c0 52       	pushl %edx
 1751              	.LCFI202:
 1752 09c1 0FB6501D 	movzbl 29(%eax),%edx
 1753 09c5 52       	pushl %edx
 1754              	.LCFI203:
 1755 09c6 0FB6501C 	movzbl 28(%eax),%edx
 1756 09ca 52       	pushl %edx
 1757              	.LCFI204:
 1758 09cb 0FB6501B 	movzbl 27(%eax),%edx
 1759 09cf 52       	pushl %edx
GAS LISTING  			page 73


 1760              	.LCFI205:
 1761 09d0 0FB6501A 	movzbl 26(%eax),%edx
 1762 09d4 52       	pushl %edx
 1763              	.LCFI206:
 1764 09d5 0FB65019 	movzbl 25(%eax),%edx
 1765 09d9 52       	pushl %edx
 1766              	.LCFI207:
 1767 09da 0FB65018 	movzbl 24(%eax),%edx
 1768 09de 52       	pushl %edx
 1769              	.LCFI208:
 1770 09df 0FB65017 	movzbl 23(%eax),%edx
 1771 09e3 52       	pushl %edx
 1772              	.LCFI209:
 1773 09e4 0FB65016 	movzbl 22(%eax),%edx
 1774 09e8 52       	pushl %edx
 1775              	.LCFI210:
 1776 09e9 0FB65015 	movzbl 21(%eax),%edx
 1777 09ed 52       	pushl %edx
 1778              	.LCFI211:
 1779 09ee 0FB65014 	movzbl 20(%eax),%edx
 1780 09f2 52       	pushl %edx
 1781              	.LCFI212:
 1782 09f3 FF7010   	pushl 16(%eax)
 1783              	.LCFI213:
 1784 09f6 FF702C   	pushl 44(%eax)
 1785              	.LCFI214:
 1786 09f9 68F80100 	pushl $.LC7
 1786      00
 1787              	.LCFI215:
 1788 09fe 53       	pushl %ebx
 1789              	.LCFI216:
 1790 09ff E8FCFFFF 	call sprintf
 1790      FF
 1791 0a04 01C3     	addl %eax,%ebx
 435:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 		     "tx_pn=%02x%02x%02x%02x%02x%02x "
 436:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 		     "rx_pn=%02x%02x%02x%02x%02x%02x "
 437:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 		     "format_errors=%d replays=%d decrypt_errors=%d\n",
 438:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 		     ccmp->key_idx, ccmp->key_set,
 439:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 		     MAC_ARG(ccmp->tx_pn), MAC_ARG(ccmp->rx_pn),
 440:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 		     ccmp->dot11RSNAStatsCCMPFormatErrors,
 441:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 		     ccmp->dot11RSNAStatsCCMPReplays,
 442:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 		     ccmp->dot11RSNAStatsCCMPDecryptErrors);
 443:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 
 444:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	return p;
 1792              	.loc 1 444 0
 1793 0a06 83C44C   	addl $76,%esp
 1794              	.LCFI217:
 445:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** }
 1795              	.loc 1 445 0
 1796 0a09 89D8     	movl %ebx,%eax
 1797 0a0b 5B       	popl %ebx
 1798 0a0c C3       	ret
 1799              	.LFE697:
 1801              	.section .rodata.str1.1
 1802              	.LC8:
 1803 0281 43434D50 	.string "CCMP"
 1803      00
GAS LISTING  			page 74


 1804              	.data
 1805              	.align 32
 1808              	ieee80211_crypt_ccmp:
 1809 0000 81020000 	.long .LC8
 1810 0004 00000000 	.zero 8
 1810      00000000 
 1811 000c 7E000000 	.long ieee80211_ccmp_init
 1812 0010 EB000000 	.long ieee80211_ccmp_deinit
 1813 0014 47020000 	.long ieee80211_ccmp_hdr
 1814 0018 23030000 	.long ieee80211_ccmp_encrypt
 1815 001c E4040000 	.long ieee80211_ccmp_decrypt
 1816 0020 00000000 	.long 0
 1817 0024 00000000 	.long 0
 1818 0028 B9080000 	.long ieee80211_ccmp_set_key
 1819 002c 50090000 	.long ieee80211_ccmp_get_key
 1820 0030 A5090000 	.long ieee80211_ccmp_print_stats
 1821 0034 00000000 	.zero 8
 1821      00000000 
 1822 003c 08000000 	.long 8
 1823 0040 08000000 	.long 8
 1824 0044 00000000 	.zero 8
 1824      00000000 
 1825 004c 00000000 	.long __this_module
 1826              	.section .init.text,"ax",@progbits
 1828              	ieee80211_crypto_ccmp_init:
 1829              	.LFB698:
 446:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 
 447:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** static struct ieee80211_crypto_ops ieee80211_crypt_ccmp = {
 448:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	.name = "CCMP",
 449:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	.init = ieee80211_ccmp_init,
 450:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	.deinit = ieee80211_ccmp_deinit,
 451:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	.build_iv = ieee80211_ccmp_hdr,
 452:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	.encrypt_mpdu = ieee80211_ccmp_encrypt,
 453:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	.decrypt_mpdu = ieee80211_ccmp_decrypt,
 454:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	.encrypt_msdu = NULL,
 455:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	.decrypt_msdu = NULL,
 456:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	.set_key = ieee80211_ccmp_set_key,
 457:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	.get_key = ieee80211_ccmp_get_key,
 458:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	.print_stats = ieee80211_ccmp_print_stats,
 459:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	.extra_mpdu_prefix_len = CCMP_HDR_LEN,
 460:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	.extra_mpdu_postfix_len = CCMP_MIC_LEN,
 461:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	.owner = THIS_MODULE,
 462:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** };
 463:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 
 464:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** static int __init ieee80211_crypto_ccmp_init(void)
 465:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** {
 1830              	.loc 1 465 0
 466:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	return ieee80211_register_crypto_ops(&ieee80211_crypt_ccmp);
 1831              	.loc 1 466 0
 1832 0000 68000000 	pushl $ieee80211_crypt_ccmp
 1832      00
 1833              	.LCFI218:
 1834 0005 E8FCFFFF 	call ieee80211_register_crypto_ops
 1834      FF
 1835 000a 5A       	popl %edx
 1836              	.LCFI219:
 467:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** }
GAS LISTING  			page 75


 1837              	.loc 1 467 0
 1838 000b C3       	ret
 1839              	.LFE698:
 1841              	.section .exit.text,"ax",@progbits
 1843              	ieee80211_crypto_ccmp_exit:
 1844              	.LFB699:
 468:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 
 469:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** static void __exit ieee80211_crypto_ccmp_exit(void)
 470:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** {
 1845              	.loc 1 470 0
 471:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_ccmp.c **** 	ieee80211_unregister_crypto_ops(&ieee80211_crypt_ccmp);
 1846              	.loc 1 471 0
 1847 0000 68000000 	pushl $ieee80211_crypt_ccmp
 1847      00
 1848              	.LCFI220:
 1849 0005 E8FCFFFF 	call ieee80211_unregister_crypto_ops
 1849      FF
 1850 000a 59       	popl %ecx
 1851              	.LCFI221:
 1852 000b C3       	ret
 1853              	.LFE699:
 1855              	.globl init_module
 1856              	.set init_module,ieee80211_crypto_ccmp_init
 1857              	.globl cleanup_module
 1858              	.set cleanup_module,ieee80211_crypto_ccmp_exit
 3351              	.Letext0:
 28624              	.ident "GCC: (GNU) 3.4.5 20050809 (prerelease) (Ubuntu 3.4.4-6ubuntu8.1)"
GAS LISTING  			page 76


DEFINED SYMBOLS
                            *ABS*:0000000000000000 ieee80211_crypt_ccmp.c
 {entrada estÃ¡ndar}:13     .modinfo:0000000000000000 __mod_author29
 {entrada estÃ¡ndar}:18     .modinfo:0000000000000020 __mod_description30
 {entrada estÃ¡ndar}:22     .modinfo:0000000000000040 __mod_license31
 {entrada estÃ¡ndar}:26     .text:0000000000000000 ieee80211_ccmp_aes_encrypt
 {entrada estÃ¡ndar}:119    .text:000000000000007e ieee80211_ccmp_init
 {entrada estÃ¡ndar}:242    .text:00000000000000eb ieee80211_ccmp_deinit
 {entrada estÃ¡ndar}:270    .text:000000000000010c ccmp_init_blocks
 {entrada estÃ¡ndar}:492    .text:0000000000000247 ieee80211_ccmp_hdr
 {entrada estÃ¡ndar}:665    .text:0000000000000323 ieee80211_ccmp_encrypt
 {entrada estÃ¡ndar}:963    .text:00000000000004e4 ieee80211_ccmp_decrypt
 {entrada estÃ¡ndar}:1526   .text:00000000000008b9 ieee80211_ccmp_set_key
 {entrada estÃ¡ndar}:1658   .text:0000000000000950 ieee80211_ccmp_get_key
 {entrada estÃ¡ndar}:1731   .text:00000000000009a5 ieee80211_ccmp_print_stats
 {entrada estÃ¡ndar}:1808   .data:0000000000000000 ieee80211_crypt_ccmp
 {entrada estÃ¡ndar}:1828   .init.text:0000000000000000 ieee80211_crypto_ccmp_init
 {entrada estÃ¡ndar}:1843   .exit.text:0000000000000000 ieee80211_crypto_ccmp_exit
 {entrada estÃ¡ndar}:1828   .init.text:0000000000000000 init_module
 {entrada estÃ¡ndar}:1843   .exit.text:0000000000000000 cleanup_module

UNDEFINED SYMBOLS
mem_map
malloc_sizes
kmem_cache_alloc
crypto_alloc_tfm
printk
crypto_free_tfm
kfree
skb_under_panic
memmove
skb_over_panic
net_ratelimit
memcmp
___pskb_trim
sprintf
__this_module
ieee80211_register_crypto_ops
ieee80211_unregister_crypto_ops
