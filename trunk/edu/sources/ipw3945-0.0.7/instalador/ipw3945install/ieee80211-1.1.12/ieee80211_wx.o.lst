GAS LISTING  			page 1


   1              	.file "ieee80211_wx.c"
   9              	.Ltext0:
  10              	.section .rodata.str1.1,"aMS",@progbits,1
  11              	.LC0:
  12 0000 3F00     	.string "?"
  13              	.LC1:
  14 0002 6100     	.string "a"
  15              	.LC2:
  16 0004 6200     	.string "b"
  17              	.LC3:
  18 0006 616200   	.string "ab"
  19              	.LC4:
  20 0009 6700     	.string "g"
  21              	.LC5:
  22 000b 616700   	.string "ag"
  23              	.LC6:
  24 000e 626700   	.string "bg"
  25              	.LC7:
  26 0011 61626700 	.string "abg"
  27              	.data
  28              	.align 32
  31              	ieee80211_modes:
  32 0000 00000000 	.long .LC0
  33 0004 02000000 	.long .LC1
  34 0008 04000000 	.long .LC2
  35 000c 06000000 	.long .LC3
  36 0010 09000000 	.long .LC4
  37 0014 0B000000 	.long .LC5
  38 0018 0E000000 	.long .LC6
  39 001c 11000000 	.long .LC7
  40              	.section .rodata.str1.1
  41              	.LC8:
  42 0015 3C686964 	.string "<hidden>"
  42      64656E3E 
  42      00
  43              	.LC9:
  44 001e 49454545 	.string "IEEE 802.11%s"
  44      20383032 
  44      2E313125 
  44      7300
  45              	.LC10:
  46 002c 20526174 	.string " Rates (Mb/s): "
  46      65732028 
  46      4D622F73 
  46      293A2000 
  47              	.LC11:
  48 003c 2E3500   	.string ".5"
  49              	.LC12:
  50 003f 00       	.string ""
  51              	.LC13:
  52 0040 25642573 	.string "%d%s "
  52      2000
  53              	.LC14:
  54 0046 7770615F 	.string "wpa_ie="
  54      69653D00 
  55              	.LC15:
  56 004e 25303278 	.string "%02x"
GAS LISTING  			page 2


  56      00
  57              	.LC16:
  58 0053 72736E5F 	.string "rsn_ie="
  58      69653D00 
  59              	.LC17:
  60 005b 204C6173 	.string " Last beacon: %dms ago"
  60      74206265 
  60      61636F6E 
  60      3A202564 
  60      6D732061 
  61              	.LC18:
  62 0072 20436861 	.string " Channel flags: "
  62      6E6E656C 
  62      20666C61 
  62      67733A20 
  62      00
  63              	.LC19:
  64 0083 494E5641 	.string "INVALID "
  64      4C494420 
  64      00
  65              	.LC20:
  66 008c 44465320 	.string "DFS "
  66      00
  67              	.text
  69              	ipw2100_translate_scan:
  70              	.LFB665:
  71              	.file 1 "/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c"
   1:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** /******************************************************************************
   2:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 
   3:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c ****   Copyright(c) 2004-2005 Intel Corporation. All rights reserved.
   4:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 
   5:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c ****   Portions of this file are based on the WEP enablement code provided by the
   6:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c ****   Host AP project hostap-drivers v0.1.3
   7:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c ****   Copyright (c) 2001-2002, SSH Communications Security Corp and Jouni Malinen
   8:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c ****   <jkmaline@cc.hut.fi>
   9:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c ****   Copyright (c) 2002-2003, Jouni Malinen <jkmaline@cc.hut.fi>
  10:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 
  11:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c ****   This program is free software; you can redistribute it and/or modify it
  12:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c ****   under the terms of version 2 of the GNU General Public License as
  13:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c ****   published by the Free Software Foundation.
  14:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 
  15:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c ****   This program is distributed in the hope that it will be useful, but WITHOUT
  16:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c ****   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  17:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c ****   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  18:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c ****   more details.
  19:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 
  20:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c ****   You should have received a copy of the GNU General Public License along with
  21:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c ****   this program; if not, write to the Free Software Foundation, Inc., 59
  22:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c ****   Temple Place - Suite 330, Boston, MA  02111-1307, USA.
  23:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 
  24:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c ****   The full GNU General Public License is included in this distribution in the
  25:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c ****   file called LICENSE.
  26:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 
  27:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c ****   Contact Information:
  28:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c ****   James P. Ketrenos <ipw2100-admin@linux.intel.com>
  29:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c ****   Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497
  30:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 
GAS LISTING  			page 3


  31:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** ******************************************************************************/
  32:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 
  33:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** #include <linux/kmod.h>
  34:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** #include <linux/module.h>
  35:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** #include <linux/jiffies.h>
  36:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 
  37:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** #include <net/ieee80211.h>
  38:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** #include <linux/wireless.h>
  39:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 
  40:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** static const char *ieee80211_modes[] = {
  41:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	"?", "a", "b", "ab", "g", "ag", "bg", "abg"
  42:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** };
  43:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 
  44:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** #define MAX_CUSTOM_LEN 64
  45:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** static char *ipw2100_translate_scan(struct ieee80211_device *ieee,
  46:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 					   char *start, char *stop,
  47:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 					   struct ieee80211_network *network)
  48:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** {
  72              	.loc 1 48 0
  73 0000 55       	pushl %ebp
  74              	.LCFI0:
  75 0001 57       	pushl %edi
  76              	.LCFI1:
  77 0002 56       	pushl %esi
  78              	.LCFI2:
  79 0003 53       	pushl %ebx
  80              	.LCFI3:
  81 0004 81ECBC01 	subl $444,%esp
  81      0000
  82              	.LCFI4:
  83              	.LBB2:
  84              	.LBB3:
  85              	.file 2 "include/asm/string.h"
   1:include/asm/string.h **** #ifndef _I386_STRING_H_
   2:include/asm/string.h **** #define _I386_STRING_H_
   3:include/asm/string.h **** 
   4:include/asm/string.h **** #ifdef __KERNEL__
   5:include/asm/string.h **** #include <linux/config.h>
   6:include/asm/string.h **** /*
   7:include/asm/string.h ****  * On a 486 or Pentium, we are better off not using the
   8:include/asm/string.h ****  * byte string operations. But on a 386 or a PPro the
   9:include/asm/string.h ****  * byte string ops are faster than doing it by hand
  10:include/asm/string.h ****  * (MUCH faster on a Pentium).
  11:include/asm/string.h ****  */
  12:include/asm/string.h **** 
  13:include/asm/string.h **** /*
  14:include/asm/string.h ****  * This string-include defines all string functions as inline
  15:include/asm/string.h ****  * functions. Use gcc. It also assumes ds=es=data space, this should be
  16:include/asm/string.h ****  * normal. Most of the string-functions are rather heavily hand-optimized,
  17:include/asm/string.h ****  * see especially strsep,strstr,str[c]spn. They should work, but are not
  18:include/asm/string.h ****  * very easy to understand. Everything is done entirely within the register
  19:include/asm/string.h ****  * set, making the functions fast and clean. String instructions have been
  20:include/asm/string.h ****  * used through-out, making for "slightly" unclear code :-)
  21:include/asm/string.h ****  *
  22:include/asm/string.h ****  *		NO Copyright (C) 1991, 1992 Linus Torvalds,
  23:include/asm/string.h ****  *		consider these trivial functions to be PD.
  24:include/asm/string.h ****  */
GAS LISTING  			page 4


  25:include/asm/string.h **** 
  26:include/asm/string.h **** /* AK: in fact I bet it would be better to move this stuff all out of line.
  27:include/asm/string.h ****  */
  28:include/asm/string.h **** 
  29:include/asm/string.h **** #define __HAVE_ARCH_STRCPY
  30:include/asm/string.h **** static inline char * strcpy(char * dest,const char *src)
  31:include/asm/string.h **** {
  32:include/asm/string.h **** int d0, d1, d2;
  33:include/asm/string.h **** __asm__ __volatile__(
  34:include/asm/string.h **** 	"1:\tlodsb\n\t"
  35:include/asm/string.h **** 	"stosb\n\t"
  36:include/asm/string.h **** 	"testb %%al,%%al\n\t"
  37:include/asm/string.h **** 	"jne 1b"
  38:include/asm/string.h **** 	: "=&S" (d0), "=&D" (d1), "=&a" (d2)
  39:include/asm/string.h **** 	:"0" (src),"1" (dest) : "memory");
  40:include/asm/string.h **** return dest;
  41:include/asm/string.h **** }
  42:include/asm/string.h **** 
  43:include/asm/string.h **** #define __HAVE_ARCH_STRNCPY
  44:include/asm/string.h **** static inline char * strncpy(char * dest,const char *src,size_t count)
  45:include/asm/string.h **** {
  46:include/asm/string.h **** int d0, d1, d2, d3;
  47:include/asm/string.h **** __asm__ __volatile__(
  48:include/asm/string.h **** 	"1:\tdecl %2\n\t"
  49:include/asm/string.h **** 	"js 2f\n\t"
  50:include/asm/string.h **** 	"lodsb\n\t"
  51:include/asm/string.h **** 	"stosb\n\t"
  52:include/asm/string.h **** 	"testb %%al,%%al\n\t"
  53:include/asm/string.h **** 	"jne 1b\n\t"
  54:include/asm/string.h **** 	"rep\n\t"
  55:include/asm/string.h **** 	"stosb\n"
  56:include/asm/string.h **** 	"2:"
  57:include/asm/string.h **** 	: "=&S" (d0), "=&D" (d1), "=&c" (d2), "=&a" (d3)
  58:include/asm/string.h **** 	:"0" (src),"1" (dest),"2" (count) : "memory");
  59:include/asm/string.h **** return dest;
  60:include/asm/string.h **** }
  61:include/asm/string.h **** 
  62:include/asm/string.h **** #define __HAVE_ARCH_STRCAT
  63:include/asm/string.h **** static inline char * strcat(char * dest,const char * src)
  64:include/asm/string.h **** {
  65:include/asm/string.h **** int d0, d1, d2, d3;
  66:include/asm/string.h **** __asm__ __volatile__(
  67:include/asm/string.h **** 	"repne\n\t"
  68:include/asm/string.h **** 	"scasb\n\t"
  69:include/asm/string.h **** 	"decl %1\n"
  70:include/asm/string.h **** 	"1:\tlodsb\n\t"
  71:include/asm/string.h **** 	"stosb\n\t"
  72:include/asm/string.h **** 	"testb %%al,%%al\n\t"
  73:include/asm/string.h **** 	"jne 1b"
  74:include/asm/string.h **** 	: "=&S" (d0), "=&D" (d1), "=&a" (d2), "=&c" (d3)
  75:include/asm/string.h **** 	: "0" (src), "1" (dest), "2" (0), "3" (0xffffffffu):"memory");
  76:include/asm/string.h **** return dest;
  77:include/asm/string.h **** }
  78:include/asm/string.h **** 
  79:include/asm/string.h **** #define __HAVE_ARCH_STRNCAT
  80:include/asm/string.h **** static inline char * strncat(char * dest,const char * src,size_t count)
  81:include/asm/string.h **** {
GAS LISTING  			page 5


  82:include/asm/string.h **** int d0, d1, d2, d3;
  83:include/asm/string.h **** __asm__ __volatile__(
  84:include/asm/string.h **** 	"repne\n\t"
  85:include/asm/string.h **** 	"scasb\n\t"
  86:include/asm/string.h **** 	"decl %1\n\t"
  87:include/asm/string.h **** 	"movl %8,%3\n"
  88:include/asm/string.h **** 	"1:\tdecl %3\n\t"
  89:include/asm/string.h **** 	"js 2f\n\t"
  90:include/asm/string.h **** 	"lodsb\n\t"
  91:include/asm/string.h **** 	"stosb\n\t"
  92:include/asm/string.h **** 	"testb %%al,%%al\n\t"
  93:include/asm/string.h **** 	"jne 1b\n"
  94:include/asm/string.h **** 	"2:\txorl %2,%2\n\t"
  95:include/asm/string.h **** 	"stosb"
  96:include/asm/string.h **** 	: "=&S" (d0), "=&D" (d1), "=&a" (d2), "=&c" (d3)
  97:include/asm/string.h **** 	: "0" (src),"1" (dest),"2" (0),"3" (0xffffffffu), "g" (count)
  98:include/asm/string.h **** 	: "memory");
  99:include/asm/string.h **** return dest;
 100:include/asm/string.h **** }
 101:include/asm/string.h **** 
 102:include/asm/string.h **** #define __HAVE_ARCH_STRCMP
 103:include/asm/string.h **** static inline int strcmp(const char * cs,const char * ct)
 104:include/asm/string.h **** {
 105:include/asm/string.h **** int d0, d1;
 106:include/asm/string.h **** register int __res;
 107:include/asm/string.h **** __asm__ __volatile__(
 108:include/asm/string.h **** 	"1:\tlodsb\n\t"
 109:include/asm/string.h **** 	"scasb\n\t"
 110:include/asm/string.h **** 	"jne 2f\n\t"
 111:include/asm/string.h **** 	"testb %%al,%%al\n\t"
 112:include/asm/string.h **** 	"jne 1b\n\t"
 113:include/asm/string.h **** 	"xorl %%eax,%%eax\n\t"
 114:include/asm/string.h **** 	"jmp 3f\n"
 115:include/asm/string.h **** 	"2:\tsbbl %%eax,%%eax\n\t"
 116:include/asm/string.h **** 	"orb $1,%%al\n"
 117:include/asm/string.h **** 	"3:"
 118:include/asm/string.h **** 	:"=a" (__res), "=&S" (d0), "=&D" (d1)
 119:include/asm/string.h **** 	:"1" (cs),"2" (ct)
 120:include/asm/string.h **** 	:"memory");
 121:include/asm/string.h **** return __res;
 122:include/asm/string.h **** }
 123:include/asm/string.h **** 
 124:include/asm/string.h **** #define __HAVE_ARCH_STRNCMP
 125:include/asm/string.h **** static inline int strncmp(const char * cs,const char * ct,size_t count)
 126:include/asm/string.h **** {
 127:include/asm/string.h **** register int __res;
 128:include/asm/string.h **** int d0, d1, d2;
 129:include/asm/string.h **** __asm__ __volatile__(
 130:include/asm/string.h **** 	"1:\tdecl %3\n\t"
 131:include/asm/string.h **** 	"js 2f\n\t"
 132:include/asm/string.h **** 	"lodsb\n\t"
 133:include/asm/string.h **** 	"scasb\n\t"
 134:include/asm/string.h **** 	"jne 3f\n\t"
 135:include/asm/string.h **** 	"testb %%al,%%al\n\t"
 136:include/asm/string.h **** 	"jne 1b\n"
 137:include/asm/string.h **** 	"2:\txorl %%eax,%%eax\n\t"
 138:include/asm/string.h **** 	"jmp 4f\n"
GAS LISTING  			page 6


 139:include/asm/string.h **** 	"3:\tsbbl %%eax,%%eax\n\t"
 140:include/asm/string.h **** 	"orb $1,%%al\n"
 141:include/asm/string.h **** 	"4:"
 142:include/asm/string.h **** 	:"=a" (__res), "=&S" (d0), "=&D" (d1), "=&c" (d2)
 143:include/asm/string.h **** 	:"1" (cs),"2" (ct),"3" (count)
 144:include/asm/string.h **** 	:"memory");
 145:include/asm/string.h **** return __res;
 146:include/asm/string.h **** }
 147:include/asm/string.h **** 
 148:include/asm/string.h **** #define __HAVE_ARCH_STRCHR
 149:include/asm/string.h **** static inline char * strchr(const char * s, int c)
 150:include/asm/string.h **** {
 151:include/asm/string.h **** int d0;
 152:include/asm/string.h **** register char * __res;
 153:include/asm/string.h **** __asm__ __volatile__(
 154:include/asm/string.h **** 	"movb %%al,%%ah\n"
 155:include/asm/string.h **** 	"1:\tlodsb\n\t"
 156:include/asm/string.h **** 	"cmpb %%ah,%%al\n\t"
 157:include/asm/string.h **** 	"je 2f\n\t"
 158:include/asm/string.h **** 	"testb %%al,%%al\n\t"
 159:include/asm/string.h **** 	"jne 1b\n\t"
 160:include/asm/string.h **** 	"movl $1,%1\n"
 161:include/asm/string.h **** 	"2:\tmovl %1,%0\n\t"
 162:include/asm/string.h **** 	"decl %0"
 163:include/asm/string.h **** 	:"=a" (__res), "=&S" (d0)
 164:include/asm/string.h **** 	:"1" (s),"0" (c)
 165:include/asm/string.h **** 	:"memory");
 166:include/asm/string.h **** return __res;
 167:include/asm/string.h **** }
 168:include/asm/string.h **** 
 169:include/asm/string.h **** #define __HAVE_ARCH_STRRCHR
 170:include/asm/string.h **** static inline char * strrchr(const char * s, int c)
 171:include/asm/string.h **** {
 172:include/asm/string.h **** int d0, d1;
 173:include/asm/string.h **** register char * __res;
 174:include/asm/string.h **** __asm__ __volatile__(
 175:include/asm/string.h **** 	"movb %%al,%%ah\n"
 176:include/asm/string.h **** 	"1:\tlodsb\n\t"
 177:include/asm/string.h **** 	"cmpb %%ah,%%al\n\t"
 178:include/asm/string.h **** 	"jne 2f\n\t"
 179:include/asm/string.h **** 	"leal -1(%%esi),%0\n"
 180:include/asm/string.h **** 	"2:\ttestb %%al,%%al\n\t"
 181:include/asm/string.h **** 	"jne 1b"
 182:include/asm/string.h **** 	:"=g" (__res), "=&S" (d0), "=&a" (d1)
 183:include/asm/string.h **** 	:"0" (0),"1" (s),"2" (c)
 184:include/asm/string.h **** 	:"memory");
 185:include/asm/string.h **** return __res;
 186:include/asm/string.h **** }
 187:include/asm/string.h **** 
 188:include/asm/string.h **** #define __HAVE_ARCH_STRLEN
 189:include/asm/string.h **** static inline size_t strlen(const char * s)
 190:include/asm/string.h **** {
 191:include/asm/string.h **** int d0;
 192:include/asm/string.h **** register int __res;
 193:include/asm/string.h **** __asm__ __volatile__(
 194:include/asm/string.h **** 	"repne\n\t"
 195:include/asm/string.h **** 	"scasb\n\t"
GAS LISTING  			page 7


 196:include/asm/string.h **** 	"notl %0\n\t"
 197:include/asm/string.h **** 	"decl %0"
 198:include/asm/string.h **** 	:"=c" (__res), "=&D" (d0)
 199:include/asm/string.h **** 	:"1" (s),"a" (0), "0" (0xffffffffu)
 200:include/asm/string.h **** 	:"memory");
 201:include/asm/string.h **** return __res;
 202:include/asm/string.h **** }
 203:include/asm/string.h **** 
 204:include/asm/string.h **** static inline void * __memcpy(void * to, const void * from, size_t n)
 205:include/asm/string.h **** {
 206:include/asm/string.h **** int d0, d1, d2;
 207:include/asm/string.h **** __asm__ __volatile__(
 208:include/asm/string.h **** 	"rep ; movsl\n\t"
 209:include/asm/string.h **** 	"movl %4,%%ecx\n\t"
 210:include/asm/string.h **** 	"andl $3,%%ecx\n\t"
 211:include/asm/string.h **** #if 1	/* want to pay 2 byte penalty for a chance to skip microcoded rep? */
 212:include/asm/string.h **** 	"jz 1f\n\t"
 213:include/asm/string.h **** #endif
 214:include/asm/string.h **** 	"rep ; movsb\n\t"
 215:include/asm/string.h **** 	"1:"
 216:include/asm/string.h **** 	: "=&c" (d0), "=&D" (d1), "=&S" (d2)
 217:include/asm/string.h **** 	: "0" (n/4), "g" (n), "1" ((long) to), "2" ((long) from)
 218:include/asm/string.h **** 	: "memory");
 219:include/asm/string.h **** return (to);
 220:include/asm/string.h **** }
 221:include/asm/string.h **** 
 222:include/asm/string.h **** /*
 223:include/asm/string.h ****  * This looks ugly, but the compiler can optimize it totally,
 224:include/asm/string.h ****  * as the count is constant.
 225:include/asm/string.h ****  */
 226:include/asm/string.h **** static inline void * __constant_memcpy(void * to, const void * from, size_t n)
 227:include/asm/string.h **** {
 228:include/asm/string.h **** 	long esi, edi;
 229:include/asm/string.h **** 	if (!n) return to;
 230:include/asm/string.h **** #if 1	/* want to do small copies with non-string ops? */
 231:include/asm/string.h **** 	switch (n) {
 232:include/asm/string.h **** 		case 1: *(char*)to = *(char*)from; return to;
 233:include/asm/string.h **** 		case 2: *(short*)to = *(short*)from; return to;
 234:include/asm/string.h **** 		case 4: *(int*)to = *(int*)from; return to;
 235:include/asm/string.h **** #if 1	/* including those doable with two moves? */
 236:include/asm/string.h **** 		case 3: *(short*)to = *(short*)from;
 237:include/asm/string.h **** 			*((char*)to+2) = *((char*)from+2); return to;
 238:include/asm/string.h **** 		case 5: *(int*)to = *(int*)from;
 239:include/asm/string.h **** 			*((char*)to+4) = *((char*)from+4); return to;
 240:include/asm/string.h **** 		case 6: *(int*)to = *(int*)from;
  86              	.loc 2 240 0
  87 000a 8B9424DC 	movl 476(%esp),%edx
  87      010000
  88              	.LBE3:
  89              	.LBE2:
  49:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	char custom[MAX_CUSTOM_LEN];
  50:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	char *p;
  51:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	struct iw_event iwe;
  52:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	int i, j;
  53:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	u8 max_rate, rate;
  54:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 
  55:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	/* First entry *MUST* be the AP MAC address */
GAS LISTING  			page 8


  56:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	iwe.cmd = SIOCGIWAP;
  90              	.loc 1 56 0
  91 0011 66C78424 	movw $-29931,350(%esp)
  91      5E010000 
  91      158B
  57:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	iwe.u.ap_addr.sa_family = ARPHRD_ETHER;
  92              	.loc 1 57 0
  93 001b 66C78424 	movw $1,352(%esp)
  93      60010000 
  93      0100
  94              	.LBB4:
  95              	.LBB5:
  96              	.loc 2 240 0
  97 0025 8B02     	movl (%edx),%eax
  98              	.LBE5:
  99              	.LBE4:
 100              	.loc 1 48 0
 101 0027 8BAC24D4 	movl 468(%esp),%ebp
 101      010000
 102              	.LBB6:
 103              	.LBB7:
 104              	.loc 2 240 0
 105 002e 89842462 	movl %eax,354(%esp)
 105      010000
 241:include/asm/string.h **** 			*((short*)to+2) = *((short*)from+2); return to;
 106              	.loc 2 241 0
 107 0035 668B4204 	movw 4(%edx),%ax
 108              	.LBE7:
 109              	.LBE6:
 110              	.LBB8:
 111              	.LBB9:
 112              	.file 3 "include/net/iw_handler.h"
   1:include/net/iw_handler.h **** /*
   2:include/net/iw_handler.h ****  * This file define the new driver API for Wireless Extensions
   3:include/net/iw_handler.h ****  *
   4:include/net/iw_handler.h ****  * Version :	6	21.6.04
   5:include/net/iw_handler.h ****  *
   6:include/net/iw_handler.h ****  * Authors :	Jean Tourrilhes - HPL - <jt@hpl.hp.com>
   7:include/net/iw_handler.h ****  * Copyright (c) 2001-2004 Jean Tourrilhes, All Rights Reserved.
   8:include/net/iw_handler.h ****  */
   9:include/net/iw_handler.h **** 
  10:include/net/iw_handler.h **** #ifndef _IW_HANDLER_H
  11:include/net/iw_handler.h **** #define _IW_HANDLER_H
  12:include/net/iw_handler.h **** 
  13:include/net/iw_handler.h **** /************************** DOCUMENTATION **************************/
  14:include/net/iw_handler.h **** /*
  15:include/net/iw_handler.h ****  * Initial driver API (1996 -> onward) :
  16:include/net/iw_handler.h ****  * -----------------------------------
  17:include/net/iw_handler.h ****  * The initial API just sends the IOCTL request received from user space
  18:include/net/iw_handler.h ****  * to the driver (via the driver ioctl handler). The driver has to
  19:include/net/iw_handler.h ****  * handle all the rest...
  20:include/net/iw_handler.h ****  *
  21:include/net/iw_handler.h ****  * The initial API also defines a specific handler in struct net_device
  22:include/net/iw_handler.h ****  * to handle wireless statistics.
  23:include/net/iw_handler.h ****  *
  24:include/net/iw_handler.h ****  * The initial APIs served us well and has proven a reasonably good design.
  25:include/net/iw_handler.h ****  * However, there is a few shortcommings :
GAS LISTING  			page 9


  26:include/net/iw_handler.h ****  *	o No events, everything is a request to the driver.
  27:include/net/iw_handler.h ****  *	o Large ioctl function in driver with gigantic switch statement
  28:include/net/iw_handler.h ****  *	  (i.e. spaghetti code).
  29:include/net/iw_handler.h ****  *	o Driver has to mess up with copy_to/from_user, and in many cases
  30:include/net/iw_handler.h ****  *	  does it unproperly. Common mistakes are :
  31:include/net/iw_handler.h ****  *		* buffer overflows (no checks or off by one checks)
  32:include/net/iw_handler.h ****  *		* call copy_to/from_user with irq disabled
  33:include/net/iw_handler.h ****  *	o The user space interface is tied to ioctl because of the use
  34:include/net/iw_handler.h ****  *	  copy_to/from_user.
  35:include/net/iw_handler.h ****  *
  36:include/net/iw_handler.h ****  * New driver API (2002 -> onward) :
  37:include/net/iw_handler.h ****  * -------------------------------
  38:include/net/iw_handler.h ****  * The new driver API is just a bunch of standard functions (handlers),
  39:include/net/iw_handler.h ****  * each handling a specific Wireless Extension. The driver just export
  40:include/net/iw_handler.h ****  * the list of handler it supports, and those will be called apropriately.
  41:include/net/iw_handler.h ****  *
  42:include/net/iw_handler.h ****  * I tried to keep the main advantage of the previous API (simplicity,
  43:include/net/iw_handler.h ****  * efficiency and light weight), and also I provide a good dose of backward
  44:include/net/iw_handler.h ****  * compatibility (most structures are the same, driver can use both API
  45:include/net/iw_handler.h ****  * simultaneously, ...).
  46:include/net/iw_handler.h ****  * Hopefully, I've also addressed the shortcomming of the initial API.
  47:include/net/iw_handler.h ****  *
  48:include/net/iw_handler.h ****  * The advantage of the new API are :
  49:include/net/iw_handler.h ****  *	o Handling of Extensions in driver broken in small contained functions
  50:include/net/iw_handler.h ****  *	o Tighter checks of ioctl before calling the driver
  51:include/net/iw_handler.h ****  *	o Flexible commit strategy (at least, the start of it)
  52:include/net/iw_handler.h ****  *	o Backward compatibility (can be mixed with old API)
  53:include/net/iw_handler.h ****  *	o Driver doesn't have to worry about memory and user-space issues
  54:include/net/iw_handler.h ****  * The last point is important for the following reasons :
  55:include/net/iw_handler.h ****  *	o You are now able to call the new driver API from any API you
  56:include/net/iw_handler.h ****  *		want (including from within other parts of the kernel).
  57:include/net/iw_handler.h ****  *	o Common mistakes are avoided (buffer overflow, user space copy
  58:include/net/iw_handler.h ****  *		with irq disabled and so on).
  59:include/net/iw_handler.h ****  *
  60:include/net/iw_handler.h ****  * The Drawback of the new API are :
  61:include/net/iw_handler.h ****  *	o bloat (especially kernel)
  62:include/net/iw_handler.h ****  *	o need to migrate existing drivers to new API
  63:include/net/iw_handler.h ****  * My initial testing shows that the new API adds around 3kB to the kernel
  64:include/net/iw_handler.h ****  * and save between 0 and 5kB from a typical driver.
  65:include/net/iw_handler.h ****  * Also, as all structures and data types are unchanged, the migration is
  66:include/net/iw_handler.h ****  * quite straightforward (but tedious).
  67:include/net/iw_handler.h ****  *
  68:include/net/iw_handler.h ****  * ---
  69:include/net/iw_handler.h ****  *
  70:include/net/iw_handler.h ****  * The new driver API is defined below in this file. User space should
  71:include/net/iw_handler.h ****  * not be aware of what's happening down there...
  72:include/net/iw_handler.h ****  *
  73:include/net/iw_handler.h ****  * A new kernel wrapper is in charge of validating the IOCTLs and calling
  74:include/net/iw_handler.h ****  * the appropriate driver handler. This is implemented in :
  75:include/net/iw_handler.h ****  *	# net/core/wireless.c
  76:include/net/iw_handler.h ****  *
  77:include/net/iw_handler.h ****  * The driver export the list of handlers in :
  78:include/net/iw_handler.h ****  *	# include/linux/netdevice.h (one place)
  79:include/net/iw_handler.h ****  *
  80:include/net/iw_handler.h ****  * The new driver API is available for WIRELESS_EXT >= 13.
  81:include/net/iw_handler.h ****  * Good luck with migration to the new API ;-)
  82:include/net/iw_handler.h ****  */
GAS LISTING  			page 10


  83:include/net/iw_handler.h **** 
  84:include/net/iw_handler.h **** /* ---------------------- THE IMPLEMENTATION ---------------------- */
  85:include/net/iw_handler.h **** /*
  86:include/net/iw_handler.h ****  * Some of the choice I've made are pretty controversials. Defining an
  87:include/net/iw_handler.h ****  * API is very much weighting compromises. This goes into some of the
  88:include/net/iw_handler.h ****  * details and the thinking behind the implementation.
  89:include/net/iw_handler.h ****  *
  90:include/net/iw_handler.h ****  * Implementation goals :
  91:include/net/iw_handler.h ****  * --------------------
  92:include/net/iw_handler.h ****  * The implementation goals were as follow :
  93:include/net/iw_handler.h ****  *	o Obvious : you should not need a PhD to understand what's happening,
  94:include/net/iw_handler.h ****  *		the benefit is easier maintainance.
  95:include/net/iw_handler.h ****  *	o Flexible : it should accommodate a wide variety of driver
  96:include/net/iw_handler.h ****  *		implementations and be as flexible as the old API.
  97:include/net/iw_handler.h ****  *	o Lean : it should be efficient memory wise to minimise the impact
  98:include/net/iw_handler.h ****  *		on kernel footprint.
  99:include/net/iw_handler.h ****  *	o Transparent to user space : the large number of user space
 100:include/net/iw_handler.h ****  *		applications that use Wireless Extensions should not need
 101:include/net/iw_handler.h ****  *		any modifications.
 102:include/net/iw_handler.h ****  *
 103:include/net/iw_handler.h ****  * Array of functions versus Struct of functions
 104:include/net/iw_handler.h ****  * ---------------------------------------------
 105:include/net/iw_handler.h ****  * 1) Having an array of functions allow the kernel code to access the
 106:include/net/iw_handler.h ****  * handler in a single lookup, which is much more efficient (think hash
 107:include/net/iw_handler.h ****  * table here).
 108:include/net/iw_handler.h ****  * 2) The only drawback is that driver writer may put their handler in
 109:include/net/iw_handler.h ****  * the wrong slot. This is trivial to test (I set the frequency, the
 110:include/net/iw_handler.h ****  * bitrate changes). Once the handler is in the proper slot, it will be
 111:include/net/iw_handler.h ****  * there forever, because the array is only extended at the end.
 112:include/net/iw_handler.h ****  * 3) Backward/forward compatibility : adding new handler just require
 113:include/net/iw_handler.h ****  * extending the array, so you can put newer driver in older kernel
 114:include/net/iw_handler.h ****  * without having to patch the kernel code (and vice versa).
 115:include/net/iw_handler.h ****  *
 116:include/net/iw_handler.h ****  * All handler are of the same generic type
 117:include/net/iw_handler.h ****  * ----------------------------------------
 118:include/net/iw_handler.h ****  * That's a feature !!!
 119:include/net/iw_handler.h ****  * 1) Having a generic handler allow to have generic code, which is more
 120:include/net/iw_handler.h ****  * efficient. If each of the handler was individually typed I would need
 121:include/net/iw_handler.h ****  * to add a big switch in the kernel (== more bloat). This solution is
 122:include/net/iw_handler.h ****  * more scalable, adding new Wireless Extensions doesn't add new code.
 123:include/net/iw_handler.h ****  * 2) You can use the same handler in different slots of the array. For
 124:include/net/iw_handler.h ****  * hardware, it may be more efficient or logical to handle multiple
 125:include/net/iw_handler.h ****  * Wireless Extensions with a single function, and the API allow you to
 126:include/net/iw_handler.h ****  * do that. (An example would be a single record on the card to control
 127:include/net/iw_handler.h ****  * both bitrate and frequency, the handler would read the old record,
 128:include/net/iw_handler.h ****  * modify it according to info->cmd and rewrite it).
 129:include/net/iw_handler.h ****  *
 130:include/net/iw_handler.h ****  * Functions prototype uses union iwreq_data
 131:include/net/iw_handler.h ****  * -----------------------------------------
 132:include/net/iw_handler.h ****  * Some would have prefered functions defined this way :
 133:include/net/iw_handler.h ****  *	static int mydriver_ioctl_setrate(struct net_device *dev, 
 134:include/net/iw_handler.h ****  *					  long rate, int auto)
 135:include/net/iw_handler.h ****  * 1) The kernel code doesn't "validate" the content of iwreq_data, and
 136:include/net/iw_handler.h ****  * can't do it (different hardware may have different notion of what a
 137:include/net/iw_handler.h ****  * valid frequency is), so we don't pretend that we do it.
 138:include/net/iw_handler.h ****  * 2) The above form is not extendable. If I want to add a flag (for
 139:include/net/iw_handler.h ****  * example to distinguish setting max rate and basic rate), I would
GAS LISTING  			page 11


 140:include/net/iw_handler.h ****  * break the prototype. Using iwreq_data is more flexible.
 141:include/net/iw_handler.h ****  * 3) Also, the above form is not generic (see above).
 142:include/net/iw_handler.h ****  * 4) I don't expect driver developper using the wrong field of the
 143:include/net/iw_handler.h ****  * union (Doh !), so static typechecking doesn't add much value.
 144:include/net/iw_handler.h ****  * 5) Lastly, you can skip the union by doing :
 145:include/net/iw_handler.h ****  *	static int mydriver_ioctl_setrate(struct net_device *dev,
 146:include/net/iw_handler.h ****  *					  struct iw_request_info *info,
 147:include/net/iw_handler.h ****  *					  struct iw_param *rrq,
 148:include/net/iw_handler.h ****  *					  char *extra)
 149:include/net/iw_handler.h ****  * And then adding the handler in the array like this :
 150:include/net/iw_handler.h ****  *        (iw_handler) mydriver_ioctl_setrate,             // SIOCSIWRATE
 151:include/net/iw_handler.h ****  *
 152:include/net/iw_handler.h ****  * Using functions and not a registry
 153:include/net/iw_handler.h ****  * ----------------------------------
 154:include/net/iw_handler.h ****  * Another implementation option would have been for every instance to
 155:include/net/iw_handler.h ****  * define a registry (a struct containing all the Wireless Extensions)
 156:include/net/iw_handler.h ****  * and only have a function to commit the registry to the hardware.
 157:include/net/iw_handler.h ****  * 1) This approach can be emulated by the current code, but not
 158:include/net/iw_handler.h ****  * vice versa.
 159:include/net/iw_handler.h ****  * 2) Some drivers don't keep any configuration in the driver, for them
 160:include/net/iw_handler.h ****  * adding such a registry would be a significant bloat.
 161:include/net/iw_handler.h ****  * 3) The code to translate from Wireless Extension to native format is
 162:include/net/iw_handler.h ****  * needed anyway, so it would not reduce significantely the amount of code.
 163:include/net/iw_handler.h ****  * 4) The current approach only selectively translate Wireless Extensions
 164:include/net/iw_handler.h ****  * to native format and only selectively set, whereas the registry approach
 165:include/net/iw_handler.h ****  * would require to translate all WE and set all parameters for any single
 166:include/net/iw_handler.h ****  * change.
 167:include/net/iw_handler.h ****  * 5) For many Wireless Extensions, the GET operation return the current
 168:include/net/iw_handler.h ****  * dynamic value, not the value that was set.
 169:include/net/iw_handler.h ****  *
 170:include/net/iw_handler.h ****  * This header is <net/iw_handler.h>
 171:include/net/iw_handler.h ****  * ---------------------------------
 172:include/net/iw_handler.h ****  * 1) This header is kernel space only and should not be exported to
 173:include/net/iw_handler.h ****  * user space. Headers in "include/linux/" are exported, headers in
 174:include/net/iw_handler.h ****  * "include/net/" are not.
 175:include/net/iw_handler.h ****  *
 176:include/net/iw_handler.h ****  * Mixed 32/64 bit issues
 177:include/net/iw_handler.h ****  * ----------------------
 178:include/net/iw_handler.h ****  * The Wireless Extensions are designed to be 64 bit clean, by using only
 179:include/net/iw_handler.h ****  * datatypes with explicit storage size.
 180:include/net/iw_handler.h ****  * There are some issues related to kernel and user space using different
 181:include/net/iw_handler.h ****  * memory model, and in particular 64bit kernel with 32bit user space.
 182:include/net/iw_handler.h ****  * The problem is related to struct iw_point, that contains a pointer
 183:include/net/iw_handler.h ****  * that *may* need to be translated.
 184:include/net/iw_handler.h ****  * This is quite messy. The new API doesn't solve this problem (it can't),
 185:include/net/iw_handler.h ****  * but is a step in the right direction :
 186:include/net/iw_handler.h ****  * 1) Meta data about each ioctl is easily available, so we know what type
 187:include/net/iw_handler.h ****  * of translation is needed.
 188:include/net/iw_handler.h ****  * 2) The move of data between kernel and user space is only done in a single
 189:include/net/iw_handler.h ****  * place in the kernel, so adding specific hooks in there is possible.
 190:include/net/iw_handler.h ****  * 3) In the long term, it allows to move away from using ioctl as the
 191:include/net/iw_handler.h ****  * user space API.
 192:include/net/iw_handler.h ****  *
 193:include/net/iw_handler.h ****  * So many comments and so few code
 194:include/net/iw_handler.h ****  * --------------------------------
 195:include/net/iw_handler.h ****  * That's a feature. Comments won't bloat the resulting kernel binary.
 196:include/net/iw_handler.h ****  */
GAS LISTING  			page 12


 197:include/net/iw_handler.h **** 
 198:include/net/iw_handler.h **** /***************************** INCLUDES *****************************/
 199:include/net/iw_handler.h **** 
 200:include/net/iw_handler.h **** #include <linux/wireless.h>		/* IOCTL user space API */
 201:include/net/iw_handler.h **** #include <linux/if_ether.h>
 202:include/net/iw_handler.h **** 
 203:include/net/iw_handler.h **** /***************************** VERSION *****************************/
 204:include/net/iw_handler.h **** /*
 205:include/net/iw_handler.h ****  * This constant is used to know which version of the driver API is
 206:include/net/iw_handler.h ****  * available. Hopefully, this will be pretty stable and no changes
 207:include/net/iw_handler.h ****  * will be needed...
 208:include/net/iw_handler.h ****  * I just plan to increment with each new version.
 209:include/net/iw_handler.h ****  */
 210:include/net/iw_handler.h **** #define IW_HANDLER_VERSION	6
 211:include/net/iw_handler.h **** 
 212:include/net/iw_handler.h **** /*
 213:include/net/iw_handler.h ****  * Changes :
 214:include/net/iw_handler.h ****  *
 215:include/net/iw_handler.h ****  * V2 to V3
 216:include/net/iw_handler.h ****  * --------
 217:include/net/iw_handler.h ****  *	- Move event definition in <linux/wireless.h>
 218:include/net/iw_handler.h ****  *	- Add Wireless Event support :
 219:include/net/iw_handler.h ****  *		o wireless_send_event() prototype
 220:include/net/iw_handler.h ****  *		o iwe_stream_add_event/point() inline functions
 221:include/net/iw_handler.h ****  * V3 to V4
 222:include/net/iw_handler.h ****  * --------
 223:include/net/iw_handler.h ****  *	- Reshuffle IW_HEADER_TYPE_XXX to map IW_PRIV_TYPE_XXX changes
 224:include/net/iw_handler.h ****  *
 225:include/net/iw_handler.h ****  * V4 to V5
 226:include/net/iw_handler.h ****  * --------
 227:include/net/iw_handler.h ****  *	- Add new spy support : struct iw_spy_data & prototypes
 228:include/net/iw_handler.h ****  *
 229:include/net/iw_handler.h ****  * V5 to V6
 230:include/net/iw_handler.h ****  * --------
 231:include/net/iw_handler.h ****  *	- Change the way we get to spy_data method for added safety
 232:include/net/iw_handler.h ****  *	- Remove spy #ifdef, they are always on -> cleaner code
 233:include/net/iw_handler.h ****  *	- Add IW_DESCR_FLAG_NOMAX flag for very large requests
 234:include/net/iw_handler.h ****  *	- Start migrating get_wireless_stats to struct iw_handler_def
 235:include/net/iw_handler.h ****  */
 236:include/net/iw_handler.h **** 
 237:include/net/iw_handler.h **** /**************************** CONSTANTS ****************************/
 238:include/net/iw_handler.h **** 
 239:include/net/iw_handler.h **** /* Enhanced spy support available */
 240:include/net/iw_handler.h **** #define IW_WIRELESS_SPY
 241:include/net/iw_handler.h **** #define IW_WIRELESS_THRSPY
 242:include/net/iw_handler.h **** 
 243:include/net/iw_handler.h **** /* Special error message for the driver to indicate that we
 244:include/net/iw_handler.h ****  * should do a commit after return from the iw_handler */
 245:include/net/iw_handler.h **** #define EIWCOMMIT	EINPROGRESS
 246:include/net/iw_handler.h **** 
 247:include/net/iw_handler.h **** /* Flags available in struct iw_request_info */
 248:include/net/iw_handler.h **** #define IW_REQUEST_FLAG_NONE	0x0000	/* No flag so far */
 249:include/net/iw_handler.h **** 
 250:include/net/iw_handler.h **** /* Type of headers we know about (basically union iwreq_data) */
 251:include/net/iw_handler.h **** #define IW_HEADER_TYPE_NULL	0	/* Not available */
 252:include/net/iw_handler.h **** #define IW_HEADER_TYPE_CHAR	2	/* char [IFNAMSIZ] */
 253:include/net/iw_handler.h **** #define IW_HEADER_TYPE_UINT	4	/* __u32 */
GAS LISTING  			page 13


 254:include/net/iw_handler.h **** #define IW_HEADER_TYPE_FREQ	5	/* struct iw_freq */
 255:include/net/iw_handler.h **** #define IW_HEADER_TYPE_ADDR	6	/* struct sockaddr */
 256:include/net/iw_handler.h **** #define IW_HEADER_TYPE_POINT	8	/* struct iw_point */
 257:include/net/iw_handler.h **** #define IW_HEADER_TYPE_PARAM	9	/* struct iw_param */
 258:include/net/iw_handler.h **** #define IW_HEADER_TYPE_QUAL	10	/* struct iw_quality */
 259:include/net/iw_handler.h **** 
 260:include/net/iw_handler.h **** /* Handling flags */
 261:include/net/iw_handler.h **** /* Most are not implemented. I just use them as a reminder of some
 262:include/net/iw_handler.h ****  * cool features we might need one day ;-) */
 263:include/net/iw_handler.h **** #define IW_DESCR_FLAG_NONE	0x0000	/* Obvious */
 264:include/net/iw_handler.h **** /* Wrapper level flags */
 265:include/net/iw_handler.h **** #define IW_DESCR_FLAG_DUMP	0x0001	/* Not part of the dump command */
 266:include/net/iw_handler.h **** #define IW_DESCR_FLAG_EVENT	0x0002	/* Generate an event on SET */
 267:include/net/iw_handler.h **** #define IW_DESCR_FLAG_RESTRICT	0x0004	/* GET : request is ROOT only */
 268:include/net/iw_handler.h **** 				/* SET : Omit payload from generated iwevent */
 269:include/net/iw_handler.h **** #define IW_DESCR_FLAG_NOMAX	0x0008	/* GET : no limit on request size */
 270:include/net/iw_handler.h **** /* Driver level flags */
 271:include/net/iw_handler.h **** #define IW_DESCR_FLAG_WAIT	0x0100	/* Wait for driver event */
 272:include/net/iw_handler.h **** 
 273:include/net/iw_handler.h **** /****************************** TYPES ******************************/
 274:include/net/iw_handler.h **** 
 275:include/net/iw_handler.h **** /* ----------------------- WIRELESS HANDLER ----------------------- */
 276:include/net/iw_handler.h **** /*
 277:include/net/iw_handler.h ****  * A wireless handler is just a standard function, that looks like the
 278:include/net/iw_handler.h ****  * ioctl handler.
 279:include/net/iw_handler.h ****  * We also define there how a handler list look like... As the Wireless
 280:include/net/iw_handler.h ****  * Extension space is quite dense, we use a simple array, which is faster
 281:include/net/iw_handler.h ****  * (that's the perfect hash table ;-).
 282:include/net/iw_handler.h ****  */
 283:include/net/iw_handler.h **** 
 284:include/net/iw_handler.h **** /*
 285:include/net/iw_handler.h ****  * Meta data about the request passed to the iw_handler.
 286:include/net/iw_handler.h ****  * Most handlers can safely ignore what's in there.
 287:include/net/iw_handler.h ****  * The 'cmd' field might come handy if you want to use the same handler
 288:include/net/iw_handler.h ****  * for multiple command...
 289:include/net/iw_handler.h ****  * This struct is also my long term insurance. I can add new fields here
 290:include/net/iw_handler.h ****  * without breaking the prototype of iw_handler...
 291:include/net/iw_handler.h ****  */
 292:include/net/iw_handler.h **** struct iw_request_info
 293:include/net/iw_handler.h **** {
 294:include/net/iw_handler.h **** 	__u16		cmd;		/* Wireless Extension command */
 295:include/net/iw_handler.h **** 	__u16		flags;		/* More to come ;-) */
 296:include/net/iw_handler.h **** };
 297:include/net/iw_handler.h **** 
 298:include/net/iw_handler.h **** struct net_device;
 299:include/net/iw_handler.h **** 
 300:include/net/iw_handler.h **** /*
 301:include/net/iw_handler.h ****  * This is how a function handling a Wireless Extension should look
 302:include/net/iw_handler.h ****  * like (both get and set, standard and private).
 303:include/net/iw_handler.h ****  */
 304:include/net/iw_handler.h **** typedef int (*iw_handler)(struct net_device *dev, struct iw_request_info *info,
 305:include/net/iw_handler.h **** 			  union iwreq_data *wrqu, char *extra);
 306:include/net/iw_handler.h **** 
 307:include/net/iw_handler.h **** /*
 308:include/net/iw_handler.h ****  * This define all the handler that the driver export.
 309:include/net/iw_handler.h ****  * As you need only one per driver type, please use a static const
 310:include/net/iw_handler.h ****  * shared by all driver instances... Same for the members...
GAS LISTING  			page 14


 311:include/net/iw_handler.h ****  * This will be linked from net_device in <linux/netdevice.h>
 312:include/net/iw_handler.h ****  */
 313:include/net/iw_handler.h **** struct iw_handler_def
 314:include/net/iw_handler.h **** {
 315:include/net/iw_handler.h **** 	/* Number of handlers defined (more precisely, index of the
 316:include/net/iw_handler.h **** 	 * last defined handler + 1) */
 317:include/net/iw_handler.h **** 	__u16			num_standard;
 318:include/net/iw_handler.h **** 	__u16			num_private;
 319:include/net/iw_handler.h **** 	/* Number of private arg description */
 320:include/net/iw_handler.h **** 	__u16			num_private_args;
 321:include/net/iw_handler.h **** 
 322:include/net/iw_handler.h **** 	/* Array of handlers for standard ioctls
 323:include/net/iw_handler.h **** 	 * We will call dev->wireless_handlers->standard[ioctl - SIOCSIWNAME]
 324:include/net/iw_handler.h **** 	 */
 325:include/net/iw_handler.h **** 	const iw_handler *	standard;
 326:include/net/iw_handler.h **** 
 327:include/net/iw_handler.h **** 	/* Array of handlers for private ioctls
 328:include/net/iw_handler.h **** 	 * Will call dev->wireless_handlers->private[ioctl - SIOCIWFIRSTPRIV]
 329:include/net/iw_handler.h **** 	 */
 330:include/net/iw_handler.h **** 	const iw_handler *	private;
 331:include/net/iw_handler.h **** 
 332:include/net/iw_handler.h **** 	/* Arguments of private handler. This one is just a list, so you
 333:include/net/iw_handler.h **** 	 * can put it in any order you want and should not leave holes...
 334:include/net/iw_handler.h **** 	 * We will automatically export that to user space... */
 335:include/net/iw_handler.h **** 	const struct iw_priv_args *	private_args;
 336:include/net/iw_handler.h **** 
 337:include/net/iw_handler.h **** 	/* This field will be *removed* in the next version of WE */
 338:include/net/iw_handler.h **** 	long			spy_offset;	/* DO NOT USE */
 339:include/net/iw_handler.h **** 
 340:include/net/iw_handler.h **** 	/* New location of get_wireless_stats, to de-bloat struct net_device.
 341:include/net/iw_handler.h **** 	 * The old pointer in struct net_device will be gradually phased
 342:include/net/iw_handler.h **** 	 * out, and drivers are encouraged to use this one... */
 343:include/net/iw_handler.h **** 	struct iw_statistics*	(*get_wireless_stats)(struct net_device *dev);
 344:include/net/iw_handler.h **** };
 345:include/net/iw_handler.h **** 
 346:include/net/iw_handler.h **** /* ---------------------- IOCTL DESCRIPTION ---------------------- */
 347:include/net/iw_handler.h **** /*
 348:include/net/iw_handler.h ****  * One of the main goal of the new interface is to deal entirely with
 349:include/net/iw_handler.h ****  * user space/kernel space memory move.
 350:include/net/iw_handler.h ****  * For that, we need to know :
 351:include/net/iw_handler.h ****  *	o if iwreq is a pointer or contain the full data
 352:include/net/iw_handler.h ****  *	o what is the size of the data to copy
 353:include/net/iw_handler.h ****  *
 354:include/net/iw_handler.h ****  * For private IOCTLs, we use the same rules as used by iwpriv and
 355:include/net/iw_handler.h ****  * defined in struct iw_priv_args.
 356:include/net/iw_handler.h ****  *
 357:include/net/iw_handler.h ****  * For standard IOCTLs, things are quite different and we need to
 358:include/net/iw_handler.h ****  * use the stuctures below. Actually, this struct is also more
 359:include/net/iw_handler.h ****  * efficient, but that's another story...
 360:include/net/iw_handler.h ****  */
 361:include/net/iw_handler.h **** 
 362:include/net/iw_handler.h **** /*
 363:include/net/iw_handler.h ****  * Describe how a standard IOCTL looks like.
 364:include/net/iw_handler.h ****  */
 365:include/net/iw_handler.h **** struct iw_ioctl_description
 366:include/net/iw_handler.h **** {
 367:include/net/iw_handler.h **** 	__u8	header_type;		/* NULL, iw_point or other */
GAS LISTING  			page 15


 368:include/net/iw_handler.h **** 	__u8	token_type;		/* Future */
 369:include/net/iw_handler.h **** 	__u16	token_size;		/* Granularity of payload */
 370:include/net/iw_handler.h **** 	__u16	min_tokens;		/* Min acceptable token number */
 371:include/net/iw_handler.h **** 	__u16	max_tokens;		/* Max acceptable token number */
 372:include/net/iw_handler.h **** 	__u32	flags;			/* Special handling of the request */
 373:include/net/iw_handler.h **** };
 374:include/net/iw_handler.h **** 
 375:include/net/iw_handler.h **** /* Need to think of short header translation table. Later. */
 376:include/net/iw_handler.h **** 
 377:include/net/iw_handler.h **** /* --------------------- ENHANCED SPY SUPPORT --------------------- */
 378:include/net/iw_handler.h **** /*
 379:include/net/iw_handler.h ****  * In the old days, the driver was handling spy support all by itself.
 380:include/net/iw_handler.h ****  * Now, the driver can delegate this task to Wireless Extensions.
 381:include/net/iw_handler.h ****  * It needs to include this struct in its private part and use the
 382:include/net/iw_handler.h ****  * standard spy iw_handler.
 383:include/net/iw_handler.h ****  */
 384:include/net/iw_handler.h **** 
 385:include/net/iw_handler.h **** /*
 386:include/net/iw_handler.h ****  * Instance specific spy data, i.e. addresses spied and quality for them.
 387:include/net/iw_handler.h ****  */
 388:include/net/iw_handler.h **** struct iw_spy_data
 389:include/net/iw_handler.h **** {
 390:include/net/iw_handler.h **** 	/* --- Standard spy support --- */
 391:include/net/iw_handler.h **** 	int			spy_number;
 392:include/net/iw_handler.h **** 	u_char			spy_address[IW_MAX_SPY][ETH_ALEN];
 393:include/net/iw_handler.h **** 	struct iw_quality	spy_stat[IW_MAX_SPY];
 394:include/net/iw_handler.h **** 	/* --- Enhanced spy support (event) */
 395:include/net/iw_handler.h **** 	struct iw_quality	spy_thr_low;	/* Low threshold */
 396:include/net/iw_handler.h **** 	struct iw_quality	spy_thr_high;	/* High threshold */
 397:include/net/iw_handler.h **** 	u_char			spy_thr_under[IW_MAX_SPY];
 398:include/net/iw_handler.h **** };
 399:include/net/iw_handler.h **** 
 400:include/net/iw_handler.h **** /* --------------------- DEVICE WIRELESS DATA --------------------- */
 401:include/net/iw_handler.h **** /*
 402:include/net/iw_handler.h ****  * This is all the wireless data specific to a device instance that
 403:include/net/iw_handler.h ****  * is managed by the core of Wireless Extensions.
 404:include/net/iw_handler.h ****  * We only keep pointer to those structures, so that a driver is free
 405:include/net/iw_handler.h ****  * to share them between instances.
 406:include/net/iw_handler.h ****  * This structure should be initialised before registering the device.
 407:include/net/iw_handler.h ****  * Access to this data follow the same rules as any other struct net_device
 408:include/net/iw_handler.h ****  * data (i.e. valid as long as struct net_device exist, same locking rules).
 409:include/net/iw_handler.h ****  */
 410:include/net/iw_handler.h **** struct iw_public_data {
 411:include/net/iw_handler.h **** 	/* Driver enhanced spy support */
 412:include/net/iw_handler.h **** 	struct iw_spy_data *	spy_data;
 413:include/net/iw_handler.h **** };
 414:include/net/iw_handler.h **** 
 415:include/net/iw_handler.h **** /**************************** PROTOTYPES ****************************/
 416:include/net/iw_handler.h **** /*
 417:include/net/iw_handler.h ****  * Functions part of the Wireless Extensions (defined in net/core/wireless.c).
 418:include/net/iw_handler.h ****  * Those may be called only within the kernel.
 419:include/net/iw_handler.h ****  */
 420:include/net/iw_handler.h **** 
 421:include/net/iw_handler.h **** /* First : function strictly used inside the kernel */
 422:include/net/iw_handler.h **** 
 423:include/net/iw_handler.h **** /* Handle /proc/net/wireless, called in net/code/dev.c */
 424:include/net/iw_handler.h **** extern int dev_get_wireless_info(char * buffer, char **start, off_t offset,
GAS LISTING  			page 16


 425:include/net/iw_handler.h **** 				 int length);
 426:include/net/iw_handler.h **** 
 427:include/net/iw_handler.h **** /* Handle IOCTLs, called in net/code/dev.c */
 428:include/net/iw_handler.h **** extern int wireless_process_ioctl(struct ifreq *ifr, unsigned int cmd);
 429:include/net/iw_handler.h **** 
 430:include/net/iw_handler.h **** /* Second : functions that may be called by driver modules */
 431:include/net/iw_handler.h **** 
 432:include/net/iw_handler.h **** /* Send a single event to user space */
 433:include/net/iw_handler.h **** extern void wireless_send_event(struct net_device *	dev,
 434:include/net/iw_handler.h **** 				unsigned int		cmd,
 435:include/net/iw_handler.h **** 				union iwreq_data *	wrqu,
 436:include/net/iw_handler.h **** 				char *			extra);
 437:include/net/iw_handler.h **** 
 438:include/net/iw_handler.h **** /* We may need a function to send a stream of events to user space.
 439:include/net/iw_handler.h ****  * More on that later... */
 440:include/net/iw_handler.h **** 
 441:include/net/iw_handler.h **** /* Standard handler for SIOCSIWSPY */
 442:include/net/iw_handler.h **** extern int iw_handler_set_spy(struct net_device *	dev,
 443:include/net/iw_handler.h **** 			      struct iw_request_info *	info,
 444:include/net/iw_handler.h **** 			      union iwreq_data *	wrqu,
 445:include/net/iw_handler.h **** 			      char *			extra);
 446:include/net/iw_handler.h **** /* Standard handler for SIOCGIWSPY */
 447:include/net/iw_handler.h **** extern int iw_handler_get_spy(struct net_device *	dev,
 448:include/net/iw_handler.h **** 			      struct iw_request_info *	info,
 449:include/net/iw_handler.h **** 			      union iwreq_data *	wrqu,
 450:include/net/iw_handler.h **** 			      char *			extra);
 451:include/net/iw_handler.h **** /* Standard handler for SIOCSIWTHRSPY */
 452:include/net/iw_handler.h **** extern int iw_handler_set_thrspy(struct net_device *	dev,
 453:include/net/iw_handler.h **** 				 struct iw_request_info *info,
 454:include/net/iw_handler.h **** 				 union iwreq_data *	wrqu,
 455:include/net/iw_handler.h **** 				 char *			extra);
 456:include/net/iw_handler.h **** /* Standard handler for SIOCGIWTHRSPY */
 457:include/net/iw_handler.h **** extern int iw_handler_get_thrspy(struct net_device *	dev,
 458:include/net/iw_handler.h **** 				 struct iw_request_info *info,
 459:include/net/iw_handler.h **** 				 union iwreq_data *	wrqu,
 460:include/net/iw_handler.h **** 				 char *			extra);
 461:include/net/iw_handler.h **** /* Driver call to update spy records */
 462:include/net/iw_handler.h **** extern void wireless_spy_update(struct net_device *	dev,
 463:include/net/iw_handler.h **** 				unsigned char *		address,
 464:include/net/iw_handler.h **** 				struct iw_quality *	wstats);
 465:include/net/iw_handler.h **** 
 466:include/net/iw_handler.h **** /************************* INLINE FUNTIONS *************************/
 467:include/net/iw_handler.h **** /*
 468:include/net/iw_handler.h ****  * Function that are so simple that it's more efficient inlining them
 469:include/net/iw_handler.h ****  */
 470:include/net/iw_handler.h **** 
 471:include/net/iw_handler.h **** /*------------------------------------------------------------------*/
 472:include/net/iw_handler.h **** /*
 473:include/net/iw_handler.h ****  * Wrapper to add an Wireless Event to a stream of events.
 474:include/net/iw_handler.h ****  */
 475:include/net/iw_handler.h **** static inline char *
 476:include/net/iw_handler.h **** iwe_stream_add_event(char *	stream,		/* Stream of events */
 477:include/net/iw_handler.h **** 		     char *	ends,		/* End of stream */
 478:include/net/iw_handler.h **** 		     struct iw_event *iwe,	/* Payload */
 479:include/net/iw_handler.h **** 		     int	event_len)	/* Real size of payload */
 480:include/net/iw_handler.h **** {
 481:include/net/iw_handler.h **** 	/* Check if it's possible */
GAS LISTING  			page 17


 482:include/net/iw_handler.h **** 	if((stream + event_len) < ends) {
 113              	.loc 3 482 0
 114 0039 8D5514   	leal 20(%ebp),%edx
 115 003c 3B9424D8 	cmpl 472(%esp),%edx
 115      010000
 116              	.LBE9:
 117              	.LBE8:
 118              	.LBB10:
 119              	.LBB11:
 120              	.loc 2 241 0
 121 0043 66898424 	movw %ax,358(%esp)
 121      66010000 
 122              	.loc 2 231 0
 123 004b B9050000 	movl $5,%ecx
 123      00
 124              	.LBE11:
 125              	.LBE10:
 126              	.LBB12:
 127              	.loc 3 480 0
 128 0050 89EF     	movl %ebp,%edi
 129 0052 8D84245C 	leal 348(%esp),%eax
 129      010000
 130              	.LBB13:
 131              	.loc 3 482 0
 132 0059 7310     	jae .L24
 483:include/net/iw_handler.h **** 		iwe->len = event_len;
 133              	.loc 3 483 0
 134 005b 66C78424 	movw $20,348(%esp)
 134      5C010000 
 134      1400
 135              	.LBB14:
 136              	.LBB15:
 137              	.LBB16:
 242:include/asm/string.h **** 		case 8: *(int*)to = *(int*)from;
 243:include/asm/string.h **** 			*((int*)to+1) = *((int*)from+1); return to;
 244:include/asm/string.h **** #endif
 245:include/asm/string.h **** 	}
 246:include/asm/string.h **** #endif
 247:include/asm/string.h **** 	esi = (long) from;
 248:include/asm/string.h **** 	edi = (long) to;
 249:include/asm/string.h **** 	if (n >= 5*4) {
 250:include/asm/string.h **** 		/* large block: use rep prefix */
 251:include/asm/string.h **** 		int ecx;
 252:include/asm/string.h **** 		__asm__ __volatile__(
 138              	.loc 2 252 0
 139 0065 89C6     	movl %eax,%esi
 140              	
 141 0067 F3A5     	rep
 142              	
 143              	.LBE16:
 144              	.LBE15:
 145              	.LBE14:
 484:include/net/iw_handler.h **** 		memcpy(stream, (char *) iwe, event_len);
 485:include/net/iw_handler.h **** 		stream += event_len;
 146              	.loc 3 485 0
 147 0069 89D7     	movl %edx,%edi
 148              	.L24:
GAS LISTING  			page 18


 149              	.LBE13:
 150              	.LBE12:
  58:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	memcpy(iwe.u.ap_addr.sa_data, network->bssid, ETH_ALEN);
  59:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	start = iwe_stream_add_event(start, stop, &iwe, IW_EV_ADDR_LEN);
  60:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 
  61:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	/* Remaining entries will be displayed in the order we provide them */
  62:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 
  63:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	/* Add the ESSID */
  64:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	iwe.cmd = SIOCGIWESSID;
 151              	.loc 1 64 0
 152 006b 66C78424 	movw $-29925,350(%esp)
 152      5E010000 
 152      1B8B
  65:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	iwe.u.data.flags = 1;
 153              	.loc 1 65 0
 154 0075 66C78424 	movw $1,358(%esp)
 154      66010000 
 154      0100
  66:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	if (network->flags & NETWORK_EMPTY_ESSID) {
 155              	.loc 1 66 0
 156 007f 8B8C24DC 	movl 476(%esp),%ecx
 156      010000
 157 0086 F6819C00 	testb $1,156(%ecx)
 157      000001
 158              	.loc 3 480 0
 159 008d 89FD     	movl %edi,%ebp
 160              	.loc 1 66 0
 161 008f 744D     	je .L51
 162              	.LBB17:
 163              	.LBB18:
 486:include/net/iw_handler.h **** 	}
 487:include/net/iw_handler.h **** 	return stream;
 488:include/net/iw_handler.h **** }
 489:include/net/iw_handler.h **** 
 490:include/net/iw_handler.h **** /*------------------------------------------------------------------*/
 491:include/net/iw_handler.h **** /*
 492:include/net/iw_handler.h ****  * Wrapper to add an short Wireless Event containing a pointer to a
 493:include/net/iw_handler.h ****  * stream of events.
 494:include/net/iw_handler.h ****  */
 495:include/net/iw_handler.h **** static inline char *
 496:include/net/iw_handler.h **** iwe_stream_add_point(char *	stream,		/* Stream of events */
 497:include/net/iw_handler.h **** 		     char *	ends,		/* End of stream */
 498:include/net/iw_handler.h **** 		     struct iw_event *iwe,	/* Payload */
 499:include/net/iw_handler.h **** 		     char *	extra)
 500:include/net/iw_handler.h **** {
 501:include/net/iw_handler.h **** 	int	event_len = IW_EV_POINT_LEN + iwe->u.data.length;
 502:include/net/iw_handler.h **** 	/* Check if it's possible */
 503:include/net/iw_handler.h **** 	if((stream + event_len) < ends) {
 164              	.loc 3 503 0
 165 0091 8D5D15   	leal 21(%ebp),%ebx
 166 0094 3B9C24D8 	cmpl 472(%esp),%ebx
 166      010000
 167              	.LBE18:
 168              	.LBE17:
  67:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		iwe.u.data.length = sizeof("<hidden>");
 169              	.loc 1 67 0
 170 009b 66C78424 	movw $9,356(%esp)
GAS LISTING  			page 19


 170      64010000 
 170      0900
 171              	.LBB19:
 172              	.loc 3 500 0
 173 00a5 BA150000 	movl $.LC8,%edx
 173      00
 174              	.LBB20:
 175              	.loc 3 503 0
 176 00aa 732E     	jae .L52
 504:include/net/iw_handler.h **** 		iwe->len = event_len;
 177              	.loc 3 504 0
 178 00ac 66C78424 	movw $21,348(%esp)
 178      5C010000 
 178      1500
 179              	.LBB21:
 180              	.LBB22:
 253:include/asm/string.h **** 			"rep ; movsl"
 254:include/asm/string.h **** 			: "=&c" (ecx), "=&D" (edi), "=&S" (esi)
 255:include/asm/string.h **** 			: "0" (n/4), "1" (edi),"2" (esi)
 256:include/asm/string.h **** 			: "memory"
 257:include/asm/string.h **** 		);
 258:include/asm/string.h **** 	} else {
 259:include/asm/string.h **** 		/* small block: don't clobber ecx + smaller code */
 260:include/asm/string.h **** 		if (n >= 4*4) __asm__ __volatile__("movsl"
 261:include/asm/string.h **** 			:"=&D"(edi),"=&S"(esi):"0"(edi),"1"(esi):"memory");
 262:include/asm/string.h **** 		if (n >= 3*4) __asm__ __volatile__("movsl"
 181              	.loc 2 262 0
 182 00b6 89C6     	movl %eax,%esi
 183              	
 184 00b8 A5       	movsl
 263:include/asm/string.h **** 			:"=&D"(edi),"=&S"(esi):"0"(edi),"1"(esi):"memory");
 264:include/asm/string.h **** 		if (n >= 2*4) __asm__ __volatile__("movsl"
 185              	.loc 2 264 0
 186 00b9 A5       	movsl
 265:include/asm/string.h **** 			:"=&D"(edi),"=&S"(esi):"0"(edi),"1"(esi):"memory");
 266:include/asm/string.h **** 		if (n >= 1*4) __asm__ __volatile__("movsl"
 187              	.loc 2 266 0
 188 00ba A5       	movsl
 189              	
 190              	.LBE22:
 191              	.LBE21:
 505:include/net/iw_handler.h **** 		memcpy(stream, (char *) iwe, IW_EV_POINT_LEN);
 506:include/net/iw_handler.h **** 		memcpy(stream + IW_EV_POINT_LEN, extra, iwe->u.data.length);
 192              	.loc 3 506 0
 193 00bb 0FB78424 	movzwl 356(%esp),%eax
 193      64010000 
 194              	.LBB23:
 195              	.LBB24:
 196              	.loc 2 207 0
 197 00c3 89C1     	movl %eax,%ecx
 198 00c5 8D7D0C   	leal 12(%ebp),%edi
 199 00c8 C1E902   	shrl $2,%ecx
 200 00cb 89D6     	movl %edx,%esi
 201              	
 202 00cd F3A5     	rep
 203 00cf 89C1     	movl %eax,%ecx
 204 00d1 83E103   	andl $3,%ecx
GAS LISTING  			page 20


 205 00d4 7402     	jz 1f
 206 00d6 F3A4     	rep
 207              	1:
 208              	
 209              	.LBE24:
 210              	.LBE23:
 507:include/net/iw_handler.h **** 		stream += event_len;
 211              	.loc 3 507 0
 212 00d8 89DF     	movl %ebx,%edi
 213              	.L52:
 214              	.LBE20:
 215              	.LBE19:
 216              	.loc 3 500 0
 217 00da 89FD     	movl %edi,%ebp
 218 00dc EB6C     	jmp .L101
 219              	.L51:
 220              	.LBB25:
  68:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		start = iwe_stream_add_point(start, stop, &iwe, "<hidden>");
  69:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	} else {
  70:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		iwe.u.data.length = min(network->ssid_len, (u8) 32);
 221              	.loc 1 70 0
 222 00de 8B9424DC 	movl 476(%esp),%edx
 222      010000
 223 00e5 8A4228   	movb 40(%edx),%al
 224 00e8 3C20     	cmpb $32,%al
 225 00ea B9200000 	movl $32,%ecx
 225      00
 226 00ef 7303     	jae .L103
 227 00f1 0FB6C8   	movzbl %al,%ecx
 228              	.L103:
 229              	.LBE25:
 230              	.LBB26:
 231              	.LBB27:
 232              	.loc 3 501 0
 233 00f4 8D410C   	leal 12(%ecx),%eax
 234              	.LBE27:
 235              	.loc 3 500 0
 236 00f7 8B9C24DC 	movl 476(%esp),%ebx
 236      010000
 237              	.LBB28:
 238              	.loc 3 503 0
 239 00fe 8D2C07   	leal (%edi,%eax),%ebp
 240              	.LBE28:
 241              	.loc 3 500 0
 242 0101 83C307   	addl $7,%ebx
 243              	.LBB29:
 244              	.loc 3 503 0
 245 0104 3BAC24D8 	cmpl 472(%esp),%ebp
 245      010000
 246              	.LBE29:
 247              	.LBE26:
 248              	.loc 1 70 0
 249 010b 66898C24 	movw %cx,356(%esp)
 249      64010000 
 250              	.LBB30:
 251              	.loc 3 500 0
 252 0113 89FA     	movl %edi,%edx
GAS LISTING  			page 21


 253 0115 8DB4245C 	leal 348(%esp),%esi
 253      010000
 254              	.LBB31:
 255              	.loc 3 503 0
 256 011c 732A     	jae .L104
 257              	.loc 3 504 0
 258 011e 66898424 	movw %ax,348(%esp)
 258      5C010000 
 259              	.LBB32:
 260              	.LBB33:
 261              	.loc 2 262 0
 262              	
 263 0126 A5       	movsl
 264              	.loc 2 264 0
 265 0127 A5       	movsl
 266              	.loc 2 266 0
 267 0128 A5       	movsl
 268              	
 269              	.LBE33:
 270              	.LBE32:
 271              	.loc 3 506 0
 272 0129 0FB78424 	movzwl 356(%esp),%eax
 272      64010000 
 273              	.LBB34:
 274              	.LBB35:
 275              	.loc 2 207 0
 276 0131 89C1     	movl %eax,%ecx
 277 0133 8D7A0C   	leal 12(%edx),%edi
 278 0136 C1E902   	shrl $2,%ecx
 279 0139 89DE     	movl %ebx,%esi
 280              	
 281 013b F3A5     	rep
 282 013d 89C1     	movl %eax,%ecx
 283 013f 83E103   	andl $3,%ecx
 284 0142 7402     	jz 1f
 285 0144 F3A4     	rep
 286              	1:
 287              	
 288              	.LBE35:
 289              	.LBE34:
 290              	.loc 3 507 0
 291 0146 89EA     	movl %ebp,%edx
 292              	.L104:
 293              	.LBE31:
 294              	.LBE30:
 295              	.loc 3 500 0
 296 0148 89D5     	movl %edx,%ebp
 297              	.L101:
  71:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		start = iwe_stream_add_point(start, stop, &iwe, network->ssid);
  72:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	}
  73:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 
  74:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	/* Add the protocol name */
  75:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	iwe.cmd = SIOCGIWNAME;
 298              	.loc 1 75 0
 299 014a 66C78424 	movw $-29951,350(%esp)
 299      5E010000 
 299      018B
GAS LISTING  			page 22


  76:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	snprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11%s",
 300              	.loc 1 76 0
 301 0154 8B8C24DC 	movl 476(%esp),%ecx
 301      010000
 302 015b 0FB68198 	movzbl 152(%ecx),%eax
 302      000000
 303 0162 FF348500 	pushl ieee80211_modes(,%eax,4)
 303      000000
 304              	.LCFI5:
 305 0169 681E0000 	pushl $.LC9
 305      00
 306              	.LCFI6:
 307 016e 6A10     	pushl $16
 308              	.LCFI7:
 309 0170 8D84246C 	leal 364(%esp),%eax
 309      010000
 310 0177 8DB42468 	leal 360(%esp),%esi
 310      010000
 311 017e 50       	pushl %eax
 312              	.LCFI8:
 313 017f E8FCFFFF 	call snprintf
 313      FF
 314              	.loc 3 480 0
 315 0184 83C410   	addl $16,%esp
 316              	.LCFI9:
 317              	.LBB36:
 318              	.LBB37:
 319              	.loc 3 482 0
 320 0187 8D4514   	leal 20(%ebp),%eax
 321 018a 3B8424D8 	cmpl 472(%esp),%eax
 321      010000
 322              	.LBE37:
 323              	.loc 3 480 0
 324 0191 89EF     	movl %ebp,%edi
 325              	.LBB38:
 326              	.loc 3 482 0
 327 0193 7313     	jae .L153
 328              	.loc 3 483 0
 329 0195 66C78424 	movw $20,348(%esp)
 329      5C010000 
 329      1400
 330              	.LBB39:
 331              	.LBB40:
 332              	.LBB41:
 333              	.loc 2 252 0
 334 019f B9050000 	movl $5,%ecx
 334      00
 335              	
 336 01a4 F3A5     	rep
 337              	
 338              	.LBE41:
 339              	.LBE40:
 340              	.LBE39:
 341              	.loc 3 485 0
 342 01a6 89C7     	movl %eax,%edi
 343              	.L153:
 344              	.LBE38:
GAS LISTING  			page 23


 345              	.LBE36:
  77:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		 ieee80211_modes[network->mode]);
  78:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	start = iwe_stream_add_event(start, stop, &iwe, IW_EV_CHAR_LEN);
  79:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 
  80:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	/* Add mode */
  81:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	iwe.cmd = SIOCGIWMODE;
 346              	.loc 1 81 0
 347 01a8 66C78424 	movw $-29945,350(%esp)
 347      5E010000 
 347      078B
  82:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	if (network->capability & (WLAN_CAPABILITY_ESS | WLAN_CAPABILITY_IBSS)) {
 348              	.loc 1 82 0
 349 01b2 8B9424DC 	movl 476(%esp),%edx
 349      010000
 350 01b9 0FB74274 	movzwl 116(%edx),%eax
 351 01bd A803     	testb $3,%al
 352              	.loc 3 480 0
 353 01bf 89FD     	movl %edi,%ebp
 354              	.loc 1 82 0
 355 01c1 7443     	je .L180
  83:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		if (network->capability & WLAN_CAPABILITY_ESS)
 356              	.loc 1 83 0
 357 01c3 83E001   	andl $1,%eax
  84:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 			iwe.u.mode = IW_MODE_MASTER;
 358              	.loc 1 84 0
 359 01c6 83F801   	cmpl $1,%eax
 360 01c9 19C0     	sbbl %eax,%eax
 361 01cb 83E0FE   	andl $-2,%eax
 362              	.LBB42:
 363              	.LBB43:
 364              	.loc 3 482 0
 365 01ce 8D5508   	leal 8(%ebp),%edx
 366              	.LBE43:
 367              	.LBE42:
 368              	.loc 1 84 0
 369 01d1 83C003   	addl $3,%eax
 370              	.LBB44:
 371              	.LBB45:
 372              	.loc 3 482 0
 373 01d4 3B9424D8 	cmpl 472(%esp),%edx
 373      010000
 374              	.LBE45:
 375              	.LBE44:
 376              	.loc 1 84 0
 377 01db 89842460 	movl %eax,352(%esp)
 377      010000
 378              	.LBB46:
 379              	.LBB47:
 380              	.loc 3 482 0
 381 01e2 7320     	jae .L183
 382              	.loc 3 483 0
 383 01e4 66C78424 	movw $8,348(%esp)
 383      5C010000 
 383      0800
 384              	.LBB48:
 385              	.LBB49:
 386              	.loc 2 242 0
GAS LISTING  			page 24


 387 01ee 8B84245C 	movl 348(%esp),%eax
 387      010000
 388 01f5 894500   	movl %eax,(%ebp)
 389              	.loc 2 243 0
 390 01f8 8B842460 	movl 352(%esp),%eax
 390      010000
 391 01ff 894504   	movl %eax,4(%ebp)
 392              	.LBE49:
 393              	.LBE48:
 394              	.loc 3 485 0
 395 0202 89D7     	movl %edx,%edi
 396              	.L183:
 397              	.LBE47:
 398              	.LBE46:
 399              	.loc 3 480 0
 400 0204 89FD     	movl %edi,%ebp
 401              	.L180:
  85:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		else
  86:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 			iwe.u.mode = IW_MODE_ADHOC;
  87:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 
  88:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		start = iwe_stream_add_event(start, stop, &iwe, IW_EV_UINT_LEN);
  89:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	}
  90:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 
  91:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	/* Add frequency/channel */
  92:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	iwe.cmd = SIOCGIWFREQ;
 402              	.loc 1 92 0
 403 0206 66C78424 	movw $-29947,350(%esp)
 403      5E010000 
 403      058B
  93:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** /*	iwe.u.freq.m = ieee80211_frequency(network->channel, network->mode);
  94:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	iwe.u.freq.e = 3; */
  95:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	iwe.u.freq.m = network->channel;
 404              	.loc 1 95 0
 405 0210 8B8C24DC 	movl 476(%esp),%ecx
 405      010000
 406 0217 0FB64106 	movzbl 6(%ecx),%eax
 407 021b 89842460 	movl %eax,352(%esp)
 407      010000
 408              	.LBB50:
 409              	.LBB51:
 410              	.loc 3 482 0
 411 0222 8D450C   	leal 12(%ebp),%eax
 412 0225 3B8424D8 	cmpl 472(%esp),%eax
 412      010000
 413              	.LBE51:
 414              	.LBE50:
  96:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	iwe.u.freq.e = 0;
 415              	.loc 1 96 0
 416 022c 66C78424 	movw $0,356(%esp)
 416      64010000 
 416      0000
  97:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	iwe.u.freq.i = 0;
 417              	.loc 1 97 0
 418 0236 C6842466 	movb $0,358(%esp)
 418      01000000 
 419              	.LBB52:
 420              	.loc 3 480 0
GAS LISTING  			page 25


 421 023e 89EF     	movl %ebp,%edi
 422 0240 8DB4245C 	leal 348(%esp),%esi
 422      010000
 423              	.LBB53:
 424              	.loc 3 482 0
 425 0247 730F     	jae .L210
 426              	.loc 3 483 0
 427 0249 66C78424 	movw $12,348(%esp)
 427      5C010000 
 427      0C00
 428              	.LBB54:
 429              	.LBB55:
 430              	.loc 2 262 0
 431              	
 432 0253 A5       	movsl
 433              	.loc 2 264 0
 434 0254 A5       	movsl
 435              	.loc 2 266 0
 436 0255 A5       	movsl
 437              	
 438              	.LBE55:
 439              	.LBE54:
 440              	.loc 3 485 0
 441 0256 89C7     	movl %eax,%edi
 442              	.L210:
 443              	.LBE53:
 444              	.LBE52:
  98:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	start = iwe_stream_add_event(start, stop, &iwe, IW_EV_FREQ_LEN);
  99:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 
 100:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	/* Add encryption capability */
 101:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	iwe.cmd = SIOCGIWENCODE;
 445              	.loc 1 101 0
 446 0258 66C78424 	movw $-29909,350(%esp)
 446      5E010000 
 446      2B8B
 102:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	if (network->capability & WLAN_CAPABILITY_PRIVACY)
 447              	.loc 1 102 0
 448 0262 8B8424DC 	movl 476(%esp),%eax
 448      010000
 449 0269 F6407410 	testb $16,116(%eax)
 450 026d 740C     	je .L237
 103:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		iwe.u.data.flags = IW_ENCODE_ENABLED | IW_ENCODE_NOKEY;
 451              	.loc 1 103 0
 452 026f 66C78424 	movw $2048,358(%esp)
 452      66010000 
 452      0008
 453 0279 EB0A     	jmp .L238
 454              	.L237:
 104:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	else
 105:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		iwe.u.data.flags = IW_ENCODE_DISABLED;
 455              	.loc 1 105 0
 456 027b 66C78424 	movw $-32768,358(%esp)
 456      66010000 
 456      0080
 457              	.L238:
 458              	.LBB56:
 459              	.loc 3 500 0
GAS LISTING  			page 26


 460 0285 8B9C24DC 	movl 476(%esp),%ebx
 460      010000
 461              	.LBB57:
 462              	.loc 3 503 0
 463 028c 8D570C   	leal 12(%edi),%edx
 464              	.LBE57:
 465              	.loc 3 500 0
 466 028f 83C307   	addl $7,%ebx
 467              	.LBB58:
 468              	.loc 3 503 0
 469 0292 3B9424D8 	cmpl 472(%esp),%edx
 469      010000
 470              	.LBE58:
 471              	.LBE56:
 106:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	iwe.u.data.length = 0;
 472              	.loc 1 106 0
 473 0299 66C78424 	movw $0,356(%esp)
 473      64010000 
 473      0000
 474              	.LBB59:
 475              	.loc 3 500 0
 476 02a3 8DB4245C 	leal 348(%esp),%esi
 476      010000
 477              	.LBB60:
 478              	.loc 3 503 0
 479 02aa 732B     	jae .L239
 480              	.loc 3 504 0
 481 02ac 66C78424 	movw $12,348(%esp)
 481      5C010000 
 481      0C00
 482              	.LBB61:
 483              	.LBB62:
 484              	.loc 2 262 0
 485              	
 486 02b6 A5       	movsl
 487              	.loc 2 264 0
 488 02b7 A5       	movsl
 489              	.loc 2 266 0
 490 02b8 A5       	movsl
 491              	
 492              	.LBE62:
 493              	.LBE61:
 494              	.loc 3 506 0
 495 02b9 0FB78424 	movzwl 356(%esp),%eax
 495      64010000 
 496              	.LBB63:
 497              	.LBB64:
 498              	.loc 2 207 0
 499 02c1 89C1     	movl %eax,%ecx
 500 02c3 C1E902   	shrl $2,%ecx
 501 02c6 89D7     	movl %edx,%edi
 502 02c8 89DE     	movl %ebx,%esi
 503              	
 504 02ca F3A5     	rep
 505 02cc 89C1     	movl %eax,%ecx
 506 02ce 83E103   	andl $3,%ecx
 507 02d1 7402     	jz 1f
GAS LISTING  			page 27


 508 02d3 F3A4     	rep
 509              	1:
 510              	
 511              	.LBE64:
 512              	.LBE63:
 513              	.loc 3 507 0
 514 02d5 89D7     	movl %edx,%edi
 515              	.L239:
 516              	.LBE60:
 517              	.LBE59:
 107:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	start = iwe_stream_add_point(start, stop, &iwe, network->ssid);
 108:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 
 109:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	/* Add basic and extended rates */
 110:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	max_rate = 0;
 111:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	p = custom;
 518              	.loc 1 111 0
 519 02d7 8D94247C 	leal 380(%esp),%edx
 519      010000
 520              	.loc 1 110 0
 521 02de C6442413 	movb $0,19(%esp)
 521      00
 522              	.loc 1 111 0
 523 02e3 89542418 	movl %edx,24(%esp)
 112:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	p += snprintf(p, MAX_CUSTOM_LEN - (p - custom), " Rates (Mb/s): ");
 524              	.loc 1 112 0
 525 02e7 682C0000 	pushl $.LC10
 525      00
 526              	.LCFI10:
 527 02ec 6A40     	pushl $64
 528              	.LCFI11:
 529 02ee 52       	pushl %edx
 530              	.LCFI12:
 531 02ef E8FCFFFF 	call snprintf
 531      FF
 532 02f4 01442424 	addl %eax,36(%esp)
 113:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	for (i = 0, j = 0; i < network->rates_len;) {
 533              	.loc 1 113 0
 534 02f8 C7442420 	movl $0,32(%esp)
 534      00000000 
 535 0300 83C40C   	addl $12,%esp
 536              	.LCFI13:
 537 0303 8B8C24DC 	movl 476(%esp),%ecx
 537      010000
 538 030a 31F6     	xorl %esi,%esi
 539 030c 80B98200 	cmpb $0,130(%ecx)
 539      000000
 540 0313 0F84B000 	je .L708
 540      0000
 541 0319 89CD     	movl %ecx,%ebp
 542 031b 81C18300 	addl $131,%ecx
 542      0000
 543 0321 83C576   	addl $118,%ebp
 544 0324 894C2404 	movl %ecx,4(%esp)
 545              	.L295:
 114:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		if (j < network->rates_ex_len &&
 546              	.loc 1 114 0
 547 0328 8B9424DC 	movl 476(%esp),%edx
GAS LISTING  			page 28


 547      010000
 548 032f 0FB68293 	movzbl 147(%edx),%eax
 548      000000
 549 0336 39442414 	cmpl %eax,20(%esp)
 550 033a 7D25     	jge .L290
 551 033c 8B442404 	movl 4(%esp),%eax
 552 0340 8A08     	movb (%eax),%cl
 553 0342 89CA     	movl %ecx,%edx
 554 0344 0FB64500 	movzbl (%ebp),%eax
 555 0348 83E27F   	andl $127,%edx
 556 034b 83E07F   	andl $127,%eax
 557 034e 39C2     	cmpl %eax,%edx
 558 0350 7D0F     	jge .L290
 115:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		    ((network->rates_ex[j] & 0x7F) <
 116:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		     (network->rates[i] & 0x7F)))
 117:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 			rate = network->rates_ex[j++] & 0x7F;
 559              	.loc 1 117 0
 560 0352 88CB     	movb %cl,%bl
 561 0354 83E37F   	andl $127,%ebx
 562 0357 FF442414 	incl 20(%esp)
 563 035b FF442404 	incl 4(%esp)
 564 035f EB08     	jmp .L291
 565              	.L290:
 118:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		else
 119:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 			rate = network->rates[i++] & 0x7F;
 566              	.loc 1 119 0
 567 0361 8A5D00   	movb (%ebp),%bl
 568 0364 83E37F   	andl $127,%ebx
 569 0367 46       	incl %esi
 570 0368 45       	incl %ebp
 571              	.L291:
 120:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		if (rate > max_rate)
 572              	.loc 1 120 0
 573 0369 3A5C2413 	cmpb 19(%esp),%bl
 574 036d 7604     	jbe .L292
 121:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 			max_rate = rate;
 575              	.loc 1 121 0
 576 036f 885C2413 	movb %bl,19(%esp)
 577              	.L292:
 122:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		p += snprintf(p, MAX_CUSTOM_LEN - (p - custom),
 578              	.loc 1 122 0
 579 0373 F6C301   	testb $1,%bl
 580 0376 B83C0000 	movl $.LC11,%eax
 580      00
 581 037b 7505     	jne .L294
 582 037d B83F0000 	movl $.LC12,%eax
 582      00
 583              	.L294:
 584 0382 D0EB     	shrb %bl
 585 0384 50       	pushl %eax
 586              	.LCFI14:
 587 0385 0FB6C3   	movzbl %bl,%eax
 588 0388 50       	pushl %eax
 589              	.LCFI15:
 590 0389 68400000 	pushl $.LC13
 590      00
 591              	.LCFI16:
GAS LISTING  			page 29


 592 038e 8D842488 	leal 392(%esp),%eax
 592      010000
 593 0395 8B542424 	movl 36(%esp),%edx
 594 0399 29C2     	subl %eax,%edx
 595 039b B8400000 	movl $64,%eax
 595      00
 596 03a0 29D0     	subl %edx,%eax
 597 03a2 50       	pushl %eax
 598              	.LCFI17:
 599 03a3 FF742428 	pushl 40(%esp)
 600              	.LCFI18:
 601 03a7 E8FCFFFF 	call snprintf
 601      FF
 602 03ac 0144242C 	addl %eax,44(%esp)
 603              	.loc 1 113 0
 604 03b0 83C414   	addl $20,%esp
 605              	.LCFI19:
 606 03b3 8B9424DC 	movl 476(%esp),%edx
 606      010000
 607 03ba 0FB68282 	movzbl 130(%edx),%eax
 607      000000
 608 03c1 39C6     	cmpl %eax,%esi
 609 03c3 0F8C5FFF 	jl .L295
 609      FFFF
 610              	.L708:
 123:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 			      "%d%s ", rate >> 1, (rate & 1) ? ".5" : "");
 124:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	}
 125:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	for (; j < network->rates_ex_len; j++) {
 611              	.loc 1 125 0
 612 03c9 8B8C24DC 	movl 476(%esp),%ecx
 612      010000
 613 03d0 0FB68193 	movzbl 147(%ecx),%eax
 613      000000
 614 03d7 39442414 	cmpl %eax,20(%esp)
 615 03db 7D67     	jge .L710
 126:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		rate = network->rates_ex[j] & 0x7F;
 616              	.loc 1 126 0
 617 03dd 8B442414 	movl 20(%esp),%eax
 618 03e1 8B9424DC 	movl 476(%esp),%edx
 618      010000
 619 03e8 8A9C1083 	movb 131(%eax,%edx),%bl
 619      000000
 620 03ef 83E37F   	andl $127,%ebx
 127:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		p += snprintf(p, MAX_CUSTOM_LEN - (p - custom),
 621              	.loc 1 127 0
 622 03f2 F6C301   	testb $1,%bl
 623 03f5 B83C0000 	movl $.LC11,%eax
 623      00
 624 03fa 7505     	jne .L300
 625 03fc B83F0000 	movl $.LC12,%eax
 625      00
 626              	.L300:
 627 0401 50       	pushl %eax
 628              	.LCFI20:
 629 0402 88D8     	movb %bl,%al
 630 0404 D0E8     	shrb %al
 631 0406 0FB6C0   	movzbl %al,%eax
GAS LISTING  			page 30


 632 0409 50       	pushl %eax
 633              	.LCFI21:
 634 040a 68400000 	pushl $.LC13
 634      00
 635              	.LCFI22:
 636 040f 8D842488 	leal 392(%esp),%eax
 636      010000
 637 0416 8B542424 	movl 36(%esp),%edx
 638 041a 29C2     	subl %eax,%edx
 639 041c B8400000 	movl $64,%eax
 639      00
 640 0421 29D0     	subl %edx,%eax
 641 0423 50       	pushl %eax
 642              	.LCFI23:
 643 0424 FF742428 	pushl 40(%esp)
 644              	.LCFI24:
 645 0428 E8FCFFFF 	call snprintf
 645      FF
 646 042d 0144242C 	addl %eax,44(%esp)
 128:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 			      "%d%s ", rate >> 1, (rate & 1) ? ".5" : "");
 129:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		if (rate > max_rate)
 647              	.loc 1 129 0
 648 0431 83C414   	addl $20,%esp
 649              	.LCFI25:
 650 0434 3A5C2413 	cmpb 19(%esp),%bl
 651 0438 7604     	jbe .L298
 130:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 			max_rate = rate;
 652              	.loc 1 130 0
 653 043a 885C2413 	movb %bl,19(%esp)
 654              	.L298:
 655              	.loc 1 125 0
 656 043e FF442414 	incl 20(%esp)
 657 0442 EB85     	jmp .L708
 658              	.L710:
 131:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	}
 132:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 
 133:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	iwe.cmd = SIOCGIWRATE;
 134:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	iwe.u.bitrate.fixed = iwe.u.bitrate.disabled = 0;
 135:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	iwe.u.bitrate.value = max_rate * 500000;
 659              	.loc 1 135 0
 660 0444 0FB64424 	movzbl 19(%esp),%eax
 660      13
 661 0449 69C020A1 	imull $500000,%eax,%eax
 661      0700
 662 044f 89842460 	movl %eax,352(%esp)
 662      010000
 663              	.LBB65:
 664              	.LBB66:
 665              	.loc 3 482 0
 666 0456 8D470C   	leal 12(%edi),%eax
 667 0459 3B8424D8 	cmpl 472(%esp),%eax
 667      010000
 668              	.LBE66:
 669              	.LBE65:
 670              	.loc 1 133 0
 671 0460 66C78424 	movw $-29919,350(%esp)
 671      5E010000 
GAS LISTING  			page 31


 671      218B
 672              	.loc 1 134 0
 673 046a C6842465 	movb $0,357(%esp)
 673      01000000 
 674 0472 C6842464 	movb $0,356(%esp)
 674      01000000 
 675              	.LBB67:
 676              	.loc 3 480 0
 677 047a 8D94245C 	leal 348(%esp),%edx
 677      010000
 678              	.LBB68:
 679              	.loc 3 482 0
 680 0481 7311     	jae .L303
 681              	.loc 3 483 0
 682 0483 66C78424 	movw $12,348(%esp)
 682      5C010000 
 682      0C00
 683              	.LBB69:
 684              	.LBB70:
 685              	.loc 2 262 0
 686 048d 89D6     	movl %edx,%esi
 687              	
 688 048f A5       	movsl
 689              	.loc 2 264 0
 690 0490 A5       	movsl
 691              	.loc 2 266 0
 692 0491 A5       	movsl
 693              	
 694              	.LBE70:
 695              	.LBE69:
 696              	.loc 3 485 0
 697 0492 89C7     	movl %eax,%edi
 698              	.L303:
 699              	.LBE68:
 700              	.LBE67:
 136:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	start = iwe_stream_add_event(start, stop, &iwe, IW_EV_PARAM_LEN);
 137:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 
 138:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	iwe.cmd = IWEVCUSTOM;
 139:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	iwe.u.data.length = p - custom;
 701              	.loc 1 139 0
 702 0494 8D9C247C 	leal 380(%esp),%ebx
 702      010000
 703 049b 8B442418 	movl 24(%esp),%eax
 704 049f 6629D8   	subw %bx,%ax
 140:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	if (iwe.u.data.length)
 705              	.loc 1 140 0
 706 04a2 6685C0   	testw %ax,%ax
 707              	.loc 3 480 0
 708 04a5 89FD     	movl %edi,%ebp
 709              	.loc 1 138 0
 710 04a7 66C78424 	movw $-29694,350(%esp)
 710      5E010000 
 710      028C
 711              	.loc 1 139 0
 712 04b1 66898424 	movw %ax,356(%esp)
 712      64010000 
 713              	.loc 1 140 0
GAS LISTING  			page 32


 714 04b9 744B     	je .L330
 715              	.LBB71:
 716              	.LBB72:
 717              	.loc 3 501 0
 718 04bb 0FB7C0   	movzwl %ax,%eax
 719 04be 83C00C   	addl $12,%eax
 720              	.loc 3 503 0
 721 04c1 8D4C0500 	leal (%ebp,%eax),%ecx
 722 04c5 894C240C 	movl %ecx,12(%esp)
 723 04c9 8B8C24D8 	movl 472(%esp),%ecx
 723      010000
 724 04d0 394C240C 	cmpl %ecx,12(%esp)
 725 04d4 732E     	jae .L331
 726              	.loc 3 504 0
 727 04d6 66898424 	movw %ax,348(%esp)
 727      5C010000 
 728              	.LBB73:
 729              	.LBB74:
 730              	.loc 2 262 0
 731 04de 89D6     	movl %edx,%esi
 732              	
 733 04e0 A5       	movsl
 734              	.loc 2 264 0
 735 04e1 A5       	movsl
 736              	.loc 2 266 0
 737 04e2 A5       	movsl
 738              	
 739              	.LBE74:
 740              	.LBE73:
 741              	.loc 3 506 0
 742 04e3 0FB78424 	movzwl 356(%esp),%eax
 742      64010000 
 743              	.LBB75:
 744              	.LBB76:
 745              	.loc 2 207 0
 746 04eb 89C1     	movl %eax,%ecx
 747 04ed 8D7D0C   	leal 12(%ebp),%edi
 748 04f0 C1E902   	shrl $2,%ecx
 749 04f3 89DE     	movl %ebx,%esi
 750              	
 751 04f5 F3A5     	rep
 752 04f7 89C1     	movl %eax,%ecx
 753 04f9 83E103   	andl $3,%ecx
 754 04fc 7402     	jz 1f
 755 04fe F3A4     	rep
 756              	1:
 757              	
 758              	.LBE76:
 759              	.LBE75:
 760              	.loc 3 507 0
 761 0500 8B7C240C 	movl 12(%esp),%edi
 762              	.L331:
 763              	.LBE72:
 764              	.LBE71:
 765              	.loc 3 500 0
 766 0504 89FD     	movl %edi,%ebp
 767              	.L330:
GAS LISTING  			page 33


 141:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		start = iwe_stream_add_point(start, stop, &iwe, custom);
 142:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 
 143:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	/* Add quality statistics */
 144:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	iwe.cmd = IWEVQUAL;
 768              	.loc 1 144 0
 769 0506 66C78424 	movw $-29695,350(%esp)
 769      5E010000 
 769      018C
 145:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	iwe.u.qual.updated = IW_QUAL_QUAL_UPDATED | IW_QUAL_LEVEL_UPDATED |
 770              	.loc 1 145 0
 771 0510 C6842463 	movb $7,355(%esp)
 771      01000007 
 146:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	    IW_QUAL_NOISE_UPDATED;
 147:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 
 148:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	if (!(network->stats.mask & IEEE80211_STATMASK_RSSI)) {
 772              	.loc 1 148 0
 773 0518 8B8424DC 	movl 476(%esp),%eax
 773      010000
 774 051f 0FB67864 	movzbl 100(%eax),%edi
 775 0523 F7C70200 	testl $2,%edi
 775      0000
 776 0529 750A     	jne .L380
 149:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		iwe.u.qual.updated |= IW_QUAL_QUAL_INVALID |
 777              	.loc 1 149 0
 778 052b C6842463 	movb $55,355(%esp)
 778      01000037 
 779 0533 EB74     	jmp .L717
 780              	.L380:
 150:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		    IW_QUAL_LEVEL_INVALID;
 151:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		iwe.u.qual.qual = 0;
 152:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	} else {
 153:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		if (ieee->perfect_rssi == ieee->worst_rssi)
 781              	.loc 1 153 0
 782 0535 8B9424D0 	movl 464(%esp),%edx
 782      010000
 783 053c 8B8A6C07 	movl 1900(%edx),%ecx
 783      0000
 784 0542 8B827007 	movl 1904(%edx),%eax
 784      0000
 785 0548 39C1     	cmpl %eax,%ecx
 786 054a 750A     	jne .L382
 154:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 			iwe.u.qual.qual = 100;
 787              	.loc 1 154 0
 788 054c C6842460 	movb $100,352(%esp)
 788      01000064 
 789 0554 EB3A     	jmp .L383
 790              	.L382:
 155:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		else
 156:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 			iwe.u.qual.qual =
 791              	.loc 1 156 0
 792 0556 89CA     	movl %ecx,%edx
 793 0558 29C2     	subl %eax,%edx
 794 055a 89D6     	movl %edx,%esi
 795 055c 0FAFF2   	imull %edx,%esi
 796 055f 89D0     	movl %edx,%eax
 797 0561 8B9424DC 	movl 476(%esp),%edx
 797      010000
GAS LISTING  			page 34


 798 0568 0FBE525C 	movsbl 92(%edx),%edx
 799 056c 891424   	movl %edx,(%esp)
 800 056f 89CA     	movl %ecx,%edx
 801 0571 2B1424   	subl (%esp),%edx
 802 0574 6BCA3E   	imull $62,%edx,%ecx
 803 0577 6BC00F   	imull $15,%eax,%eax
 804 057a 01C8     	addl %ecx,%eax
 805 057c 0FAFD0   	imull %eax,%edx
 806 057f 6BDE64   	imull $100,%esi,%ebx
 807 0582 29D3     	subl %edx,%ebx
 808 0584 89D8     	movl %ebx,%eax
 809 0586 99       	cltd
 810 0587 F7FE     	idivl %esi
 811 0589 88842460 	movb %al,352(%esp)
 811      010000
 812              	.L383:
 157:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 			    (100 *
 158:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 			     (ieee->perfect_rssi - ieee->worst_rssi) *
 159:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 			     (ieee->perfect_rssi - ieee->worst_rssi) -
 160:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 			     (ieee->perfect_rssi - network->stats.rssi) *
 161:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 			     (15 * (ieee->perfect_rssi - ieee->worst_rssi) +
 162:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 			      62 * (ieee->perfect_rssi -
 163:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 				    network->stats.rssi))) /
 164:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 			    ((ieee->perfect_rssi -
 165:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 			      ieee->worst_rssi) * (ieee->perfect_rssi -
 166:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 						   ieee->worst_rssi));
 167:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		if (iwe.u.qual.qual > 100)
 813              	.loc 1 167 0
 814 0590 8A842460 	movb 352(%esp),%al
 814      010000
 815 0597 3C64     	cmpb $100,%al
 816 0599 760A     	jbe .L384
 168:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 			iwe.u.qual.qual = 100;
 817              	.loc 1 168 0
 818 059b C6842460 	movb $100,352(%esp)
 818      01000064 
 819 05a3 EB0C     	jmp .L381
 820              	.L384:
 169:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		else if (iwe.u.qual.qual < 1)
 821              	.loc 1 169 0
 822 05a5 84C0     	testb %al,%al
 823 05a7 7508     	jne .L381
 824              	.L717:
 170:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 			iwe.u.qual.qual = 0;
 825              	.loc 1 170 0
 826 05a9 C6842460 	movb $0,352(%esp)
 826      01000000 
 827              	.L381:
 171:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	}
 172:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 
 173:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	if (!(network->stats.mask & IEEE80211_STATMASK_NOISE)) {
 828              	.loc 1 173 0
 829 05b1 F7C70400 	testl $4,%edi
 829      0000
 830 05b7 7512     	jne .L387
 174:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		iwe.u.qual.updated |= IW_QUAL_NOISE_INVALID;
 831              	.loc 1 174 0
GAS LISTING  			page 35


 832 05b9 808C2463 	orb $64,355(%esp)
 832      01000040 
 175:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		iwe.u.qual.noise = 0;
 833              	.loc 1 175 0
 834 05c1 C6842462 	movb $0,354(%esp)
 834      01000000 
 835 05c9 EB11     	jmp .L388
 836              	.L387:
 176:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	} else {
 177:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		iwe.u.qual.noise = network->stats.noise;
 837              	.loc 1 177 0
 838 05cb 8B9424DC 	movl 476(%esp),%edx
 838      010000
 839 05d2 8A425E   	movb 94(%edx),%al
 840 05d5 88842462 	movb %al,354(%esp)
 840      010000
 841              	.L388:
 178:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	}
 179:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 
 180:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	if (!(network->stats.mask & IEEE80211_STATMASK_SIGNAL)) {
 842              	.loc 1 180 0
 843 05dc 83E701   	andl $1,%edi
 844 05df 7512     	jne .L389
 181:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		iwe.u.qual.updated |= IW_QUAL_LEVEL_INVALID;
 845              	.loc 1 181 0
 846 05e1 808C2463 	orb $32,355(%esp)
 846      01000020 
 182:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		iwe.u.qual.level = 0;
 847              	.loc 1 182 0
 848 05e9 C6842461 	movb $0,353(%esp)
 848      01000000 
 849 05f1 EB11     	jmp .L390
 850              	.L389:
 183:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	} else {
 184:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		iwe.u.qual.level = network->stats.signal;
 851              	.loc 1 184 0
 852 05f3 8B8C24DC 	movl 476(%esp),%ecx
 852      010000
 853 05fa 8A415D   	movb 93(%ecx),%al
 854 05fd 88842461 	movb %al,353(%esp)
 854      010000
 855              	.L390:
 856              	.LBB77:
 857              	.LBB78:
 858              	.loc 3 482 0
 859 0604 8D5508   	leal 8(%ebp),%edx
 860 0607 3B9424D8 	cmpl 472(%esp),%edx
 860      010000
 861              	.LBE78:
 862              	.loc 3 480 0
 863 060e 896C2408 	movl %ebp,8(%esp)
 864 0612 8DBC245C 	leal 348(%esp),%edi
 864      010000
 865              	.LBB79:
 866              	.loc 3 482 0
 867 0619 7322     	jae .L391
 868              	.loc 3 483 0
GAS LISTING  			page 36


 869 061b 66C78424 	movw $8,348(%esp)
 869      5C010000 
 869      0800
 870              	.LBB80:
 871              	.LBB81:
 872              	.loc 2 242 0
 873 0625 8B84245C 	movl 348(%esp),%eax
 873      010000
 874 062c 894500   	movl %eax,(%ebp)
 875              	.loc 2 243 0
 876 062f 8B842460 	movl 352(%esp),%eax
 876      010000
 877 0636 894504   	movl %eax,4(%ebp)
 878              	.LBE81:
 879              	.LBE80:
 880              	.loc 3 485 0
 881 0639 89542408 	movl %edx,8(%esp)
 882              	.L391:
 883              	.LBE79:
 884              	.LBE77:
 885              	.loc 3 480 0
 886 063d 8B6C2408 	movl 8(%esp),%ebp
 185:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	}
 186:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 
 187:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	start = iwe_stream_add_event(start, stop, &iwe, IW_EV_QUAL_LEN);
 188:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 
 189:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	iwe.cmd = IWEVCUSTOM;
 887              	.loc 1 189 0
 888 0641 66C78424 	movw $-29694,350(%esp)
 888      5E010000 
 888      028C
 190:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	p = custom;
 191:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 
 192:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	iwe.u.data.length = p - custom;
 889              	.loc 1 192 0
 890 064b 66C78424 	movw $0,356(%esp)
 890      64010000 
 890      0000
 891              	.LBB82:
 267:include/asm/string.h **** 			:"=&D"(edi),"=&S"(esi):"0"(edi),"1"(esi):"memory");
 268:include/asm/string.h **** 	}
 269:include/asm/string.h **** 	switch (n % 4) {
 270:include/asm/string.h **** 		/* tail */
 271:include/asm/string.h **** 		case 0: return to;
 272:include/asm/string.h **** 		case 1: __asm__ __volatile__("movsb"
 273:include/asm/string.h **** 			:"=&D"(edi),"=&S"(esi):"0"(edi),"1"(esi):"memory");
 274:include/asm/string.h **** 			return to;
 275:include/asm/string.h **** 		case 2: __asm__ __volatile__("movsw"
 276:include/asm/string.h **** 			:"=&D"(edi),"=&S"(esi):"0"(edi),"1"(esi):"memory");
 277:include/asm/string.h **** 			return to;
 278:include/asm/string.h **** 		default: __asm__ __volatile__("movsw\n\tmovsb"
 279:include/asm/string.h **** 			:"=&D"(edi),"=&S"(esi):"0"(edi),"1"(esi):"memory");
 280:include/asm/string.h **** 			return to;
 281:include/asm/string.h **** 	}
 282:include/asm/string.h **** }
 283:include/asm/string.h **** 
 284:include/asm/string.h **** #define __HAVE_ARCH_MEMCPY
GAS LISTING  			page 37


 285:include/asm/string.h **** 
 286:include/asm/string.h **** #ifdef CONFIG_X86_USE_3DNOW
 287:include/asm/string.h **** 
 288:include/asm/string.h **** #include <asm/mmx.h>
 289:include/asm/string.h **** 
 290:include/asm/string.h **** /*
 291:include/asm/string.h ****  *	This CPU favours 3DNow strongly (eg AMD Athlon)
 292:include/asm/string.h ****  */
 293:include/asm/string.h **** 
 294:include/asm/string.h **** static inline void * __constant_memcpy3d(void * to, const void * from, size_t len)
 295:include/asm/string.h **** {
 296:include/asm/string.h **** 	if (len < 512)
 297:include/asm/string.h **** 		return __constant_memcpy(to, from, len);
 298:include/asm/string.h **** 	return _mmx_memcpy(to, from, len);
 299:include/asm/string.h **** }
 300:include/asm/string.h **** 
 301:include/asm/string.h **** static __inline__ void *__memcpy3d(void *to, const void *from, size_t len)
 302:include/asm/string.h **** {
 303:include/asm/string.h **** 	if (len < 512)
 304:include/asm/string.h **** 		return __memcpy(to, from, len);
 305:include/asm/string.h **** 	return _mmx_memcpy(to, from, len);
 306:include/asm/string.h **** }
 307:include/asm/string.h **** 
 308:include/asm/string.h **** #define memcpy(t, f, n) \
 309:include/asm/string.h **** (__builtin_constant_p(n) ? \
 310:include/asm/string.h ****  __constant_memcpy3d((t),(f),(n)) : \
 311:include/asm/string.h ****  __memcpy3d((t),(f),(n)))
 312:include/asm/string.h **** 
 313:include/asm/string.h **** #else
 314:include/asm/string.h **** 
 315:include/asm/string.h **** /*
 316:include/asm/string.h ****  *	No 3D Now!
 317:include/asm/string.h ****  */
 318:include/asm/string.h ****  
 319:include/asm/string.h **** #define memcpy(t, f, n) \
 320:include/asm/string.h **** (__builtin_constant_p(n) ? \
 321:include/asm/string.h ****  __constant_memcpy((t),(f),(n)) : \
 322:include/asm/string.h ****  __memcpy((t),(f),(n)))
 323:include/asm/string.h **** 
 324:include/asm/string.h **** #endif
 325:include/asm/string.h **** 
 326:include/asm/string.h **** #define __HAVE_ARCH_MEMMOVE
 327:include/asm/string.h **** void *memmove(void * dest,const void * src, size_t n);
 328:include/asm/string.h **** 
 329:include/asm/string.h **** #define memcmp __builtin_memcmp
 330:include/asm/string.h **** 
 331:include/asm/string.h **** #define __HAVE_ARCH_MEMCHR
 332:include/asm/string.h **** static inline void * memchr(const void * cs,int c,size_t count)
 333:include/asm/string.h **** {
 334:include/asm/string.h **** int d0;
 335:include/asm/string.h **** register void * __res;
 336:include/asm/string.h **** if (!count)
 337:include/asm/string.h **** 	return NULL;
 338:include/asm/string.h **** __asm__ __volatile__(
 339:include/asm/string.h **** 	"repne\n\t"
 340:include/asm/string.h **** 	"scasb\n\t"
 341:include/asm/string.h **** 	"je 1f\n\t"
GAS LISTING  			page 38


 342:include/asm/string.h **** 	"movl $1,%0\n"
 343:include/asm/string.h **** 	"1:\tdecl %0"
 344:include/asm/string.h **** 	:"=D" (__res), "=&c" (d0)
 345:include/asm/string.h **** 	:"a" (c),"0" (cs),"1" (count)
 346:include/asm/string.h **** 	:"memory");
 347:include/asm/string.h **** return __res;
 348:include/asm/string.h **** }
 349:include/asm/string.h **** 
 350:include/asm/string.h **** static inline void * __memset_generic(void * s, char c,size_t count)
 351:include/asm/string.h **** {
 352:include/asm/string.h **** int d0, d1;
 353:include/asm/string.h **** __asm__ __volatile__(
 354:include/asm/string.h **** 	"rep\n\t"
 355:include/asm/string.h **** 	"stosb"
 356:include/asm/string.h **** 	: "=&c" (d0), "=&D" (d1)
 357:include/asm/string.h **** 	:"a" (c),"1" (s),"0" (count)
 358:include/asm/string.h **** 	:"memory");
 359:include/asm/string.h **** return s;
 360:include/asm/string.h **** }
 361:include/asm/string.h **** 
 362:include/asm/string.h **** /* we might want to write optimized versions of these later */
 363:include/asm/string.h **** #define __constant_count_memset(s,c,count) __memset_generic((s),(c),(count))
 364:include/asm/string.h **** 
 365:include/asm/string.h **** /*
 366:include/asm/string.h ****  * memset(x,0,y) is a reasonably common thing to do, so we want to fill
 367:include/asm/string.h ****  * things 32 bits at a time even when we don't know the size of the
 368:include/asm/string.h ****  * area at compile-time..
 369:include/asm/string.h ****  */
 370:include/asm/string.h **** static inline void * __constant_c_memset(void * s, unsigned long c, size_t count)
 371:include/asm/string.h **** {
 372:include/asm/string.h **** int d0, d1;
 373:include/asm/string.h **** __asm__ __volatile__(
 374:include/asm/string.h **** 	"rep ; stosl\n\t"
 375:include/asm/string.h **** 	"testb $2,%b3\n\t"
 376:include/asm/string.h **** 	"je 1f\n\t"
 377:include/asm/string.h **** 	"stosw\n"
 378:include/asm/string.h **** 	"1:\ttestb $1,%b3\n\t"
 379:include/asm/string.h **** 	"je 2f\n\t"
 380:include/asm/string.h **** 	"stosb\n"
 381:include/asm/string.h **** 	"2:"
 382:include/asm/string.h **** 	:"=&c" (d0), "=&D" (d1)
 383:include/asm/string.h **** 	:"a" (c), "q" (count), "0" (count/4), "1" ((long) s)
 384:include/asm/string.h **** 	:"memory");
 385:include/asm/string.h **** return (s);	
 386:include/asm/string.h **** }
 387:include/asm/string.h **** 
 388:include/asm/string.h **** /* Added by Gertjan van Wingerde to make minix and sysv module work */
 389:include/asm/string.h **** #define __HAVE_ARCH_STRNLEN
 390:include/asm/string.h **** static inline size_t strnlen(const char * s, size_t count)
 391:include/asm/string.h **** {
 392:include/asm/string.h **** int d0;
 393:include/asm/string.h **** register int __res;
 394:include/asm/string.h **** __asm__ __volatile__(
 395:include/asm/string.h **** 	"movl %2,%0\n\t"
 396:include/asm/string.h **** 	"jmp 2f\n"
 397:include/asm/string.h **** 	"1:\tcmpb $0,(%0)\n\t"
 398:include/asm/string.h **** 	"je 3f\n\t"
GAS LISTING  			page 39


 399:include/asm/string.h **** 	"incl %0\n"
 400:include/asm/string.h **** 	"2:\tdecl %1\n\t"
 401:include/asm/string.h **** 	"cmpl $-1,%1\n\t"
 402:include/asm/string.h **** 	"jne 1b\n"
 403:include/asm/string.h **** 	"3:\tsubl %2,%0"
 404:include/asm/string.h **** 	:"=a" (__res), "=&d" (d0)
 405:include/asm/string.h **** 	:"c" (s),"1" (count)
 406:include/asm/string.h **** 	:"memory");
 407:include/asm/string.h **** return __res;
 408:include/asm/string.h **** }
 409:include/asm/string.h **** /* end of additional stuff */
 410:include/asm/string.h **** 
 411:include/asm/string.h **** #define __HAVE_ARCH_STRSTR
 412:include/asm/string.h **** 
 413:include/asm/string.h **** extern char *strstr(const char *cs, const char *ct);
 414:include/asm/string.h **** 
 415:include/asm/string.h **** /*
 416:include/asm/string.h ****  * This looks horribly ugly, but the compiler can optimize it totally,
 417:include/asm/string.h ****  * as we by now know that both pattern and count is constant..
 418:include/asm/string.h ****  */
 419:include/asm/string.h **** static inline void * __constant_c_and_count_memset(void * s, unsigned long pattern, size_t count)
 420:include/asm/string.h **** {
 892              	.loc 2 420 0
 893 0655 31C0     	xorl %eax,%eax
 894              	.LBB83:
 895              	.LBB84:
 421:include/asm/string.h **** 	switch (count) {
 422:include/asm/string.h **** 		case 0:
 423:include/asm/string.h **** 			return s;
 424:include/asm/string.h **** 		case 1:
 425:include/asm/string.h **** 			*(unsigned char *)s = pattern;
 426:include/asm/string.h **** 			return s;
 427:include/asm/string.h **** 		case 2:
 428:include/asm/string.h **** 			*(unsigned short *)s = pattern;
 429:include/asm/string.h **** 			return s;
 430:include/asm/string.h **** 		case 3:
 431:include/asm/string.h **** 			*(unsigned short *)s = pattern;
 432:include/asm/string.h **** 			*(2+(unsigned char *)s) = pattern;
 433:include/asm/string.h **** 			return s;
 434:include/asm/string.h **** 		case 4:
 435:include/asm/string.h **** 			*(unsigned long *)s = pattern;
 436:include/asm/string.h **** 			return s;
 437:include/asm/string.h **** 	}
 438:include/asm/string.h **** #define COMMON(x) \
 439:include/asm/string.h **** __asm__  __volatile__( \
 440:include/asm/string.h **** 	"rep ; stosl" \
 441:include/asm/string.h **** 	x \
 442:include/asm/string.h **** 	: "=&c" (d0), "=&D" (d1) \
 443:include/asm/string.h **** 	: "a" (pattern),"0" (count/4),"1" ((long) s) \
 444:include/asm/string.h **** 	: "memory")
 445:include/asm/string.h **** {
 446:include/asm/string.h **** 	int d0, d1;
 447:include/asm/string.h **** 	switch (count % 4) {
 448:include/asm/string.h **** 		case 0: COMMON(""); return s;
 896              	.loc 2 448 0
 897 0657 B9050000 	movl $5,%ecx
 897      00
GAS LISTING  			page 40


 898              	
 899 065c F3AB     	rep
 900              	
 901              	.LBE84:
 902              	.LBE83:
 903              	.LBE82:
 193:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	if (iwe.u.data.length)
 194:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		start = iwe_stream_add_point(start, stop, &iwe, custom);
 195:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 
 196:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	memset(&iwe, 0, sizeof(iwe));
 197:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	if (network->wpa_ie_len) {
 904              	.loc 1 197 0
 905 065e 8B8424DC 	movl 476(%esp),%eax
 905      010000
 906 0665 83B8F400 	cmpl $0,244(%eax)
 906      000000
 907 066c 0F84C700 	je .L481
 907      0000
 908              	.LBB85:
 198:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** #ifdef IWEVGENIE
 199:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		char buf[MAX_WPA_IE_LEN];
 200:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		memcpy(buf, network->wpa_ie, network->wpa_ie_len);
 201:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		iwe.cmd = IWEVGENIE;
 202:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		iwe.u.data.length = network->wpa_ie_len;
 203:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** #else
 204:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		char buf[MAX_WPA_IE_LEN * 2 + 30];
 205:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 
 206:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		u8 *p = buf;
 909              	.loc 1 206 0
 910 0672 8D9C24BC 	leal 188(%esp),%ebx
 910      000000
 207:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		p += sprintf(p, "wpa_ie=");
 911              	.loc 1 207 0
 912 0679 68460000 	pushl $.LC14
 912      00
 913              	.LCFI26:
 914 067e 53       	pushl %ebx
 915              	.LCFI27:
 916 067f E8FCFFFF 	call sprintf
 916      FF
 917 0684 01C3     	addl %eax,%ebx
 208:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		for (i = 0; i < network->wpa_ie_len; i++) {
 918              	.loc 1 208 0
 919 0686 58       	popl %eax
 920              	.LCFI28:
 921 0687 5A       	popl %edx
 922              	.LCFI29:
 923 0688 31F6     	xorl %esi,%esi
 924 068a 8B9424DC 	movl 476(%esp),%edx
 924      010000
 925 0691 3BB2F400 	cmpl 244(%edx),%esi
 925      0000
 926              	.L718:
 927 0697 7330     	jae .L712
 209:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 			p += sprintf(p, "%02x", network->wpa_ie[i]);
 928              	.loc 1 209 0
 929 0699 8B8C24DC 	movl 476(%esp),%ecx
GAS LISTING  			page 41


 929      010000
 930 06a0 0FB6840E 	movzbl 179(%esi,%ecx),%eax
 930      B3000000 
 931 06a8 50       	pushl %eax
 932              	.LCFI30:
 933 06a9 684E0000 	pushl $.LC15
 933      00
 934              	.LCFI31:
 935 06ae 53       	pushl %ebx
 936              	.LCFI32:
 937 06af E8FCFFFF 	call sprintf
 937      FF
 938              	.loc 1 208 0
 939 06b4 83C40C   	addl $12,%esp
 940              	.LCFI33:
 941              	.loc 1 209 0
 942 06b7 01C3     	addl %eax,%ebx
 943              	.loc 1 208 0
 944 06b9 46       	incl %esi
 945 06ba 8B8424DC 	movl 476(%esp),%eax
 945      010000
 946 06c1 3BB0F400 	cmpl 244(%eax),%esi
 946      0000
 947 06c7 EBCE     	jmp .L718
 948              	.L712:
 949              	.LBB86:
 950              	.loc 2 190 0
 951 06c9 8D9C24BC 	leal 188(%esp),%ebx
 951      000000
 952              	.LBE86:
 210:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		}
 211:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		iwe.cmd = IWEVCUSTOM;
 953              	.loc 1 211 0
 954 06d0 66C78424 	movw $-29694,350(%esp)
 954      5E010000 
 954      028C
 955              	.LBB87:
 956              	.LBB88:
 957              	.loc 2 193 0
 958 06da 31C0     	xorl %eax,%eax
 959 06dc 83C9FF   	orl $-1,%ecx
 960 06df 89DF     	movl %ebx,%edi
 961              	
 962 06e1 F2       	repne
 963 06e2 AE       	scasb
 964 06e3 F7D1     	notl %ecx
 965 06e5 49       	decl %ecx
 966              	
 967              	.LBE88:
 968              	.LBE87:
 969              	.loc 2 190 0
 970 06e6 66898C24 	movw %cx,356(%esp)
 970      64010000 
 971              	.LBB89:
 972              	.LBB90:
 973              	.loc 3 501 0
 974 06ee 0FB7C9   	movzwl %cx,%ecx
GAS LISTING  			page 42


 975              	.LBE90:
 976              	.loc 3 500 0
 977 06f1 8B542408 	movl 8(%esp),%edx
 978              	.LBB91:
 979              	.loc 3 501 0
 980 06f5 8D410C   	leal 12(%ecx),%eax
 981              	.loc 3 503 0
 982 06f8 8D2C02   	leal (%edx,%eax),%ebp
 983 06fb 3BAC24D8 	cmpl 472(%esp),%ebp
 983      010000
 984              	.LBE91:
 985              	.loc 3 500 0
 986 0702 8DB4245C 	leal 348(%esp),%esi
 986      010000
 987              	.LBB92:
 988              	.loc 3 503 0
 989 0709 732C     	jae .L487
 990              	.loc 3 504 0
 991 070b 66898424 	movw %ax,348(%esp)
 991      5C010000 
 992              	.LBB93:
 993              	.LBB94:
 994              	.loc 2 262 0
 995 0713 89D7     	movl %edx,%edi
 996              	
 997 0715 A5       	movsl
 998              	.loc 2 264 0
 999 0716 A5       	movsl
 1000              	.loc 2 266 0
 1001 0717 A5       	movsl
 1002              	
 1003              	.LBE94:
 1004              	.LBE93:
 1005              	.loc 3 506 0
 1006 0718 0FB78424 	movzwl 356(%esp),%eax
 1006      64010000 
 1007              	.LBB95:
 1008              	.LBB96:
 1009              	.loc 2 207 0
 1010 0720 89C1     	movl %eax,%ecx
 1011 0722 8D7A0C   	leal 12(%edx),%edi
 1012 0725 C1E902   	shrl $2,%ecx
 1013 0728 89DE     	movl %ebx,%esi
 1014              	
 1015 072a F3A5     	rep
 1016 072c 89C1     	movl %eax,%ecx
 1017 072e 83E103   	andl $3,%ecx
 1018 0731 7402     	jz 1f
 1019 0733 F3A4     	rep
 1020              	1:
 1021              	
 1022              	.LBE96:
 1023              	.LBE95:
 1024              	.loc 3 507 0
 1025 0735 89EA     	movl %ebp,%edx
 1026              	.L487:
 1027              	.LBE92:
GAS LISTING  			page 43


 1028              	.LBE89:
 1029              	.loc 3 500 0
 1030 0737 89D5     	movl %edx,%ebp
 1031              	.L481:
 1032              	.LBE85:
 1033              	.LBB97:
 1034              	.loc 2 420 0
 1035 0739 8DBC245C 	leal 348(%esp),%edi
 1035      010000
 1036 0740 31C0     	xorl %eax,%eax
 1037              	.LBB98:
 1038              	.LBB99:
 1039              	.loc 2 448 0
 1040 0742 B9050000 	movl $5,%ecx
 1040      00
 1041              	
 1042 0747 F3AB     	rep
 1043              	
 1044              	.LBE99:
 1045              	.LBE98:
 1046              	.LBE97:
 212:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		iwe.u.data.length = strlen(buf);
 213:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** #endif
 214:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		start = iwe_stream_add_point(start, stop, &iwe, buf);
 215:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	}
 216:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 
 217:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	memset(&iwe, 0, sizeof(iwe));
 218:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	if (network->rsn_ie_len) {
 1047              	.loc 1 218 0
 1048 0749 8B9424DC 	movl 476(%esp),%edx
 1048      010000
 1049 0750 83BA3801 	cmpl $0,312(%edx)
 1049      000000
 1050 0757 0F84B100 	je .L549
 1050      0000
 1051              	.LBB100:
 219:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** #ifdef IWEVGENIE
 220:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		char buf[MAX_WPA_IE_LEN];
 221:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		memcpy(buf, network->rsn_ie, network->rsn_ie_len);
 222:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		iwe.cmd = IWEVGENIE;
 223:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		iwe.u.data.length = network->rsn_ie_len;
 224:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** #else
 225:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		char buf[MAX_WPA_IE_LEN * 2 + 30];
 226:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 
 227:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		u8 *p = buf;
 1052              	.loc 1 227 0
 1053 075d 8D5C241C 	leal 28(%esp),%ebx
 228:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		p += sprintf(p, "rsn_ie=");
 1054              	.loc 1 228 0
 1055 0761 68530000 	pushl $.LC16
 1055      00
 1056              	.LCFI34:
 1057 0766 53       	pushl %ebx
 1058              	.LCFI35:
 1059 0767 E8FCFFFF 	call sprintf
 1059      FF
 229:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		for (i = 0; i < network->rsn_ie_len; i++) {
GAS LISTING  			page 44


 1060              	.loc 1 229 0
 1061 076c 5F       	popl %edi
 1062              	.LCFI36:
 1063              	.loc 1 228 0
 1064 076d 01C3     	addl %eax,%ebx
 1065              	.loc 1 229 0
 1066 076f 31F6     	xorl %esi,%esi
 1067 0771 58       	popl %eax
 1068              	.LCFI37:
 1069              	.L719:
 1070 0772 8B8C24DC 	movl 476(%esp),%ecx
 1070      010000
 1071 0779 3BB13801 	cmpl 312(%ecx),%esi
 1071      0000
 1072 077f 7323     	jae .L714
 230:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 			p += sprintf(p, "%02x", network->rsn_ie[i]);
 1073              	.loc 1 230 0
 1074 0781 8B9424DC 	movl 476(%esp),%edx
 1074      010000
 1075 0788 0FB68416 	movzbl 248(%esi,%edx),%eax
 1075      F8000000 
 1076 0790 50       	pushl %eax
 1077              	.LCFI38:
 1078 0791 684E0000 	pushl $.LC15
 1078      00
 1079              	.LCFI39:
 1080 0796 53       	pushl %ebx
 1081              	.LCFI40:
 1082 0797 E8FCFFFF 	call sprintf
 1082      FF
 1083 079c 01C3     	addl %eax,%ebx
 1084              	.loc 1 229 0
 1085 079e 83C40C   	addl $12,%esp
 1086              	.LCFI41:
 1087 07a1 46       	incl %esi
 1088 07a2 EBCE     	jmp .L719
 1089              	.L714:
 1090              	.LBB101:
 1091              	.loc 2 190 0
 1092 07a4 8D54241C 	leal 28(%esp),%edx
 1093              	.LBE101:
 231:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		}
 232:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		iwe.cmd = IWEVCUSTOM;
 1094              	.loc 1 232 0
 1095 07a8 66C78424 	movw $-29694,350(%esp)
 1095      5E010000 
 1095      028C
 1096              	.LBB102:
 1097              	.LBB103:
 1098              	.loc 2 193 0
 1099 07b2 31C0     	xorl %eax,%eax
 1100 07b4 83C9FF   	orl $-1,%ecx
 1101 07b7 89D7     	movl %edx,%edi
 1102              	
 1103 07b9 F2       	repne
 1104 07ba AE       	scasb
 1105 07bb F7D1     	notl %ecx
GAS LISTING  			page 45


 1106 07bd 49       	decl %ecx
 1107              	
 1108              	.LBE103:
 1109              	.LBE102:
 1110              	.loc 2 190 0
 1111 07be 66898C24 	movw %cx,356(%esp)
 1111      64010000 
 1112              	.LBB104:
 1113              	.LBB105:
 1114              	.loc 3 501 0
 1115 07c6 0FB7C9   	movzwl %cx,%ecx
 1116 07c9 8D410C   	leal 12(%ecx),%eax
 1117              	.loc 3 503 0
 1118 07cc 8D5C0500 	leal (%ebp,%eax),%ebx
 1119 07d0 3B9C24D8 	cmpl 472(%esp),%ebx
 1119      010000
 1120              	.LBE105:
 1121              	.loc 3 500 0
 1122 07d7 89EF     	movl %ebp,%edi
 1123 07d9 8DB4245C 	leal 348(%esp),%esi
 1123      010000
 1124              	.LBB106:
 1125              	.loc 3 503 0
 1126 07e0 732A     	jae .L555
 1127              	.loc 3 504 0
 1128 07e2 66898424 	movw %ax,348(%esp)
 1128      5C010000 
 1129              	.LBB107:
 1130              	.LBB108:
 1131              	.loc 2 262 0
 1132              	
 1133 07ea A5       	movsl
 1134              	.loc 2 264 0
 1135 07eb A5       	movsl
 1136              	.loc 2 266 0
 1137 07ec A5       	movsl
 1138              	
 1139              	.LBE108:
 1140              	.LBE107:
 1141              	.loc 3 506 0
 1142 07ed 0FB78424 	movzwl 356(%esp),%eax
 1142      64010000 
 1143              	.LBB109:
 1144              	.LBB110:
 1145              	.loc 2 207 0
 1146 07f5 89C1     	movl %eax,%ecx
 1147 07f7 8D7D0C   	leal 12(%ebp),%edi
 1148 07fa C1E902   	shrl $2,%ecx
 1149 07fd 89D6     	movl %edx,%esi
 1150              	
 1151 07ff F3A5     	rep
 1152 0801 89C1     	movl %eax,%ecx
 1153 0803 83E103   	andl $3,%ecx
 1154 0806 7402     	jz 1f
 1155 0808 F3A4     	rep
 1156              	1:
 1157              	
GAS LISTING  			page 46


 1158              	.LBE110:
 1159              	.LBE109:
 1160              	.loc 3 507 0
 1161 080a 89DF     	movl %ebx,%edi
 1162              	.L555:
 1163              	.LBE106:
 1164              	.LBE104:
 1165              	.loc 3 500 0
 1166 080c 89FD     	movl %edi,%ebp
 1167              	.L549:
 1168              	.LBE100:
 233:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		iwe.u.data.length = strlen(buf);
 234:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** #endif
 235:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		start = iwe_stream_add_point(start, stop, &iwe, buf);
 236:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	}
 237:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 
 238:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	/* Add EXTRA: Age to display seconds since last beacon/probe response
 239:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	 * for given network. */
 240:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	iwe.cmd = IWEVCUSTOM;
 241:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	p = custom;
 1169              	.loc 1 241 0
 1170 080e 8D84247C 	leal 380(%esp),%eax
 1170      010000
 1171 0815 89442418 	movl %eax,24(%esp)
 1172              	.loc 1 240 0
 1173 0819 66C78424 	movw $-29694,350(%esp)
 1173      5E010000 
 1173      028C
 1174              	.LBB111:
 1175              	.file 4 "include/linux/jiffies.h"
   1:include/linux/jiffies.h **** #ifndef _LINUX_JIFFIES_H
   2:include/linux/jiffies.h **** #define _LINUX_JIFFIES_H
   3:include/linux/jiffies.h **** 
   4:include/linux/jiffies.h **** #include <linux/kernel.h>
   5:include/linux/jiffies.h **** #include <linux/types.h>
   6:include/linux/jiffies.h **** #include <linux/time.h>
   7:include/linux/jiffies.h **** #include <linux/timex.h>
   8:include/linux/jiffies.h **** #include <asm/param.h>			/* for HZ */
   9:include/linux/jiffies.h **** #include <asm/div64.h>
  10:include/linux/jiffies.h **** 
  11:include/linux/jiffies.h **** #ifndef div_long_long_rem
  12:include/linux/jiffies.h **** #define div_long_long_rem(dividend,divisor,remainder) \
  13:include/linux/jiffies.h **** ({							\
  14:include/linux/jiffies.h **** 	u64 result = dividend;				\
  15:include/linux/jiffies.h **** 	*remainder = do_div(result,divisor);		\
  16:include/linux/jiffies.h **** 	result;						\
  17:include/linux/jiffies.h **** })
  18:include/linux/jiffies.h **** #endif
  19:include/linux/jiffies.h **** 
  20:include/linux/jiffies.h **** /*
  21:include/linux/jiffies.h ****  * The following defines establish the engineering parameters of the PLL
  22:include/linux/jiffies.h ****  * model. The HZ variable establishes the timer interrupt frequency, 100 Hz
  23:include/linux/jiffies.h ****  * for the SunOS kernel, 256 Hz for the Ultrix kernel and 1024 Hz for the
  24:include/linux/jiffies.h ****  * OSF/1 kernel. The SHIFT_HZ define expresses the same value as the
  25:include/linux/jiffies.h ****  * nearest power of two in order to avoid hardware multiply operations.
  26:include/linux/jiffies.h ****  */
  27:include/linux/jiffies.h **** #if HZ >= 12 && HZ < 24
GAS LISTING  			page 47


  28:include/linux/jiffies.h **** # define SHIFT_HZ	4
  29:include/linux/jiffies.h **** #elif HZ >= 24 && HZ < 48
  30:include/linux/jiffies.h **** # define SHIFT_HZ	5
  31:include/linux/jiffies.h **** #elif HZ >= 48 && HZ < 96
  32:include/linux/jiffies.h **** # define SHIFT_HZ	6
  33:include/linux/jiffies.h **** #elif HZ >= 96 && HZ < 192
  34:include/linux/jiffies.h **** # define SHIFT_HZ	7
  35:include/linux/jiffies.h **** #elif HZ >= 192 && HZ < 384
  36:include/linux/jiffies.h **** # define SHIFT_HZ	8
  37:include/linux/jiffies.h **** #elif HZ >= 384 && HZ < 768
  38:include/linux/jiffies.h **** # define SHIFT_HZ	9
  39:include/linux/jiffies.h **** #elif HZ >= 768 && HZ < 1536
  40:include/linux/jiffies.h **** # define SHIFT_HZ	10
  41:include/linux/jiffies.h **** #else
  42:include/linux/jiffies.h **** # error You lose.
  43:include/linux/jiffies.h **** #endif
  44:include/linux/jiffies.h **** 
  45:include/linux/jiffies.h **** /* LATCH is used in the interval timer and ftape setup. */
  46:include/linux/jiffies.h **** #define LATCH  ((CLOCK_TICK_RATE + HZ/2) / HZ)	/* For divider */
  47:include/linux/jiffies.h **** 
  48:include/linux/jiffies.h **** /* Suppose we want to devide two numbers NOM and DEN: NOM/DEN, the we can
  49:include/linux/jiffies.h ****  * improve accuracy by shifting LSH bits, hence calculating:
  50:include/linux/jiffies.h ****  *     (NOM << LSH) / DEN
  51:include/linux/jiffies.h ****  * This however means trouble for large NOM, because (NOM << LSH) may no
  52:include/linux/jiffies.h ****  * longer fit in 32 bits. The following way of calculating this gives us
  53:include/linux/jiffies.h ****  * some slack, under the following conditions:
  54:include/linux/jiffies.h ****  *   - (NOM / DEN) fits in (32 - LSH) bits.
  55:include/linux/jiffies.h ****  *   - (NOM % DEN) fits in (32 - LSH) bits.
  56:include/linux/jiffies.h ****  */
  57:include/linux/jiffies.h **** #define SH_DIV(NOM,DEN,LSH) (   ((NOM / DEN) << LSH)                    \
  58:include/linux/jiffies.h ****                              + (((NOM % DEN) << LSH) + DEN / 2) / DEN)
  59:include/linux/jiffies.h **** 
  60:include/linux/jiffies.h **** /* HZ is the requested value. ACTHZ is actual HZ ("<< 8" is for accuracy) */
  61:include/linux/jiffies.h **** #define ACTHZ (SH_DIV (CLOCK_TICK_RATE, LATCH, 8))
  62:include/linux/jiffies.h **** 
  63:include/linux/jiffies.h **** /* TICK_NSEC is the time between ticks in nsec assuming real ACTHZ */
  64:include/linux/jiffies.h **** #define TICK_NSEC (SH_DIV (1000000UL * 1000, ACTHZ, 8))
  65:include/linux/jiffies.h **** 
  66:include/linux/jiffies.h **** /* TICK_USEC is the time between ticks in usec assuming fake USER_HZ */
  67:include/linux/jiffies.h **** #define TICK_USEC ((1000000UL + USER_HZ/2) / USER_HZ)
  68:include/linux/jiffies.h **** 
  69:include/linux/jiffies.h **** /* TICK_USEC_TO_NSEC is the time between ticks in nsec assuming real ACTHZ and	*/
  70:include/linux/jiffies.h **** /* a value TUSEC for TICK_USEC (can be set bij adjtimex)		*/
  71:include/linux/jiffies.h **** #define TICK_USEC_TO_NSEC(TUSEC) (SH_DIV (TUSEC * USER_HZ * 1000, ACTHZ, 8))
  72:include/linux/jiffies.h **** 
  73:include/linux/jiffies.h **** /* some arch's have a small-data section that can be accessed register-relative
  74:include/linux/jiffies.h ****  * but that can only take up to, say, 4-byte variables. jiffies being part of
  75:include/linux/jiffies.h ****  * an 8-byte variable may not be correctly accessed unless we force the issue
  76:include/linux/jiffies.h ****  */
  77:include/linux/jiffies.h **** #define __jiffy_data  __attribute__((section(".data")))
  78:include/linux/jiffies.h **** 
  79:include/linux/jiffies.h **** /*
  80:include/linux/jiffies.h ****  * The 64-bit value is not volatile - you MUST NOT read it
  81:include/linux/jiffies.h ****  * without sampling the sequence number in xtime_lock.
  82:include/linux/jiffies.h ****  * get_jiffies_64() will do this for you as appropriate.
  83:include/linux/jiffies.h ****  */
  84:include/linux/jiffies.h **** extern u64 __jiffy_data jiffies_64;
GAS LISTING  			page 48


  85:include/linux/jiffies.h **** extern unsigned long volatile __jiffy_data jiffies;
  86:include/linux/jiffies.h **** 
  87:include/linux/jiffies.h **** #if (BITS_PER_LONG < 64)
  88:include/linux/jiffies.h **** u64 get_jiffies_64(void);
  89:include/linux/jiffies.h **** #else
  90:include/linux/jiffies.h **** static inline u64 get_jiffies_64(void)
  91:include/linux/jiffies.h **** {
  92:include/linux/jiffies.h **** 	return (u64)jiffies;
  93:include/linux/jiffies.h **** }
  94:include/linux/jiffies.h **** #endif
  95:include/linux/jiffies.h **** 
  96:include/linux/jiffies.h **** /*
  97:include/linux/jiffies.h ****  *	These inlines deal with timer wrapping correctly. You are 
  98:include/linux/jiffies.h ****  *	strongly encouraged to use them
  99:include/linux/jiffies.h ****  *	1. Because people otherwise forget
 100:include/linux/jiffies.h ****  *	2. Because if the timer wrap changes in future you won't have to
 101:include/linux/jiffies.h ****  *	   alter your driver code.
 102:include/linux/jiffies.h ****  *
 103:include/linux/jiffies.h ****  * time_after(a,b) returns true if the time a is after time b.
 104:include/linux/jiffies.h ****  *
 105:include/linux/jiffies.h ****  * Do this with "<0" and ">=0" to only test the sign of the result. A
 106:include/linux/jiffies.h ****  * good compiler would generate better code (and a really good compiler
 107:include/linux/jiffies.h ****  * wouldn't care). Gcc is currently neither.
 108:include/linux/jiffies.h ****  */
 109:include/linux/jiffies.h **** #define time_after(a,b)		\
 110:include/linux/jiffies.h **** 	(typecheck(unsigned long, a) && \
 111:include/linux/jiffies.h **** 	 typecheck(unsigned long, b) && \
 112:include/linux/jiffies.h **** 	 ((long)(b) - (long)(a) < 0))
 113:include/linux/jiffies.h **** #define time_before(a,b)	time_after(b,a)
 114:include/linux/jiffies.h **** 
 115:include/linux/jiffies.h **** #define time_after_eq(a,b)	\
 116:include/linux/jiffies.h **** 	(typecheck(unsigned long, a) && \
 117:include/linux/jiffies.h **** 	 typecheck(unsigned long, b) && \
 118:include/linux/jiffies.h **** 	 ((long)(a) - (long)(b) >= 0))
 119:include/linux/jiffies.h **** #define time_before_eq(a,b)	time_after_eq(b,a)
 120:include/linux/jiffies.h **** 
 121:include/linux/jiffies.h **** /*
 122:include/linux/jiffies.h ****  * Have the 32 bit jiffies value wrap 5 minutes after boot
 123:include/linux/jiffies.h ****  * so jiffies wrap bugs show up earlier.
 124:include/linux/jiffies.h ****  */
 125:include/linux/jiffies.h **** #define INITIAL_JIFFIES ((unsigned long)(unsigned int) (-300*HZ))
 126:include/linux/jiffies.h **** 
 127:include/linux/jiffies.h **** /*
 128:include/linux/jiffies.h ****  * Change timeval to jiffies, trying to avoid the
 129:include/linux/jiffies.h ****  * most obvious overflows..
 130:include/linux/jiffies.h ****  *
 131:include/linux/jiffies.h ****  * And some not so obvious.
 132:include/linux/jiffies.h ****  *
 133:include/linux/jiffies.h ****  * Note that we don't want to return MAX_LONG, because
 134:include/linux/jiffies.h ****  * for various timeout reasons we often end up having
 135:include/linux/jiffies.h ****  * to wait "jiffies+1" in order to guarantee that we wait
 136:include/linux/jiffies.h ****  * at _least_ "jiffies" - so "jiffies+1" had better still
 137:include/linux/jiffies.h ****  * be positive.
 138:include/linux/jiffies.h ****  */
 139:include/linux/jiffies.h **** #define MAX_JIFFY_OFFSET ((~0UL >> 1)-1)
 140:include/linux/jiffies.h **** 
 141:include/linux/jiffies.h **** /*
GAS LISTING  			page 49


 142:include/linux/jiffies.h ****  * We want to do realistic conversions of time so we need to use the same
 143:include/linux/jiffies.h ****  * values the update wall clock code uses as the jiffies size.  This value
 144:include/linux/jiffies.h ****  * is: TICK_NSEC (which is defined in timex.h).  This
 145:include/linux/jiffies.h ****  * is a constant and is in nanoseconds.  We will used scaled math
 146:include/linux/jiffies.h ****  * with a set of scales defined here as SEC_JIFFIE_SC,  USEC_JIFFIE_SC and
 147:include/linux/jiffies.h ****  * NSEC_JIFFIE_SC.  Note that these defines contain nothing but
 148:include/linux/jiffies.h ****  * constants and so are computed at compile time.  SHIFT_HZ (computed in
 149:include/linux/jiffies.h ****  * timex.h) adjusts the scaling for different HZ values.
 150:include/linux/jiffies.h **** 
 151:include/linux/jiffies.h ****  * Scaled math???  What is that?
 152:include/linux/jiffies.h ****  *
 153:include/linux/jiffies.h ****  * Scaled math is a way to do integer math on values that would,
 154:include/linux/jiffies.h ****  * otherwise, either overflow, underflow, or cause undesired div
 155:include/linux/jiffies.h ****  * instructions to appear in the execution path.  In short, we "scale"
 156:include/linux/jiffies.h ****  * up the operands so they take more bits (more precision, less
 157:include/linux/jiffies.h ****  * underflow), do the desired operation and then "scale" the result back
 158:include/linux/jiffies.h ****  * by the same amount.  If we do the scaling by shifting we avoid the
 159:include/linux/jiffies.h ****  * costly mpy and the dastardly div instructions.
 160:include/linux/jiffies.h **** 
 161:include/linux/jiffies.h ****  * Suppose, for example, we want to convert from seconds to jiffies
 162:include/linux/jiffies.h ****  * where jiffies is defined in nanoseconds as NSEC_PER_JIFFIE.  The
 163:include/linux/jiffies.h ****  * simple math is: jiff = (sec * NSEC_PER_SEC) / NSEC_PER_JIFFIE; We
 164:include/linux/jiffies.h ****  * observe that (NSEC_PER_SEC / NSEC_PER_JIFFIE) is a constant which we
 165:include/linux/jiffies.h ****  * might calculate at compile time, however, the result will only have
 166:include/linux/jiffies.h ****  * about 3-4 bits of precision (less for smaller values of HZ).
 167:include/linux/jiffies.h ****  *
 168:include/linux/jiffies.h ****  * So, we scale as follows:
 169:include/linux/jiffies.h ****  * jiff = (sec) * (NSEC_PER_SEC / NSEC_PER_JIFFIE);
 170:include/linux/jiffies.h ****  * jiff = ((sec) * ((NSEC_PER_SEC * SCALE)/ NSEC_PER_JIFFIE)) / SCALE;
 171:include/linux/jiffies.h ****  * Then we make SCALE a power of two so:
 172:include/linux/jiffies.h ****  * jiff = ((sec) * ((NSEC_PER_SEC << SCALE)/ NSEC_PER_JIFFIE)) >> SCALE;
 173:include/linux/jiffies.h ****  * Now we define:
 174:include/linux/jiffies.h ****  * #define SEC_CONV = ((NSEC_PER_SEC << SCALE)/ NSEC_PER_JIFFIE))
 175:include/linux/jiffies.h ****  * jiff = (sec * SEC_CONV) >> SCALE;
 176:include/linux/jiffies.h ****  *
 177:include/linux/jiffies.h ****  * Often the math we use will expand beyond 32-bits so we tell C how to
 178:include/linux/jiffies.h ****  * do this and pass the 64-bit result of the mpy through the ">> SCALE"
 179:include/linux/jiffies.h ****  * which should take the result back to 32-bits.  We want this expansion
 180:include/linux/jiffies.h ****  * to capture as much precision as possible.  At the same time we don't
 181:include/linux/jiffies.h ****  * want to overflow so we pick the SCALE to avoid this.  In this file,
 182:include/linux/jiffies.h ****  * that means using a different scale for each range of HZ values (as
 183:include/linux/jiffies.h ****  * defined in timex.h).
 184:include/linux/jiffies.h ****  *
 185:include/linux/jiffies.h ****  * For those who want to know, gcc will give a 64-bit result from a "*"
 186:include/linux/jiffies.h ****  * operator if the result is a long long AND at least one of the
 187:include/linux/jiffies.h ****  * operands is cast to long long (usually just prior to the "*" so as
 188:include/linux/jiffies.h ****  * not to confuse it into thinking it really has a 64-bit operand,
 189:include/linux/jiffies.h ****  * which, buy the way, it can do, but it take more code and at least 2
 190:include/linux/jiffies.h ****  * mpys).
 191:include/linux/jiffies.h **** 
 192:include/linux/jiffies.h ****  * We also need to be aware that one second in nanoseconds is only a
 193:include/linux/jiffies.h ****  * couple of bits away from overflowing a 32-bit word, so we MUST use
 194:include/linux/jiffies.h ****  * 64-bits to get the full range time in nanoseconds.
 195:include/linux/jiffies.h **** 
 196:include/linux/jiffies.h ****  */
 197:include/linux/jiffies.h **** 
 198:include/linux/jiffies.h **** /*
GAS LISTING  			page 50


 199:include/linux/jiffies.h ****  * Here are the scales we will use.  One for seconds, nanoseconds and
 200:include/linux/jiffies.h ****  * microseconds.
 201:include/linux/jiffies.h ****  *
 202:include/linux/jiffies.h ****  * Within the limits of cpp we do a rough cut at the SEC_JIFFIE_SC and
 203:include/linux/jiffies.h ****  * check if the sign bit is set.  If not, we bump the shift count by 1.
 204:include/linux/jiffies.h ****  * (Gets an extra bit of precision where we can use it.)
 205:include/linux/jiffies.h ****  * We know it is set for HZ = 1024 and HZ = 100 not for 1000.
 206:include/linux/jiffies.h ****  * Haven't tested others.
 207:include/linux/jiffies.h **** 
 208:include/linux/jiffies.h ****  * Limits of cpp (for #if expressions) only long (no long long), but
 209:include/linux/jiffies.h ****  * then we only need the most signicant bit.
 210:include/linux/jiffies.h ****  */
 211:include/linux/jiffies.h **** 
 212:include/linux/jiffies.h **** #define SEC_JIFFIE_SC (31 - SHIFT_HZ)
 213:include/linux/jiffies.h **** #if !((((NSEC_PER_SEC << 2) / TICK_NSEC) << (SEC_JIFFIE_SC - 2)) & 0x80000000)
 214:include/linux/jiffies.h **** #undef SEC_JIFFIE_SC
 215:include/linux/jiffies.h **** #define SEC_JIFFIE_SC (32 - SHIFT_HZ)
 216:include/linux/jiffies.h **** #endif
 217:include/linux/jiffies.h **** #define NSEC_JIFFIE_SC (SEC_JIFFIE_SC + 29)
 218:include/linux/jiffies.h **** #define USEC_JIFFIE_SC (SEC_JIFFIE_SC + 19)
 219:include/linux/jiffies.h **** #define SEC_CONVERSION ((unsigned long)((((u64)NSEC_PER_SEC << SEC_JIFFIE_SC) +\
 220:include/linux/jiffies.h ****                                 TICK_NSEC -1) / (u64)TICK_NSEC))
 221:include/linux/jiffies.h **** 
 222:include/linux/jiffies.h **** #define NSEC_CONVERSION ((unsigned long)((((u64)1 << NSEC_JIFFIE_SC) +\
 223:include/linux/jiffies.h ****                                         TICK_NSEC -1) / (u64)TICK_NSEC))
 224:include/linux/jiffies.h **** #define USEC_CONVERSION  \
 225:include/linux/jiffies.h ****                     ((unsigned long)((((u64)NSEC_PER_USEC << USEC_JIFFIE_SC) +\
 226:include/linux/jiffies.h ****                                         TICK_NSEC -1) / (u64)TICK_NSEC))
 227:include/linux/jiffies.h **** /*
 228:include/linux/jiffies.h ****  * USEC_ROUND is used in the timeval to jiffie conversion.  See there
 229:include/linux/jiffies.h ****  * for more details.  It is the scaled resolution rounding value.  Note
 230:include/linux/jiffies.h ****  * that it is a 64-bit value.  Since, when it is applied, we are already
 231:include/linux/jiffies.h ****  * in jiffies (albit scaled), it is nothing but the bits we will shift
 232:include/linux/jiffies.h ****  * off.
 233:include/linux/jiffies.h ****  */
 234:include/linux/jiffies.h **** #define USEC_ROUND (u64)(((u64)1 << USEC_JIFFIE_SC) - 1)
 235:include/linux/jiffies.h **** /*
 236:include/linux/jiffies.h ****  * The maximum jiffie value is (MAX_INT >> 1).  Here we translate that
 237:include/linux/jiffies.h ****  * into seconds.  The 64-bit case will overflow if we are not careful,
 238:include/linux/jiffies.h ****  * so use the messy SH_DIV macro to do it.  Still all constants.
 239:include/linux/jiffies.h ****  */
 240:include/linux/jiffies.h **** #if BITS_PER_LONG < 64
 241:include/linux/jiffies.h **** # define MAX_SEC_IN_JIFFIES \
 242:include/linux/jiffies.h **** 	(long)((u64)((u64)MAX_JIFFY_OFFSET * TICK_NSEC) / NSEC_PER_SEC)
 243:include/linux/jiffies.h **** #else	/* take care of overflow on 64 bits machines */
 244:include/linux/jiffies.h **** # define MAX_SEC_IN_JIFFIES \
 245:include/linux/jiffies.h **** 	(SH_DIV((MAX_JIFFY_OFFSET >> SEC_JIFFIE_SC) * TICK_NSEC, NSEC_PER_SEC, 1) - 1)
 246:include/linux/jiffies.h **** 
 247:include/linux/jiffies.h **** #endif
 248:include/linux/jiffies.h **** 
 249:include/linux/jiffies.h **** /*
 250:include/linux/jiffies.h ****  * Convert jiffies to milliseconds and back.
 251:include/linux/jiffies.h ****  *
 252:include/linux/jiffies.h ****  * Avoid unnecessary multiplications/divisions in the
 253:include/linux/jiffies.h ****  * two most common HZ cases:
 254:include/linux/jiffies.h ****  */
 255:include/linux/jiffies.h **** static inline unsigned int jiffies_to_msecs(const unsigned long j)
GAS LISTING  			page 51


 256:include/linux/jiffies.h **** {
 1176              	.loc 4 256 0
 1177 0823 8B9424DC 	movl 476(%esp),%edx
 1177      010000
 1178 082a A1000000 	movl jiffies,%eax
 1178      00
 1179 082f 2B829400 	subl 148(%edx),%eax
 1179      0000
 1180              	.LBE111:
 1181 0835 50       	pushl %eax
 1182              	.LCFI42:
 1183 0836 685B0000 	pushl $.LC17
 1183      00
 1184              	.LCFI43:
 1185 083b 8B5C2420 	movl 32(%esp),%ebx
 1186 083f 6A40     	pushl $64
 1187              	.LCFI44:
 1188 0841 FF742424 	pushl 36(%esp)
 1189              	.LCFI45:
 1190 0845 E8FCFFFF 	call snprintf
 1190      FF
 1191 084a 01442428 	addl %eax,40(%esp)
 242:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	p += snprintf(p, MAX_CUSTOM_LEN - (p - custom),
 243:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		      " Last beacon: %dms ago",
 244:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		      jiffies_to_msecs(jiffies - network->last_scanned));
 245:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	iwe.u.data.length = p - custom;
 1192              	.loc 1 245 0
 1193 084e 8B442428 	movl 40(%esp),%eax
 1194 0852 6629D8   	subw %bx,%ax
 1195 0855 66898424 	movw %ax,372(%esp)
 1195      74010000 
 246:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	if (iwe.u.data.length)
 1196              	.loc 1 246 0
 1197 085d 83C410   	addl $16,%esp
 1198              	.LCFI46:
 1199 0860 6685C0   	testw %ax,%ax
 1200 0863 7448     	je .L605
 1201              	.LBB112:
 1202              	.LBB113:
 1203              	.loc 3 501 0
 1204 0865 0FB7C0   	movzwl %ax,%eax
 1205 0868 83C00C   	addl $12,%eax
 1206              	.loc 3 503 0
 1207 086b 8D540500 	leal (%ebp,%eax),%edx
 1208 086f 3B9424D8 	cmpl 472(%esp),%edx
 1208      010000
 1209              	.LBE113:
 1210              	.loc 3 500 0
 1211 0876 89EF     	movl %ebp,%edi
 1212 0878 8DB4245C 	leal 348(%esp),%esi
 1212      010000
 1213              	.LBB114:
 1214              	.loc 3 503 0
 1215 087f 732A     	jae .L606
 1216              	.loc 3 504 0
 1217 0881 66898424 	movw %ax,348(%esp)
 1217      5C010000 
GAS LISTING  			page 52


 1218              	.LBB115:
 1219              	.LBB116:
 1220              	.loc 2 262 0
 1221              	
 1222 0889 A5       	movsl
 1223              	.loc 2 264 0
 1224 088a A5       	movsl
 1225              	.loc 2 266 0
 1226 088b A5       	movsl
 1227              	
 1228              	.LBE116:
 1229              	.LBE115:
 1230              	.loc 3 506 0
 1231 088c 0FB78424 	movzwl 356(%esp),%eax
 1231      64010000 
 1232              	.LBB117:
 1233              	.LBB118:
 1234              	.loc 2 207 0
 1235 0894 89C1     	movl %eax,%ecx
 1236 0896 8D7D0C   	leal 12(%ebp),%edi
 1237 0899 C1E902   	shrl $2,%ecx
 1238 089c 89DE     	movl %ebx,%esi
 1239              	
 1240 089e F3A5     	rep
 1241 08a0 89C1     	movl %eax,%ecx
 1242 08a2 83E103   	andl $3,%ecx
 1243 08a5 7402     	jz 1f
 1244 08a7 F3A4     	rep
 1245              	1:
 1246              	
 1247              	.LBE118:
 1248              	.LBE117:
 1249              	.loc 3 507 0
 1250 08a9 89D7     	movl %edx,%edi
 1251              	.L606:
 1252              	.LBE114:
 1253              	.LBE112:
 1254              	.loc 3 500 0
 1255 08ab 89FD     	movl %edi,%ebp
 1256              	.L605:
 247:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		start = iwe_stream_add_point(start, stop, &iwe, custom);
 248:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 
 249:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	/* Add spectrum management information */
 250:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	iwe.cmd = -1;
 1257              	.loc 1 250 0
 1258 08ad 66C78424 	movw $-1,350(%esp)
 1258      5E010000 
 1258      FFFF
 251:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	p = custom;
 252:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	p += snprintf(p, MAX_CUSTOM_LEN - (p - custom), " Channel flags: ");
 1259              	.loc 1 252 0
 1260 08b7 68720000 	pushl $.LC18
 1260      00
 1261              	.LCFI47:
 1262 08bc 8D9C2480 	leal 384(%esp),%ebx
 1262      010000
 1263 08c3 6A40     	pushl $64
GAS LISTING  			page 53


 1264              	.LCFI48:
 1265 08c5 53       	pushl %ebx
 1266              	.LCFI49:
 1267 08c6 E8FCFFFF 	call snprintf
 1267      FF
 1268 08cb 01D8     	addl %ebx,%eax
 1269 08cd 89442424 	movl %eax,36(%esp)
 253:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 
 254:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	if (ieee80211_get_channel_flags(ieee, network->channel) &
 1270              	.loc 1 254 0
 1271 08d1 8B8C24E8 	movl 488(%esp),%ecx
 1271      010000
 1272 08d8 0FB64106 	movzbl 6(%ecx),%eax
 1273 08dc 50       	pushl %eax
 1274              	.LCFI50:
 1275 08dd FFB424E0 	pushl 480(%esp)
 1275      010000
 1276              	.LCFI51:
 1277              	.LCFI52:
 1278 08e4 E8FCFFFF 	call ieee80211_get_channel_flags
 1278      FF
 1279 08e9 83C414   	addl $20,%esp
 1280              	.LCFI53:
 1281 08ec A840     	testb $64,%al
 1282              	.loc 1 252 0
 1283 08ee BE400000 	movl $64,%esi
 1283      00
 1284              	.loc 1 254 0
 1285 08f3 742A     	je .L655
 255:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	    IEEE80211_CH_INVALID) {
 256:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		iwe.cmd = IWEVCUSTOM;
 1286              	.loc 1 256 0
 1287 08f5 66C78424 	movw $-29694,350(%esp)
 1287      5E010000 
 1287      028C
 257:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		p += snprintf(p, MAX_CUSTOM_LEN - (p - custom), "INVALID ");
 1288              	.loc 1 257 0
 1289 08ff 68830000 	pushl $.LC19
 1289      00
 1290              	.LCFI54:
 1291 0904 8B44241C 	movl 28(%esp),%eax
 1292 0908 29D8     	subl %ebx,%eax
 1293 090a 89F2     	movl %esi,%edx
 1294 090c 29C2     	subl %eax,%edx
 1295 090e 52       	pushl %edx
 1296              	.LCFI55:
 1297 090f FF742420 	pushl 32(%esp)
 1298              	.LCFI56:
 1299 0913 E8FCFFFF 	call snprintf
 1299      FF
 1300 0918 01442424 	addl %eax,36(%esp)
 1301 091c 83C40C   	addl $12,%esp
 1302              	.LCFI57:
 1303              	.L655:
 258:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	}
 259:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 
 260:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	if (ieee80211_get_channel_flags(ieee, network->channel) &
GAS LISTING  			page 54


 1304              	.loc 1 260 0
 1305 091f 8B8C24DC 	movl 476(%esp),%ecx
 1305      010000
 1306 0926 0FB64106 	movzbl 6(%ecx),%eax
 1307 092a 50       	pushl %eax
 1308              	.LCFI58:
 1309 092b FFB424D4 	pushl 468(%esp)
 1309      010000
 1310              	.LCFI59:
 1311 0932 E8FCFFFF 	call ieee80211_get_channel_flags
 1311      FF
 1312 0937 5A       	popl %edx
 1313              	.LCFI60:
 1314 0938 A820     	testb $32,%al
 1315 093a 59       	popl %ecx
 1316              	.LCFI61:
 1317 093b 7428     	je .L656
 261:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	    IEEE80211_CH_RADAR_DETECT) {
 262:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		iwe.cmd = IWEVCUSTOM;
 1318              	.loc 1 262 0
 1319 093d 66C78424 	movw $-29694,350(%esp)
 1319      5E010000 
 1319      028C
 263:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		p += snprintf(p, MAX_CUSTOM_LEN - (p - custom), "DFS ");
 1320              	.loc 1 263 0
 1321 0947 688C0000 	pushl $.LC20
 1321      00
 1322              	.LCFI62:
 1323 094c 8B44241C 	movl 28(%esp),%eax
 1324 0950 29D8     	subl %ebx,%eax
 1325 0952 29C6     	subl %eax,%esi
 1326 0954 56       	pushl %esi
 1327              	.LCFI63:
 1328 0955 FF742420 	pushl 32(%esp)
 1329              	.LCFI64:
 1330 0959 E8FCFFFF 	call snprintf
 1330      FF
 1331 095e 01442424 	addl %eax,36(%esp)
 1332 0962 83C40C   	addl $12,%esp
 1333              	.LCFI65:
 1334              	.L656:
 264:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	}
 265:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 
 266:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	if (iwe.cmd == IWEVCUSTOM) {
 1335              	.loc 1 266 0
 1336 0965 6681BC24 	cmpw $-29694,350(%esp)
 1336      5E010000 
 1336      028C
 1337 096f 7557     	jne .L657
 267:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		iwe.u.data.length = p - custom;
 1338              	.loc 1 267 0
 1339 0971 8B442418 	movl 24(%esp),%eax
 1340 0975 6629D8   	subw %bx,%ax
 1341 0978 66898424 	movw %ax,356(%esp)
 1341      64010000 
 1342              	.LBB119:
 1343              	.LBB120:
GAS LISTING  			page 55


 1344              	.loc 3 501 0
 1345 0980 0FB7C0   	movzwl %ax,%eax
 1346 0983 83C00C   	addl $12,%eax
 1347              	.loc 3 503 0
 1348 0986 8D540500 	leal (%ebp,%eax),%edx
 1349 098a 3B9424D8 	cmpl 472(%esp),%edx
 1349      010000
 1350              	.LBE120:
 1351              	.loc 3 500 0
 1352 0991 89EF     	movl %ebp,%edi
 1353 0993 8DB4245C 	leal 348(%esp),%esi
 1353      010000
 1354              	.LBB121:
 1355              	.loc 3 503 0
 1356 099a 732A     	jae .L658
 1357              	.loc 3 504 0
 1358 099c 66898424 	movw %ax,348(%esp)
 1358      5C010000 
 1359              	.LBB122:
 1360              	.LBB123:
 1361              	.loc 2 262 0
 1362              	
 1363 09a4 A5       	movsl
 1364              	.loc 2 264 0
 1365 09a5 A5       	movsl
 1366              	.loc 2 266 0
 1367 09a6 A5       	movsl
 1368              	
 1369              	.LBE123:
 1370              	.LBE122:
 1371              	.loc 3 506 0
 1372 09a7 0FB78424 	movzwl 356(%esp),%eax
 1372      64010000 
 1373              	.LBB124:
 1374              	.LBB125:
 1375              	.loc 2 207 0
 1376 09af 89C1     	movl %eax,%ecx
 1377 09b1 8D7D0C   	leal 12(%ebp),%edi
 1378 09b4 C1E902   	shrl $2,%ecx
 1379 09b7 89DE     	movl %ebx,%esi
 1380              	
 1381 09b9 F3A5     	rep
 1382 09bb 89C1     	movl %eax,%ecx
 1383 09bd 83E103   	andl $3,%ecx
 1384 09c0 7402     	jz 1f
 1385 09c2 F3A4     	rep
 1386              	1:
 1387              	
 1388              	.LBE125:
 1389              	.LBE124:
 1390              	.loc 3 507 0
 1391 09c4 89D7     	movl %edx,%edi
 1392              	.L658:
 1393              	.LBE121:
 1394              	.LBE119:
 1395              	.loc 3 500 0
 1396 09c6 89FD     	movl %edi,%ebp
GAS LISTING  			page 56


 1397              	.L657:
 268:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		start = iwe_stream_add_point(start, stop, &iwe, custom);
 269:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	}
 270:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 
 271:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	return start;
 272:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** }
 1398              	.loc 1 272 0
 1399 09c8 81C4BC01 	addl $444,%esp
 1399      0000
 1400 09ce 5B       	popl %ebx
 1401 09cf 5E       	popl %esi
 1402 09d0 5F       	popl %edi
 1403 09d1 89E8     	movl %ebp,%eax
 1404 09d3 5D       	popl %ebp
 1405 09d4 C3       	ret
 1406              	.LFE665:
 1408              	.section .rodata
 1411              	__func__.0:
 1412 0000 69656565 	.string "ieee80211_wx_get_scan"
 1412      38303231 
 1412      315F7778 
 1412      5F676574 
 1412      5F736361 
 1413              	.section .rodata.str1.1
 1414              	.LC21:
 1415 0091 3C373E69 	.string "<7>ieee80211: %c %s Getting scan\n"
 1415      65656538 
 1415      30323131 
 1415      3A202563 
 1415      20257320 
 1416              	.LC22:
 1417 00b3 3C373E69 	.string "<7>ieee80211: %c %s Not showing network '%s (%02x:%02x:%02x:%02x:%02x:%02x)' due to age (%dms).\n"
 1417      65656538 
 1417      30323131 
 1417      3A202563 
 1417      20257320 
 1418              	.LC23:
 1419 0114 3C373E69 	.string "<7>ieee80211: %c %s exit: %d networks returned.\n"
 1419      65656538 
 1419      30323131 
 1419      3A202563 
 1419      20257320 
 1420              	.text
 1421              	.globl ieee80211_wx_get_scan
 1423              	ieee80211_wx_get_scan:
 1424              	.LFB666:
 273:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 
 274:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** #define SCAN_ITEM_SIZE 128
 275:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 
 276:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** int ieee80211_wx_get_scan(struct ieee80211_device *ieee,
 277:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 			  struct iw_request_info *info,
 278:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 			  union iwreq_data *wrqu, char *extra)
 279:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** {
 1425              	.loc 1 279 0
 1426 09d5 55       	pushl %ebp
 1427              	.LCFI66:
 1428 09d6 57       	pushl %edi
GAS LISTING  			page 57


 1429              	.LCFI67:
 1430 09d7 56       	pushl %esi
 1431              	.LCFI68:
 1432 09d8 53       	pushl %ebx
 1433              	.LCFI69:
 1434 09d9 83EC14   	subl $20,%esp
 1435              	.LCFI70:
 280:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	struct ieee80211_network *network;
 281:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	unsigned long flags;
 282:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	int err = 0;
 1436              	.loc 1 282 0
 1437 09dc C7442408 	movl $0,8(%esp)
 1437      00000000 
 283:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 
 284:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	char *ev = extra;
 285:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	char *stop = ev + wrqu->data.length;
 1438              	.loc 1 285 0
 1439 09e4 8B542430 	movl 48(%esp),%edx
 1440 09e8 0FB74204 	movzwl 4(%edx),%eax
 1441              	.loc 1 284 0
 1442 09ec 8B7C2434 	movl 52(%esp),%edi
 1443              	.loc 1 285 0
 1444 09f0 01F8     	addl %edi,%eax
 286:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	int i = 0;
 287:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 
 288:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	IEEE80211_DEBUG_WX("Getting scan\n");
 1445              	.loc 1 288 0
 1446 09f2 F6050000 	testb $2,ieee80211_debug_level
 1446      000002
 1447              	.loc 1 279 0
 1448 09f9 8B6C2428 	movl 40(%esp),%ebp
 1449              	.loc 1 285 0
 1450 09fd 89442404 	movl %eax,4(%esp)
 1451              	.loc 1 286 0
 1452 0a01 C7042400 	movl $0,(%esp)
 1452      000000
 1453              	.loc 1 288 0
 1454 0a08 743C     	je .L721
 1455              	.LBB126:
 1456              	.LBB127:
 1457              	.file 5 "include/asm/thread_info.h"
   1:include/asm/thread_info.h **** /* thread_info.h: i386 low-level thread information
   2:include/asm/thread_info.h ****  *
   3:include/asm/thread_info.h ****  * Copyright (C) 2002  David Howells (dhowells@redhat.com)
   4:include/asm/thread_info.h ****  * - Incorporating suggestions made by Linus Torvalds and Dave Miller
   5:include/asm/thread_info.h ****  */
   6:include/asm/thread_info.h **** 
   7:include/asm/thread_info.h **** #ifndef _ASM_THREAD_INFO_H
   8:include/asm/thread_info.h **** #define _ASM_THREAD_INFO_H
   9:include/asm/thread_info.h **** 
  10:include/asm/thread_info.h **** #ifdef __KERNEL__
  11:include/asm/thread_info.h **** 
  12:include/asm/thread_info.h **** #include <linux/config.h>
  13:include/asm/thread_info.h **** #include <linux/compiler.h>
  14:include/asm/thread_info.h **** #include <asm/page.h>
  15:include/asm/thread_info.h **** 
  16:include/asm/thread_info.h **** #ifndef __ASSEMBLY__
GAS LISTING  			page 58


  17:include/asm/thread_info.h **** #include <asm/processor.h>
  18:include/asm/thread_info.h **** #endif
  19:include/asm/thread_info.h **** 
  20:include/asm/thread_info.h **** /*
  21:include/asm/thread_info.h ****  * low level task data that entry.S needs immediate access to
  22:include/asm/thread_info.h ****  * - this struct should fit entirely inside of one cache line
  23:include/asm/thread_info.h ****  * - this struct shares the supervisor stack pages
  24:include/asm/thread_info.h ****  * - if the contents of this structure are changed, the assembly constants must also be changed
  25:include/asm/thread_info.h ****  */
  26:include/asm/thread_info.h **** #ifndef __ASSEMBLY__
  27:include/asm/thread_info.h **** 
  28:include/asm/thread_info.h **** struct thread_info {
  29:include/asm/thread_info.h **** 	struct task_struct	*task;		/* main task structure */
  30:include/asm/thread_info.h **** 	struct exec_domain	*exec_domain;	/* execution domain */
  31:include/asm/thread_info.h **** 	unsigned long		flags;		/* low level flags */
  32:include/asm/thread_info.h **** 	unsigned long		status;		/* thread-synchronous flags */
  33:include/asm/thread_info.h **** 	__u32			cpu;		/* current CPU */
  34:include/asm/thread_info.h **** 	__s32			preempt_count; /* 0 => preemptable, <0 => BUG */
  35:include/asm/thread_info.h **** 
  36:include/asm/thread_info.h **** 
  37:include/asm/thread_info.h **** 	mm_segment_t		addr_limit;	/* thread address space:
  38:include/asm/thread_info.h **** 					 	   0-0xBFFFFFFF for user-thead
  39:include/asm/thread_info.h **** 						   0-0xFFFFFFFF for kernel-thread
  40:include/asm/thread_info.h **** 						*/
  41:include/asm/thread_info.h **** 	struct restart_block    restart_block;
  42:include/asm/thread_info.h **** 
  43:include/asm/thread_info.h **** 	unsigned long           previous_esp;   /* ESP of the previous stack in case
  44:include/asm/thread_info.h **** 						   of nested (IRQ) stacks
  45:include/asm/thread_info.h **** 						*/
  46:include/asm/thread_info.h **** 	__u8			supervisor_stack[0];
  47:include/asm/thread_info.h **** };
  48:include/asm/thread_info.h **** 
  49:include/asm/thread_info.h **** #else /* !__ASSEMBLY__ */
  50:include/asm/thread_info.h **** 
  51:include/asm/thread_info.h **** #include <asm/asm_offsets.h>
  52:include/asm/thread_info.h **** 
  53:include/asm/thread_info.h **** #endif
  54:include/asm/thread_info.h **** 
  55:include/asm/thread_info.h **** #define PREEMPT_ACTIVE		0x10000000
  56:include/asm/thread_info.h **** #ifdef CONFIG_4KSTACKS
  57:include/asm/thread_info.h **** #define THREAD_SIZE            (4096)
  58:include/asm/thread_info.h **** #else
  59:include/asm/thread_info.h **** #define THREAD_SIZE		(8192)
  60:include/asm/thread_info.h **** #endif
  61:include/asm/thread_info.h **** 
  62:include/asm/thread_info.h **** #define STACK_WARN             (THREAD_SIZE/8)
  63:include/asm/thread_info.h **** /*
  64:include/asm/thread_info.h ****  * macros/functions for gaining access to the thread information structure
  65:include/asm/thread_info.h ****  *
  66:include/asm/thread_info.h ****  * preempt_count needs to be 1 initially, until the scheduler is functional.
  67:include/asm/thread_info.h ****  */
  68:include/asm/thread_info.h **** #ifndef __ASSEMBLY__
  69:include/asm/thread_info.h **** 
  70:include/asm/thread_info.h **** #define INIT_THREAD_INFO(tsk)			\
  71:include/asm/thread_info.h **** {						\
  72:include/asm/thread_info.h **** 	.task		= &tsk,			\
  73:include/asm/thread_info.h **** 	.exec_domain	= &default_exec_domain,	\
GAS LISTING  			page 59


  74:include/asm/thread_info.h **** 	.flags		= 0,			\
  75:include/asm/thread_info.h **** 	.cpu		= 0,			\
  76:include/asm/thread_info.h **** 	.preempt_count	= 1,			\
  77:include/asm/thread_info.h **** 	.addr_limit	= KERNEL_DS,		\
  78:include/asm/thread_info.h **** 	.restart_block = {			\
  79:include/asm/thread_info.h **** 		.fn = do_no_restart_syscall,	\
  80:include/asm/thread_info.h **** 	},					\
  81:include/asm/thread_info.h **** }
  82:include/asm/thread_info.h **** 
  83:include/asm/thread_info.h **** #define init_thread_info	(init_thread_union.thread_info)
  84:include/asm/thread_info.h **** #define init_stack		(init_thread_union.stack)
  85:include/asm/thread_info.h **** 
  86:include/asm/thread_info.h **** 
  87:include/asm/thread_info.h **** /* how to get the thread information struct from C */
  88:include/asm/thread_info.h **** static inline struct thread_info *current_thread_info(void)
  89:include/asm/thread_info.h **** {
  90:include/asm/thread_info.h **** 	struct thread_info *ti;
  91:include/asm/thread_info.h **** 	__asm__("andl %%esp,%0; ":"=r" (ti) : "0" (~(THREAD_SIZE - 1)));
 1458              	.loc 5 91 0
 1459 0a0a B800E0FF 	movl $-8192,%eax
 1459      FF
 1460              	
 1461 0a0f 21E0     	andl %esp,%eax
 1462              	
 1463              	.LBE127:
 1464              	.LBE126:
 1465              	.loc 5 89 0
 1466 0a11 F7401400 	testl $268435200,20(%eax)
 1466      FFFF0F
 1467 0a18 BA490000 	movl $73,%edx
 1467      00
 1468 0a1d 7514     	jne .L724
 1469 0a1f EB0D     	jmp .L723
 1470              	.L754:
 289:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 
 290:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	spin_lock_irqsave(&ieee->lock, flags);
 291:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 
 292:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	list_for_each_entry(network, &ieee->network_list, list) {
 293:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		i++;
 294:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		if (stop - ev < SCAN_ITEM_SIZE) {
 295:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 			err = -E2BIG;
 1471              	.loc 1 295 0
 1472 0a21 C7442408 	movl $-7,8(%esp)
 1472      F9FFFFFF 
 296:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 			break;
 1473              	.loc 1 296 0
 1474 0a29 E9110100 	jmp .L730
 1474      00
 1475              	.L723:
 1476              	.loc 5 89 0
 1477 0a2e BA550000 	movl $85,%edx
 1477      00
 1478              	.L724:
 1479 0a33 68000000 	pushl $__func__.0
 1479      00
 1480              	.LCFI71:
 1481 0a38 52       	pushl %edx
GAS LISTING  			page 60


 1482              	.LCFI72:
 1483 0a39 68910000 	pushl $.LC21
 1483      00
 1484              	.LCFI73:
 1485 0a3e E8FCFFFF 	call printk
 1485      FF
 1486 0a43 83C40C   	addl $12,%esp
 1487              	.LCFI74:
 1488              	.L721:
 1489              	.loc 1 290 0
 1490              	
 1491 0a46 9C8F4424 	pushfl
 1491      0CFA
 1492              	
 1493              	.LBB128:
 1494              	.loc 1 292 0
 1495 0a4c 8B85DC05 	movl 1500(%ebp),%eax
 1495      0000
 1496              	.LBE128:
 1497 0a52 8DB0B0FE 	leal -336(%eax),%esi
 1497      FFFF
 1498              	.LBB129:
 1499              	.file 6 "include/asm/processor.h"
   1:include/asm/processor.h **** /*
   2:include/asm/processor.h ****  * include/asm-i386/processor.h
   3:include/asm/processor.h ****  *
   4:include/asm/processor.h ****  * Copyright (C) 1994 Linus Torvalds
   5:include/asm/processor.h ****  */
   6:include/asm/processor.h **** 
   7:include/asm/processor.h **** #ifndef __ASM_I386_PROCESSOR_H
   8:include/asm/processor.h **** #define __ASM_I386_PROCESSOR_H
   9:include/asm/processor.h **** 
  10:include/asm/processor.h **** #include <asm/vm86.h>
  11:include/asm/processor.h **** #include <asm/math_emu.h>
  12:include/asm/processor.h **** #include <asm/segment.h>
  13:include/asm/processor.h **** #include <asm/page.h>
  14:include/asm/processor.h **** #include <asm/types.h>
  15:include/asm/processor.h **** #include <asm/sigcontext.h>
  16:include/asm/processor.h **** #include <asm/cpufeature.h>
  17:include/asm/processor.h **** #include <asm/msr.h>
  18:include/asm/processor.h **** #include <asm/system.h>
  19:include/asm/processor.h **** #include <linux/cache.h>
  20:include/asm/processor.h **** #include <linux/config.h>
  21:include/asm/processor.h **** #include <linux/threads.h>
  22:include/asm/processor.h **** #include <asm/percpu.h>
  23:include/asm/processor.h **** 
  24:include/asm/processor.h **** /* flag for disabling the tsc */
  25:include/asm/processor.h **** extern int tsc_disable;
  26:include/asm/processor.h **** 
  27:include/asm/processor.h **** struct desc_struct {
  28:include/asm/processor.h **** 	unsigned long a,b;
  29:include/asm/processor.h **** };
  30:include/asm/processor.h **** 
  31:include/asm/processor.h **** #define desc_empty(desc) \
  32:include/asm/processor.h **** 		(!((desc)->a + (desc)->b))
  33:include/asm/processor.h **** 
  34:include/asm/processor.h **** #define desc_equal(desc1, desc2) \
GAS LISTING  			page 61


  35:include/asm/processor.h **** 		(((desc1)->a == (desc2)->a) && ((desc1)->b == (desc2)->b))
  36:include/asm/processor.h **** /*
  37:include/asm/processor.h ****  * Default implementation of macro that returns current
  38:include/asm/processor.h ****  * instruction pointer ("program counter").
  39:include/asm/processor.h ****  */
  40:include/asm/processor.h **** #define current_text_addr() ({ void *pc; __asm__("movl $1f,%0\n1:":"=g" (pc)); pc; })
  41:include/asm/processor.h **** 
  42:include/asm/processor.h **** /*
  43:include/asm/processor.h ****  *  CPU type and hardware bug flags. Kept separately for each CPU.
  44:include/asm/processor.h ****  *  Members of this structure are referenced in head.S, so think twice
  45:include/asm/processor.h ****  *  before touching them. [mj]
  46:include/asm/processor.h ****  */
  47:include/asm/processor.h **** 
  48:include/asm/processor.h **** struct cpuinfo_x86 {
  49:include/asm/processor.h **** 	__u8	x86;		/* CPU family */
  50:include/asm/processor.h **** 	__u8	x86_vendor;	/* CPU vendor */
  51:include/asm/processor.h **** 	__u8	x86_model;
  52:include/asm/processor.h **** 	__u8	x86_mask;
  53:include/asm/processor.h **** 	char	wp_works_ok;	/* It doesn't on 386's */
  54:include/asm/processor.h **** 	char	hlt_works_ok;	/* Problems on some 486Dx4's and old 386's */
  55:include/asm/processor.h **** 	char	hard_math;
  56:include/asm/processor.h **** 	char	rfu;
  57:include/asm/processor.h ****        	int	cpuid_level;	/* Maximum supported CPUID level, -1=no CPUID */
  58:include/asm/processor.h **** 	unsigned long	x86_capability[NCAPINTS];
  59:include/asm/processor.h **** 	char	x86_vendor_id[16];
  60:include/asm/processor.h **** 	char	x86_model_id[64];
  61:include/asm/processor.h **** 	int 	x86_cache_size;  /* in KB - valid for CPUS which support this
  62:include/asm/processor.h **** 				    call  */
  63:include/asm/processor.h **** 	int 	x86_cache_alignment;	/* In bytes */
  64:include/asm/processor.h **** 	int	fdiv_bug;
  65:include/asm/processor.h **** 	int	f00f_bug;
  66:include/asm/processor.h **** 	int	coma_bug;
  67:include/asm/processor.h **** 	unsigned long loops_per_jiffy;
  68:include/asm/processor.h **** 	unsigned char x86_num_cores;
  69:include/asm/processor.h **** } __attribute__((__aligned__(SMP_CACHE_BYTES)));
  70:include/asm/processor.h **** 
  71:include/asm/processor.h **** #define X86_VENDOR_INTEL 0
  72:include/asm/processor.h **** #define X86_VENDOR_CYRIX 1
  73:include/asm/processor.h **** #define X86_VENDOR_AMD 2
  74:include/asm/processor.h **** #define X86_VENDOR_UMC 3
  75:include/asm/processor.h **** #define X86_VENDOR_NEXGEN 4
  76:include/asm/processor.h **** #define X86_VENDOR_CENTAUR 5
  77:include/asm/processor.h **** #define X86_VENDOR_RISE 6
  78:include/asm/processor.h **** #define X86_VENDOR_TRANSMETA 7
  79:include/asm/processor.h **** #define X86_VENDOR_NSC 8
  80:include/asm/processor.h **** #define X86_VENDOR_NUM 9
  81:include/asm/processor.h **** #define X86_VENDOR_UNKNOWN 0xff
  82:include/asm/processor.h **** 
  83:include/asm/processor.h **** /*
  84:include/asm/processor.h ****  * capabilities of CPUs
  85:include/asm/processor.h ****  */
  86:include/asm/processor.h **** 
  87:include/asm/processor.h **** extern struct cpuinfo_x86 boot_cpu_data;
  88:include/asm/processor.h **** extern struct cpuinfo_x86 new_cpu_data;
  89:include/asm/processor.h **** extern struct tss_struct doublefault_tss;
  90:include/asm/processor.h **** DECLARE_PER_CPU(struct tss_struct, init_tss);
  91:include/asm/processor.h **** 
GAS LISTING  			page 62


  92:include/asm/processor.h **** #ifdef CONFIG_SMP
  93:include/asm/processor.h **** extern struct cpuinfo_x86 cpu_data[];
  94:include/asm/processor.h **** #define current_cpu_data cpu_data[smp_processor_id()]
  95:include/asm/processor.h **** #else
  96:include/asm/processor.h **** #define cpu_data (&boot_cpu_data)
  97:include/asm/processor.h **** #define current_cpu_data boot_cpu_data
  98:include/asm/processor.h **** #endif
  99:include/asm/processor.h **** 
 100:include/asm/processor.h **** extern	int phys_proc_id[NR_CPUS];
 101:include/asm/processor.h **** extern	int cpu_core_id[NR_CPUS];
 102:include/asm/processor.h **** extern char ignore_fpu_irq;
 103:include/asm/processor.h **** 
 104:include/asm/processor.h **** extern void identify_cpu(struct cpuinfo_x86 *);
 105:include/asm/processor.h **** extern void print_cpu_info(struct cpuinfo_x86 *);
 106:include/asm/processor.h **** extern unsigned int init_intel_cacheinfo(struct cpuinfo_x86 *c);
 107:include/asm/processor.h **** 
 108:include/asm/processor.h **** #ifdef CONFIG_X86_HT
 109:include/asm/processor.h **** extern void detect_ht(struct cpuinfo_x86 *c);
 110:include/asm/processor.h **** #else
 111:include/asm/processor.h **** static inline void detect_ht(struct cpuinfo_x86 *c) {}
 112:include/asm/processor.h **** #endif
 113:include/asm/processor.h **** 
 114:include/asm/processor.h **** /*
 115:include/asm/processor.h ****  * EFLAGS bits
 116:include/asm/processor.h ****  */
 117:include/asm/processor.h **** #define X86_EFLAGS_CF	0x00000001 /* Carry Flag */
 118:include/asm/processor.h **** #define X86_EFLAGS_PF	0x00000004 /* Parity Flag */
 119:include/asm/processor.h **** #define X86_EFLAGS_AF	0x00000010 /* Auxillary carry Flag */
 120:include/asm/processor.h **** #define X86_EFLAGS_ZF	0x00000040 /* Zero Flag */
 121:include/asm/processor.h **** #define X86_EFLAGS_SF	0x00000080 /* Sign Flag */
 122:include/asm/processor.h **** #define X86_EFLAGS_TF	0x00000100 /* Trap Flag */
 123:include/asm/processor.h **** #define X86_EFLAGS_IF	0x00000200 /* Interrupt Flag */
 124:include/asm/processor.h **** #define X86_EFLAGS_DF	0x00000400 /* Direction Flag */
 125:include/asm/processor.h **** #define X86_EFLAGS_OF	0x00000800 /* Overflow Flag */
 126:include/asm/processor.h **** #define X86_EFLAGS_IOPL	0x00003000 /* IOPL mask */
 127:include/asm/processor.h **** #define X86_EFLAGS_NT	0x00004000 /* Nested Task */
 128:include/asm/processor.h **** #define X86_EFLAGS_RF	0x00010000 /* Resume Flag */
 129:include/asm/processor.h **** #define X86_EFLAGS_VM	0x00020000 /* Virtual Mode */
 130:include/asm/processor.h **** #define X86_EFLAGS_AC	0x00040000 /* Alignment Check */
 131:include/asm/processor.h **** #define X86_EFLAGS_VIF	0x00080000 /* Virtual Interrupt Flag */
 132:include/asm/processor.h **** #define X86_EFLAGS_VIP	0x00100000 /* Virtual Interrupt Pending */
 133:include/asm/processor.h **** #define X86_EFLAGS_ID	0x00200000 /* CPUID detection flag */
 134:include/asm/processor.h **** 
 135:include/asm/processor.h **** /*
 136:include/asm/processor.h ****  * Generic CPUID function
 137:include/asm/processor.h ****  * clear %ecx since some cpus (Cyrix MII) do not set or clear %ecx
 138:include/asm/processor.h ****  * resulting in stale register contents being returned.
 139:include/asm/processor.h ****  */
 140:include/asm/processor.h **** static inline void cpuid(unsigned int op, unsigned int *eax, unsigned int *ebx, unsigned int *ecx, 
 141:include/asm/processor.h **** {
 142:include/asm/processor.h **** 	__asm__("cpuid"
 143:include/asm/processor.h **** 		: "=a" (*eax),
 144:include/asm/processor.h **** 		  "=b" (*ebx),
 145:include/asm/processor.h **** 		  "=c" (*ecx),
 146:include/asm/processor.h **** 		  "=d" (*edx)
 147:include/asm/processor.h **** 		: "0" (op), "c"(0));
 148:include/asm/processor.h **** }
GAS LISTING  			page 63


 149:include/asm/processor.h **** 
 150:include/asm/processor.h **** /* Some CPUID calls want 'count' to be placed in ecx */
 151:include/asm/processor.h **** static inline void cpuid_count(int op, int count, int *eax, int *ebx, int *ecx,
 152:include/asm/processor.h **** 	       	int *edx)
 153:include/asm/processor.h **** {
 154:include/asm/processor.h **** 	__asm__("cpuid"
 155:include/asm/processor.h **** 		: "=a" (*eax),
 156:include/asm/processor.h **** 		  "=b" (*ebx),
 157:include/asm/processor.h **** 		  "=c" (*ecx),
 158:include/asm/processor.h **** 		  "=d" (*edx)
 159:include/asm/processor.h **** 		: "0" (op), "c" (count));
 160:include/asm/processor.h **** }
 161:include/asm/processor.h **** 
 162:include/asm/processor.h **** /*
 163:include/asm/processor.h ****  * CPUID functions returning a single datum
 164:include/asm/processor.h ****  */
 165:include/asm/processor.h **** static inline unsigned int cpuid_eax(unsigned int op)
 166:include/asm/processor.h **** {
 167:include/asm/processor.h **** 	unsigned int eax;
 168:include/asm/processor.h **** 
 169:include/asm/processor.h **** 	__asm__("cpuid"
 170:include/asm/processor.h **** 		: "=a" (eax)
 171:include/asm/processor.h **** 		: "0" (op)
 172:include/asm/processor.h **** 		: "bx", "cx", "dx");
 173:include/asm/processor.h **** 	return eax;
 174:include/asm/processor.h **** }
 175:include/asm/processor.h **** static inline unsigned int cpuid_ebx(unsigned int op)
 176:include/asm/processor.h **** {
 177:include/asm/processor.h **** 	unsigned int eax, ebx;
 178:include/asm/processor.h **** 
 179:include/asm/processor.h **** 	__asm__("cpuid"
 180:include/asm/processor.h **** 		: "=a" (eax), "=b" (ebx)
 181:include/asm/processor.h **** 		: "0" (op)
 182:include/asm/processor.h **** 		: "cx", "dx" );
 183:include/asm/processor.h **** 	return ebx;
 184:include/asm/processor.h **** }
 185:include/asm/processor.h **** static inline unsigned int cpuid_ecx(unsigned int op)
 186:include/asm/processor.h **** {
 187:include/asm/processor.h **** 	unsigned int eax, ecx;
 188:include/asm/processor.h **** 
 189:include/asm/processor.h **** 	__asm__("cpuid"
 190:include/asm/processor.h **** 		: "=a" (eax), "=c" (ecx)
 191:include/asm/processor.h **** 		: "0" (op)
 192:include/asm/processor.h **** 		: "bx", "dx" );
 193:include/asm/processor.h **** 	return ecx;
 194:include/asm/processor.h **** }
 195:include/asm/processor.h **** static inline unsigned int cpuid_edx(unsigned int op)
 196:include/asm/processor.h **** {
 197:include/asm/processor.h **** 	unsigned int eax, edx;
 198:include/asm/processor.h **** 
 199:include/asm/processor.h **** 	__asm__("cpuid"
 200:include/asm/processor.h **** 		: "=a" (eax), "=d" (edx)
 201:include/asm/processor.h **** 		: "0" (op)
 202:include/asm/processor.h **** 		: "bx", "cx");
 203:include/asm/processor.h **** 	return edx;
 204:include/asm/processor.h **** }
 205:include/asm/processor.h **** 
GAS LISTING  			page 64


 206:include/asm/processor.h **** #define load_cr3(pgdir) \
 207:include/asm/processor.h **** 	asm volatile("movl %0,%%cr3": :"r" (__pa(pgdir)))
 208:include/asm/processor.h **** 
 209:include/asm/processor.h **** 
 210:include/asm/processor.h **** /*
 211:include/asm/processor.h ****  * Intel CPU features in CR4
 212:include/asm/processor.h ****  */
 213:include/asm/processor.h **** #define X86_CR4_VME		0x0001	/* enable vm86 extensions */
 214:include/asm/processor.h **** #define X86_CR4_PVI		0x0002	/* virtual interrupts flag enable */
 215:include/asm/processor.h **** #define X86_CR4_TSD		0x0004	/* disable time stamp at ipl 3 */
 216:include/asm/processor.h **** #define X86_CR4_DE		0x0008	/* enable debugging extensions */
 217:include/asm/processor.h **** #define X86_CR4_PSE		0x0010	/* enable page size extensions */
 218:include/asm/processor.h **** #define X86_CR4_PAE		0x0020	/* enable physical address extensions */
 219:include/asm/processor.h **** #define X86_CR4_MCE		0x0040	/* Machine check enable */
 220:include/asm/processor.h **** #define X86_CR4_PGE		0x0080	/* enable global pages */
 221:include/asm/processor.h **** #define X86_CR4_PCE		0x0100	/* enable performance counters at ipl 3 */
 222:include/asm/processor.h **** #define X86_CR4_OSFXSR		0x0200	/* enable fast FPU save and restore */
 223:include/asm/processor.h **** #define X86_CR4_OSXMMEXCPT	0x0400	/* enable unmasked SSE exceptions */
 224:include/asm/processor.h **** 
 225:include/asm/processor.h **** /*
 226:include/asm/processor.h ****  * Save the cr4 feature set we're using (ie
 227:include/asm/processor.h ****  * Pentium 4MB enable and PPro Global page
 228:include/asm/processor.h ****  * enable), so that any CPU's that boot up
 229:include/asm/processor.h ****  * after us can get the correct flags.
 230:include/asm/processor.h ****  */
 231:include/asm/processor.h **** extern unsigned long mmu_cr4_features;
 232:include/asm/processor.h **** 
 233:include/asm/processor.h **** static inline void set_in_cr4 (unsigned long mask)
 234:include/asm/processor.h **** {
 235:include/asm/processor.h **** 	mmu_cr4_features |= mask;
 236:include/asm/processor.h **** 	__asm__("movl %%cr4,%%eax\n\t"
 237:include/asm/processor.h **** 		"orl %0,%%eax\n\t"
 238:include/asm/processor.h **** 		"movl %%eax,%%cr4\n"
 239:include/asm/processor.h **** 		: : "irg" (mask)
 240:include/asm/processor.h **** 		:"ax");
 241:include/asm/processor.h **** }
 242:include/asm/processor.h **** 
 243:include/asm/processor.h **** static inline void clear_in_cr4 (unsigned long mask)
 244:include/asm/processor.h **** {
 245:include/asm/processor.h **** 	mmu_cr4_features &= ~mask;
 246:include/asm/processor.h **** 	__asm__("movl %%cr4,%%eax\n\t"
 247:include/asm/processor.h **** 		"andl %0,%%eax\n\t"
 248:include/asm/processor.h **** 		"movl %%eax,%%cr4\n"
 249:include/asm/processor.h **** 		: : "irg" (~mask)
 250:include/asm/processor.h **** 		:"ax");
 251:include/asm/processor.h **** }
 252:include/asm/processor.h **** 
 253:include/asm/processor.h **** /*
 254:include/asm/processor.h ****  *      NSC/Cyrix CPU configuration register indexes
 255:include/asm/processor.h ****  */
 256:include/asm/processor.h **** 
 257:include/asm/processor.h **** #define CX86_PCR0 0x20
 258:include/asm/processor.h **** #define CX86_GCR  0xb8
 259:include/asm/processor.h **** #define CX86_CCR0 0xc0
 260:include/asm/processor.h **** #define CX86_CCR1 0xc1
 261:include/asm/processor.h **** #define CX86_CCR2 0xc2
 262:include/asm/processor.h **** #define CX86_CCR3 0xc3
GAS LISTING  			page 65


 263:include/asm/processor.h **** #define CX86_CCR4 0xe8
 264:include/asm/processor.h **** #define CX86_CCR5 0xe9
 265:include/asm/processor.h **** #define CX86_CCR6 0xea
 266:include/asm/processor.h **** #define CX86_CCR7 0xeb
 267:include/asm/processor.h **** #define CX86_PCR1 0xf0
 268:include/asm/processor.h **** #define CX86_DIR0 0xfe
 269:include/asm/processor.h **** #define CX86_DIR1 0xff
 270:include/asm/processor.h **** #define CX86_ARR_BASE 0xc4
 271:include/asm/processor.h **** #define CX86_RCR_BASE 0xdc
 272:include/asm/processor.h **** 
 273:include/asm/processor.h **** /*
 274:include/asm/processor.h ****  *      NSC/Cyrix CPU indexed register access macros
 275:include/asm/processor.h ****  */
 276:include/asm/processor.h **** 
 277:include/asm/processor.h **** #define getCx86(reg) ({ outb((reg), 0x22); inb(0x23); })
 278:include/asm/processor.h **** 
 279:include/asm/processor.h **** #define setCx86(reg, data) do { \
 280:include/asm/processor.h **** 	outb((reg), 0x22); \
 281:include/asm/processor.h **** 	outb((data), 0x23); \
 282:include/asm/processor.h **** } while (0)
 283:include/asm/processor.h **** 
 284:include/asm/processor.h **** static inline void __monitor(const void *eax, unsigned long ecx,
 285:include/asm/processor.h **** 		unsigned long edx)
 286:include/asm/processor.h **** {
 287:include/asm/processor.h **** 	/* "monitor %eax,%ecx,%edx;" */
 288:include/asm/processor.h **** 	asm volatile(
 289:include/asm/processor.h **** 		".byte 0x0f,0x01,0xc8;"
 290:include/asm/processor.h **** 		: :"a" (eax), "c" (ecx), "d"(edx));
 291:include/asm/processor.h **** }
 292:include/asm/processor.h **** 
 293:include/asm/processor.h **** static inline void __mwait(unsigned long eax, unsigned long ecx)
 294:include/asm/processor.h **** {
 295:include/asm/processor.h **** 	/* "mwait %eax,%ecx;" */
 296:include/asm/processor.h **** 	asm volatile(
 297:include/asm/processor.h **** 		".byte 0x0f,0x01,0xc9;"
 298:include/asm/processor.h **** 		: :"a" (eax), "c" (ecx));
 299:include/asm/processor.h **** }
 300:include/asm/processor.h **** 
 301:include/asm/processor.h **** /* from system description table in BIOS.  Mostly for MCA use, but
 302:include/asm/processor.h **** others may find it useful. */
 303:include/asm/processor.h **** extern unsigned int machine_id;
 304:include/asm/processor.h **** extern unsigned int machine_submodel_id;
 305:include/asm/processor.h **** extern unsigned int BIOS_revision;
 306:include/asm/processor.h **** extern unsigned int mca_pentium_flag;
 307:include/asm/processor.h **** 
 308:include/asm/processor.h **** /* Boot loader type from the setup header */
 309:include/asm/processor.h **** extern int bootloader_type;
 310:include/asm/processor.h **** 
 311:include/asm/processor.h **** /*
 312:include/asm/processor.h ****  * User space process size: 3GB (default).
 313:include/asm/processor.h ****  */
 314:include/asm/processor.h **** #define TASK_SIZE	(PAGE_OFFSET)
 315:include/asm/processor.h **** 
 316:include/asm/processor.h **** /* This decides where the kernel will search for a free chunk of vm
 317:include/asm/processor.h ****  * space during mmap's.
 318:include/asm/processor.h ****  */
 319:include/asm/processor.h **** #define TASK_UNMAPPED_BASE	(PAGE_ALIGN(TASK_SIZE / 3))
GAS LISTING  			page 66


 320:include/asm/processor.h **** 
 321:include/asm/processor.h **** #define HAVE_ARCH_PICK_MMAP_LAYOUT
 322:include/asm/processor.h **** 
 323:include/asm/processor.h **** /*
 324:include/asm/processor.h ****  * Size of io_bitmap.
 325:include/asm/processor.h ****  */
 326:include/asm/processor.h **** #define IO_BITMAP_BITS  65536
 327:include/asm/processor.h **** #define IO_BITMAP_BYTES (IO_BITMAP_BITS/8)
 328:include/asm/processor.h **** #define IO_BITMAP_LONGS (IO_BITMAP_BYTES/sizeof(long))
 329:include/asm/processor.h **** #define IO_BITMAP_OFFSET offsetof(struct tss_struct,io_bitmap)
 330:include/asm/processor.h **** #define INVALID_IO_BITMAP_OFFSET 0x8000
 331:include/asm/processor.h **** #define INVALID_IO_BITMAP_OFFSET_LAZY 0x9000
 332:include/asm/processor.h **** 
 333:include/asm/processor.h **** struct i387_fsave_struct {
 334:include/asm/processor.h **** 	long	cwd;
 335:include/asm/processor.h **** 	long	swd;
 336:include/asm/processor.h **** 	long	twd;
 337:include/asm/processor.h **** 	long	fip;
 338:include/asm/processor.h **** 	long	fcs;
 339:include/asm/processor.h **** 	long	foo;
 340:include/asm/processor.h **** 	long	fos;
 341:include/asm/processor.h **** 	long	st_space[20];	/* 8*10 bytes for each FP-reg = 80 bytes */
 342:include/asm/processor.h **** 	long	status;		/* software status information */
 343:include/asm/processor.h **** };
 344:include/asm/processor.h **** 
 345:include/asm/processor.h **** struct i387_fxsave_struct {
 346:include/asm/processor.h **** 	unsigned short	cwd;
 347:include/asm/processor.h **** 	unsigned short	swd;
 348:include/asm/processor.h **** 	unsigned short	twd;
 349:include/asm/processor.h **** 	unsigned short	fop;
 350:include/asm/processor.h **** 	long	fip;
 351:include/asm/processor.h **** 	long	fcs;
 352:include/asm/processor.h **** 	long	foo;
 353:include/asm/processor.h **** 	long	fos;
 354:include/asm/processor.h **** 	long	mxcsr;
 355:include/asm/processor.h **** 	long	mxcsr_mask;
 356:include/asm/processor.h **** 	long	st_space[32];	/* 8*16 bytes for each FP-reg = 128 bytes */
 357:include/asm/processor.h **** 	long	xmm_space[32];	/* 8*16 bytes for each XMM-reg = 128 bytes */
 358:include/asm/processor.h **** 	long	padding[56];
 359:include/asm/processor.h **** } __attribute__ ((aligned (16)));
 360:include/asm/processor.h **** 
 361:include/asm/processor.h **** struct i387_soft_struct {
 362:include/asm/processor.h **** 	long	cwd;
 363:include/asm/processor.h **** 	long	swd;
 364:include/asm/processor.h **** 	long	twd;
 365:include/asm/processor.h **** 	long	fip;
 366:include/asm/processor.h **** 	long	fcs;
 367:include/asm/processor.h **** 	long	foo;
 368:include/asm/processor.h **** 	long	fos;
 369:include/asm/processor.h **** 	long	st_space[20];	/* 8*10 bytes for each FP-reg = 80 bytes */
 370:include/asm/processor.h **** 	unsigned char	ftop, changed, lookahead, no_update, rm, alimit;
 371:include/asm/processor.h **** 	struct info	*info;
 372:include/asm/processor.h **** 	unsigned long	entry_eip;
 373:include/asm/processor.h **** };
 374:include/asm/processor.h **** 
 375:include/asm/processor.h **** union i387_union {
 376:include/asm/processor.h **** 	struct i387_fsave_struct	fsave;
GAS LISTING  			page 67


 377:include/asm/processor.h **** 	struct i387_fxsave_struct	fxsave;
 378:include/asm/processor.h **** 	struct i387_soft_struct soft;
 379:include/asm/processor.h **** };
 380:include/asm/processor.h **** 
 381:include/asm/processor.h **** typedef struct {
 382:include/asm/processor.h **** 	unsigned long seg;
 383:include/asm/processor.h **** } mm_segment_t;
 384:include/asm/processor.h **** 
 385:include/asm/processor.h **** struct thread_struct;
 386:include/asm/processor.h **** 
 387:include/asm/processor.h **** struct tss_struct {
 388:include/asm/processor.h **** 	unsigned short	back_link,__blh;
 389:include/asm/processor.h **** 	unsigned long	esp0;
 390:include/asm/processor.h **** 	unsigned short	ss0,__ss0h;
 391:include/asm/processor.h **** 	unsigned long	esp1;
 392:include/asm/processor.h **** 	unsigned short	ss1,__ss1h;	/* ss1 is used to cache MSR_IA32_SYSENTER_CS */
 393:include/asm/processor.h **** 	unsigned long	esp2;
 394:include/asm/processor.h **** 	unsigned short	ss2,__ss2h;
 395:include/asm/processor.h **** 	unsigned long	__cr3;
 396:include/asm/processor.h **** 	unsigned long	eip;
 397:include/asm/processor.h **** 	unsigned long	eflags;
 398:include/asm/processor.h **** 	unsigned long	eax,ecx,edx,ebx;
 399:include/asm/processor.h **** 	unsigned long	esp;
 400:include/asm/processor.h **** 	unsigned long	ebp;
 401:include/asm/processor.h **** 	unsigned long	esi;
 402:include/asm/processor.h **** 	unsigned long	edi;
 403:include/asm/processor.h **** 	unsigned short	es, __esh;
 404:include/asm/processor.h **** 	unsigned short	cs, __csh;
 405:include/asm/processor.h **** 	unsigned short	ss, __ssh;
 406:include/asm/processor.h **** 	unsigned short	ds, __dsh;
 407:include/asm/processor.h **** 	unsigned short	fs, __fsh;
 408:include/asm/processor.h **** 	unsigned short	gs, __gsh;
 409:include/asm/processor.h **** 	unsigned short	ldt, __ldth;
 410:include/asm/processor.h **** 	unsigned short	trace, io_bitmap_base;
 411:include/asm/processor.h **** 	/*
 412:include/asm/processor.h **** 	 * The extra 1 is there because the CPU will access an
 413:include/asm/processor.h **** 	 * additional byte beyond the end of the IO permission
 414:include/asm/processor.h **** 	 * bitmap. The extra byte must be all 1 bits, and must
 415:include/asm/processor.h **** 	 * be within the limit.
 416:include/asm/processor.h **** 	 */
 417:include/asm/processor.h **** 	unsigned long	io_bitmap[IO_BITMAP_LONGS + 1];
 418:include/asm/processor.h **** 	/*
 419:include/asm/processor.h **** 	 * Cache the current maximum and the last task that used the bitmap:
 420:include/asm/processor.h **** 	 */
 421:include/asm/processor.h **** 	unsigned long io_bitmap_max;
 422:include/asm/processor.h **** 	struct thread_struct *io_bitmap_owner;
 423:include/asm/processor.h **** 	/*
 424:include/asm/processor.h **** 	 * pads the TSS to be cacheline-aligned (size is 0x100)
 425:include/asm/processor.h **** 	 */
 426:include/asm/processor.h **** 	unsigned long __cacheline_filler[35];
 427:include/asm/processor.h **** 	/*
 428:include/asm/processor.h **** 	 * .. and then another 0x100 bytes for emergency kernel stack
 429:include/asm/processor.h **** 	 */
 430:include/asm/processor.h **** 	unsigned long stack[64];
 431:include/asm/processor.h **** } __attribute__((packed));
 432:include/asm/processor.h **** 
 433:include/asm/processor.h **** #define ARCH_MIN_TASKALIGN	16
GAS LISTING  			page 68


 434:include/asm/processor.h **** 
 435:include/asm/processor.h **** struct thread_struct {
 436:include/asm/processor.h **** /* cached TLS descriptors. */
 437:include/asm/processor.h **** 	struct desc_struct tls_array[GDT_ENTRY_TLS_ENTRIES];
 438:include/asm/processor.h **** 	unsigned long	esp0;
 439:include/asm/processor.h **** 	unsigned long	sysenter_cs;
 440:include/asm/processor.h **** 	unsigned long	eip;
 441:include/asm/processor.h **** 	unsigned long	esp;
 442:include/asm/processor.h **** 	unsigned long	fs;
 443:include/asm/processor.h **** 	unsigned long	gs;
 444:include/asm/processor.h **** /* Hardware debugging registers */
 445:include/asm/processor.h **** 	unsigned long	debugreg[8];  /* %%db0-7 debug registers */
 446:include/asm/processor.h **** /* fault info */
 447:include/asm/processor.h **** 	unsigned long	cr2, trap_no, error_code;
 448:include/asm/processor.h **** /* floating point info */
 449:include/asm/processor.h **** 	union i387_union	i387;
 450:include/asm/processor.h **** /* virtual 86 mode info */
 451:include/asm/processor.h **** 	struct vm86_struct __user * vm86_info;
 452:include/asm/processor.h **** 	unsigned long		screen_bitmap;
 453:include/asm/processor.h **** 	unsigned long		v86flags, v86mask, saved_esp0;
 454:include/asm/processor.h **** 	unsigned int		saved_fs, saved_gs;
 455:include/asm/processor.h **** /* IO permissions */
 456:include/asm/processor.h **** 	unsigned long	*io_bitmap_ptr;
 457:include/asm/processor.h **** /* max allowed port in the bitmap, in bytes: */
 458:include/asm/processor.h **** 	unsigned long	io_bitmap_max;
 459:include/asm/processor.h **** };
 460:include/asm/processor.h **** 
 461:include/asm/processor.h **** #define INIT_THREAD  {							\
 462:include/asm/processor.h **** 	.vm86_info = NULL,						\
 463:include/asm/processor.h **** 	.sysenter_cs = __KERNEL_CS,					\
 464:include/asm/processor.h **** 	.io_bitmap_ptr = NULL,						\
 465:include/asm/processor.h **** }
 466:include/asm/processor.h **** 
 467:include/asm/processor.h **** /*
 468:include/asm/processor.h ****  * Note that the .io_bitmap member must be extra-big. This is because
 469:include/asm/processor.h ****  * the CPU will access an additional byte beyond the end of the IO
 470:include/asm/processor.h ****  * permission bitmap. The extra byte must be all 1 bits, and must
 471:include/asm/processor.h ****  * be within the limit.
 472:include/asm/processor.h ****  */
 473:include/asm/processor.h **** #define INIT_TSS  {							\
 474:include/asm/processor.h **** 	.esp0		= sizeof(init_stack) + (long)&init_stack,	\
 475:include/asm/processor.h **** 	.ss0		= __KERNEL_DS,					\
 476:include/asm/processor.h **** 	.ss1		= __KERNEL_CS,					\
 477:include/asm/processor.h **** 	.ldt		= GDT_ENTRY_LDT,				\
 478:include/asm/processor.h **** 	.io_bitmap_base	= INVALID_IO_BITMAP_OFFSET,			\
 479:include/asm/processor.h **** 	.io_bitmap	= { [ 0 ... IO_BITMAP_LONGS] = ~0 },		\
 480:include/asm/processor.h **** }
 481:include/asm/processor.h **** 
 482:include/asm/processor.h **** static inline void load_esp0(struct tss_struct *tss, struct thread_struct *thread)
 483:include/asm/processor.h **** {
 484:include/asm/processor.h **** 	tss->esp0 = thread->esp0;
 485:include/asm/processor.h **** 	/* This can only happen when SEP is enabled, no need to test "SEP"arately */
 486:include/asm/processor.h **** 	if (unlikely(tss->ss1 != thread->sysenter_cs)) {
 487:include/asm/processor.h **** 		tss->ss1 = thread->sysenter_cs;
 488:include/asm/processor.h **** 		wrmsr(MSR_IA32_SYSENTER_CS, thread->sysenter_cs, 0);
 489:include/asm/processor.h **** 	}
 490:include/asm/processor.h **** }
GAS LISTING  			page 69


 491:include/asm/processor.h **** 
 492:include/asm/processor.h **** #define start_thread(regs, new_eip, new_esp) do {		\
 493:include/asm/processor.h **** 	__asm__("movl %0,%%fs ; movl %0,%%gs": :"r" (0));	\
 494:include/asm/processor.h **** 	set_fs(USER_DS);					\
 495:include/asm/processor.h **** 	regs->xds = __USER_DS;					\
 496:include/asm/processor.h **** 	regs->xes = __USER_DS;					\
 497:include/asm/processor.h **** 	regs->xss = __USER_DS;					\
 498:include/asm/processor.h **** 	regs->xcs = __USER_CS;					\
 499:include/asm/processor.h **** 	regs->eip = new_eip;					\
 500:include/asm/processor.h **** 	regs->esp = new_esp;					\
 501:include/asm/processor.h **** } while (0)
 502:include/asm/processor.h **** 
 503:include/asm/processor.h **** /*
 504:include/asm/processor.h ****  * This special macro can be used to load a debugging register
 505:include/asm/processor.h ****  */
 506:include/asm/processor.h **** #define loaddebug(thread,register) \
 507:include/asm/processor.h ****                __asm__("movl %0,%%db" #register  \
 508:include/asm/processor.h ****                        : /* no output */ \
 509:include/asm/processor.h ****                        :"r" ((thread)->debugreg[register]))
 510:include/asm/processor.h **** 
 511:include/asm/processor.h **** /* Forward declaration, a strange C thing */
 512:include/asm/processor.h **** struct task_struct;
 513:include/asm/processor.h **** struct mm_struct;
 514:include/asm/processor.h **** 
 515:include/asm/processor.h **** /* Free all resources held by a thread. */
 516:include/asm/processor.h **** extern void release_thread(struct task_struct *);
 517:include/asm/processor.h **** 
 518:include/asm/processor.h **** /* Prepare to copy thread state - unlazy all lazy status */
 519:include/asm/processor.h **** extern void prepare_to_copy(struct task_struct *tsk);
 520:include/asm/processor.h **** 
 521:include/asm/processor.h **** /*
 522:include/asm/processor.h ****  * create a kernel thread without removing it from tasklists
 523:include/asm/processor.h ****  */
 524:include/asm/processor.h **** extern int kernel_thread(int (*fn)(void *), void * arg, unsigned long flags);
 525:include/asm/processor.h **** 
 526:include/asm/processor.h **** extern unsigned long thread_saved_pc(struct task_struct *tsk);
 527:include/asm/processor.h **** void show_trace(struct task_struct *task, unsigned long *stack);
 528:include/asm/processor.h **** 
 529:include/asm/processor.h **** unsigned long get_wchan(struct task_struct *p);
 530:include/asm/processor.h **** 
 531:include/asm/processor.h **** #define THREAD_SIZE_LONGS      (THREAD_SIZE/sizeof(unsigned long))
 532:include/asm/processor.h **** #define KSTK_TOP(info)                                                 \
 533:include/asm/processor.h **** ({                                                                     \
 534:include/asm/processor.h ****        unsigned long *__ptr = (unsigned long *)(info);                 \
 535:include/asm/processor.h ****        (unsigned long)(&__ptr[THREAD_SIZE_LONGS]);                     \
 536:include/asm/processor.h **** })
 537:include/asm/processor.h **** 
 538:include/asm/processor.h **** #define task_pt_regs(task)                                             \
 539:include/asm/processor.h **** ({                                                                     \
 540:include/asm/processor.h ****        struct pt_regs *__regs__;                                       \
 541:include/asm/processor.h ****        __regs__ = (struct pt_regs *)KSTK_TOP((task)->thread_info);     \
 542:include/asm/processor.h ****        __regs__ - 1;                                                   \
 543:include/asm/processor.h **** })
 544:include/asm/processor.h **** 
 545:include/asm/processor.h **** #define KSTK_EIP(task) (task_pt_regs(task)->eip)
 546:include/asm/processor.h **** #define KSTK_ESP(task) (task_pt_regs(task)->esp)
 547:include/asm/processor.h **** 
GAS LISTING  			page 70


 548:include/asm/processor.h **** 
 549:include/asm/processor.h **** struct microcode_header {
 550:include/asm/processor.h **** 	unsigned int hdrver;
 551:include/asm/processor.h **** 	unsigned int rev;
 552:include/asm/processor.h **** 	unsigned int date;
 553:include/asm/processor.h **** 	unsigned int sig;
 554:include/asm/processor.h **** 	unsigned int cksum;
 555:include/asm/processor.h **** 	unsigned int ldrver;
 556:include/asm/processor.h **** 	unsigned int pf;
 557:include/asm/processor.h **** 	unsigned int datasize;
 558:include/asm/processor.h **** 	unsigned int totalsize;
 559:include/asm/processor.h **** 	unsigned int reserved[3];
 560:include/asm/processor.h **** };
 561:include/asm/processor.h **** 
 562:include/asm/processor.h **** struct microcode {
 563:include/asm/processor.h **** 	struct microcode_header hdr;
 564:include/asm/processor.h **** 	unsigned int bits[0];
 565:include/asm/processor.h **** };
 566:include/asm/processor.h **** 
 567:include/asm/processor.h **** typedef struct microcode microcode_t;
 568:include/asm/processor.h **** typedef struct microcode_header microcode_header_t;
 569:include/asm/processor.h **** 
 570:include/asm/processor.h **** /* microcode format is extended from prescott processors */
 571:include/asm/processor.h **** struct extended_signature {
 572:include/asm/processor.h **** 	unsigned int sig;
 573:include/asm/processor.h **** 	unsigned int pf;
 574:include/asm/processor.h **** 	unsigned int cksum;
 575:include/asm/processor.h **** };
 576:include/asm/processor.h **** 
 577:include/asm/processor.h **** struct extended_sigtable {
 578:include/asm/processor.h **** 	unsigned int count;
 579:include/asm/processor.h **** 	unsigned int cksum;
 580:include/asm/processor.h **** 	unsigned int reserved[3];
 581:include/asm/processor.h **** 	struct extended_signature sigs[0];
 582:include/asm/processor.h **** };
 583:include/asm/processor.h **** /* '6' because it used to be for P6 only (but now covers Pentium 4 as well) */
 584:include/asm/processor.h **** #define MICROCODE_IOCFREE	_IO('6',0)
 585:include/asm/processor.h **** 
 586:include/asm/processor.h **** /* REP NOP (PAUSE) is a good thing to insert into busy-wait loops. */
 587:include/asm/processor.h **** static inline void rep_nop(void)
 588:include/asm/processor.h **** {
 589:include/asm/processor.h **** 	__asm__ __volatile__("rep;nop": : :"memory");
 590:include/asm/processor.h **** }
 591:include/asm/processor.h **** 
 592:include/asm/processor.h **** #define cpu_relax()	rep_nop()
 593:include/asm/processor.h **** 
 594:include/asm/processor.h **** /* generic versions from gas */
 595:include/asm/processor.h **** #define GENERIC_NOP1	".byte 0x90\n"
 596:include/asm/processor.h **** #define GENERIC_NOP2    	".byte 0x89,0xf6\n"
 597:include/asm/processor.h **** #define GENERIC_NOP3        ".byte 0x8d,0x76,0x00\n"
 598:include/asm/processor.h **** #define GENERIC_NOP4        ".byte 0x8d,0x74,0x26,0x00\n"
 599:include/asm/processor.h **** #define GENERIC_NOP5        GENERIC_NOP1 GENERIC_NOP4
 600:include/asm/processor.h **** #define GENERIC_NOP6	".byte 0x8d,0xb6,0x00,0x00,0x00,0x00\n"
 601:include/asm/processor.h **** #define GENERIC_NOP7	".byte 0x8d,0xb4,0x26,0x00,0x00,0x00,0x00\n"
 602:include/asm/processor.h **** #define GENERIC_NOP8	GENERIC_NOP1 GENERIC_NOP7
 603:include/asm/processor.h **** 
 604:include/asm/processor.h **** /* Opteron nops */
GAS LISTING  			page 71


 605:include/asm/processor.h **** #define K8_NOP1 GENERIC_NOP1
 606:include/asm/processor.h **** #define K8_NOP2	".byte 0x66,0x90\n" 
 607:include/asm/processor.h **** #define K8_NOP3	".byte 0x66,0x66,0x90\n" 
 608:include/asm/processor.h **** #define K8_NOP4	".byte 0x66,0x66,0x66,0x90\n" 
 609:include/asm/processor.h **** #define K8_NOP5	K8_NOP3 K8_NOP2 
 610:include/asm/processor.h **** #define K8_NOP6	K8_NOP3 K8_NOP3
 611:include/asm/processor.h **** #define K8_NOP7	K8_NOP4 K8_NOP3
 612:include/asm/processor.h **** #define K8_NOP8	K8_NOP4 K8_NOP4
 613:include/asm/processor.h **** 
 614:include/asm/processor.h **** /* K7 nops */
 615:include/asm/processor.h **** /* uses eax dependencies (arbitary choice) */
 616:include/asm/processor.h **** #define K7_NOP1  GENERIC_NOP1
 617:include/asm/processor.h **** #define K7_NOP2	".byte 0x8b,0xc0\n" 
 618:include/asm/processor.h **** #define K7_NOP3	".byte 0x8d,0x04,0x20\n"
 619:include/asm/processor.h **** #define K7_NOP4	".byte 0x8d,0x44,0x20,0x00\n"
 620:include/asm/processor.h **** #define K7_NOP5	K7_NOP4 ASM_NOP1
 621:include/asm/processor.h **** #define K7_NOP6	".byte 0x8d,0x80,0,0,0,0\n"
 622:include/asm/processor.h **** #define K7_NOP7        ".byte 0x8D,0x04,0x05,0,0,0,0\n"
 623:include/asm/processor.h **** #define K7_NOP8        K7_NOP7 ASM_NOP1
 624:include/asm/processor.h **** 
 625:include/asm/processor.h **** #ifdef CONFIG_MK8
 626:include/asm/processor.h **** #define ASM_NOP1 K8_NOP1
 627:include/asm/processor.h **** #define ASM_NOP2 K8_NOP2
 628:include/asm/processor.h **** #define ASM_NOP3 K8_NOP3
 629:include/asm/processor.h **** #define ASM_NOP4 K8_NOP4
 630:include/asm/processor.h **** #define ASM_NOP5 K8_NOP5
 631:include/asm/processor.h **** #define ASM_NOP6 K8_NOP6
 632:include/asm/processor.h **** #define ASM_NOP7 K8_NOP7
 633:include/asm/processor.h **** #define ASM_NOP8 K8_NOP8
 634:include/asm/processor.h **** #elif defined(CONFIG_MK7)
 635:include/asm/processor.h **** #define ASM_NOP1 K7_NOP1
 636:include/asm/processor.h **** #define ASM_NOP2 K7_NOP2
 637:include/asm/processor.h **** #define ASM_NOP3 K7_NOP3
 638:include/asm/processor.h **** #define ASM_NOP4 K7_NOP4
 639:include/asm/processor.h **** #define ASM_NOP5 K7_NOP5
 640:include/asm/processor.h **** #define ASM_NOP6 K7_NOP6
 641:include/asm/processor.h **** #define ASM_NOP7 K7_NOP7
 642:include/asm/processor.h **** #define ASM_NOP8 K7_NOP8
 643:include/asm/processor.h **** #else
 644:include/asm/processor.h **** #define ASM_NOP1 GENERIC_NOP1
 645:include/asm/processor.h **** #define ASM_NOP2 GENERIC_NOP2
 646:include/asm/processor.h **** #define ASM_NOP3 GENERIC_NOP3
 647:include/asm/processor.h **** #define ASM_NOP4 GENERIC_NOP4
 648:include/asm/processor.h **** #define ASM_NOP5 GENERIC_NOP5
 649:include/asm/processor.h **** #define ASM_NOP6 GENERIC_NOP6
 650:include/asm/processor.h **** #define ASM_NOP7 GENERIC_NOP7
 651:include/asm/processor.h **** #define ASM_NOP8 GENERIC_NOP8
 652:include/asm/processor.h **** #endif
 653:include/asm/processor.h **** 
 654:include/asm/processor.h **** #define ASM_NOP_MAX 8
 655:include/asm/processor.h **** 
 656:include/asm/processor.h **** /* Prefetch instructions for Pentium III and AMD Athlon */
 657:include/asm/processor.h **** /* It's not worth to care about 3dnow! prefetches for the K6
 658:include/asm/processor.h ****    because they are microcoded there and very slow.
 659:include/asm/processor.h ****    However we don't do prefetches for pre XP Athlons currently
 660:include/asm/processor.h ****    That should be fixed. */
 661:include/asm/processor.h **** #define ARCH_HAS_PREFETCH
GAS LISTING  			page 72


 662:include/asm/processor.h **** extern inline void prefetch(const void *x)
 663:include/asm/processor.h **** {
 1500              	.loc 6 663 0
 1501 0a58 8B965001 	movl 336(%esi),%edx
 1501      0000
 1502              	.LBB130:
 664:include/asm/processor.h **** 	alternative_input(ASM_NOP4,
 1503              	.loc 6 664 0
 1504              	
 1505              	661:
 1506 0a5e 8D742600 	.byte 0x8d,0x74,0x26,0x00
 1507              	
 1508              	662:
 1509              	.section .altinstructions,"a"
 1510              	.align 4
 1511 0000 5E0A0000 	.long 661b
 1512 0004 00000000 	.long 663f
 1513 0008 19       	.byte 25
 1514 0009 04       	.byte 662b-661b
 1515 000a 03       	.byte 664f-663f
 1516              	.previous
 1517              	.section .altinstr_replacement,"ax"
 1518              	663:
 1519 0000 0F1802   	prefetchnta (%edx)
 1520              	664:
 1521              	.previous
 1522              	
 1523              	.LBE130:
 1524              	.LBE129:
 1525 0a62 8D95DC05 	leal 1500(%ebp),%edx
 1525      0000
 1526 0a68 39D0     	cmpl %edx,%eax
 1527              	.L755:
 1528 0a6a 0F84CF00 	je .L730
 1528      0000
 1529              	.loc 1 294 0
 1530 0a70 8B442404 	movl 4(%esp),%eax
 1531 0a74 29F8     	subl %edi,%eax
 1532              	.loc 1 293 0
 1533 0a76 FF0424   	incl (%esp)
 1534              	.loc 1 294 0
 1535 0a79 83F87F   	cmpl $127,%eax
 1536 0a7c 7EA3     	jle .L754
 297:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		}
 298:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 
 299:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		if (ieee->scan_age == 0 ||
 1537              	.loc 1 299 0
 1538 0a7e 8B85EC05 	movl 1516(%ebp),%eax
 1538      0000
 1539 0a84 85C0     	testl %eax,%eax
 1540 0a86 7412     	je .L735
 300:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		    time_after(network->last_scanned + ieee->scan_age, jiffies))
 1541              	.loc 1 300 0
 1542 0a88 8B8E9400 	movl 148(%esi),%ecx
 1542      0000
 1543 0a8e 8D1401   	leal (%ecx,%eax),%edx
 1544 0a91 A1000000 	movl jiffies,%eax
GAS LISTING  			page 73


 1544      00
 1545 0a96 39D0     	cmpl %edx,%eax
 1546 0a98 7913     	jns .L734
 1547              	.L735:
 301:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 			ev = ipw2100_translate_scan(ieee, ev, stop, network);
 1548              	.loc 1 301 0
 1549 0a9a 56       	pushl %esi
 1550              	.LCFI75:
 1551 0a9b FF742408 	pushl 8(%esp)
 1552              	.LCFI76:
 1553 0a9f 57       	pushl %edi
 1554              	.LCFI77:
 1555 0aa0 55       	pushl %ebp
 1556              	.LCFI78:
 1557 0aa1 E85AF5FF 	call ipw2100_translate_scan
 1557      FF
 1558 0aa6 89C7     	movl %eax,%edi
 1559 0aa8 83C410   	addl $16,%esp
 1560              	.LCFI79:
 1561 0aab EB6D     	jmp .L731
 1562              	.L734:
 302:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		else
 303:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 			IEEE80211_DEBUG_SCAN("Not showing network '%s ("
 1563              	.loc 1 303 0
 1564 0aad F6050000 	testb $4,ieee80211_debug_level
 1564      000004
 1565 0ab4 7464     	je .L731
 1566              	.LBB131:
 1567              	.loc 4 256 0
 1568 0ab6 8B150000 	movl jiffies,%edx
 1568      0000
 1569 0abc 29CA     	subl %ecx,%edx
 1570              	.LBE131:
 1571              	.LBB132:
 1572              	.LBB133:
 1573              	.loc 5 91 0
 1574 0abe B800E0FF 	movl $-8192,%eax
 1574      FF
 1575              	
 1576 0ac3 21E0     	andl %esp,%eax
 1577              	
 1578              	.LBE133:
 1579              	.LBE132:
 1580              	.loc 5 89 0
 1581 0ac5 8B4014   	movl 20(%eax),%eax
 1582 0ac8 2500FFFF 	andl $268435200,%eax
 1582      0F
 1583 0acd 52       	pushl %edx
 1584              	.LCFI80:
 1585 0ace 83F801   	cmpl $1,%eax
 1586 0ad1 0FB64605 	movzbl 5(%esi),%eax
 1587 0ad5 50       	pushl %eax
 1588              	.LCFI81:
 1589 0ad6 0FB64604 	movzbl 4(%esi),%eax
 1590 0ada 50       	pushl %eax
 1591              	.LCFI82:
 1592 0adb 0FB64603 	movzbl 3(%esi),%eax
GAS LISTING  			page 74


 1593 0adf 50       	pushl %eax
 1594              	.LCFI83:
 1595 0ae0 0FB64602 	movzbl 2(%esi),%eax
 1596 0ae4 50       	pushl %eax
 1597              	.LCFI84:
 1598 0ae5 0FB64601 	movzbl 1(%esi),%eax
 1599 0ae9 50       	pushl %eax
 1600              	.LCFI85:
 1601 0aea 0FB606   	movzbl (%esi),%eax
 1602 0aed 50       	pushl %eax
 1603              	.LCFI86:
 1604 0aee 0FB64628 	movzbl 40(%esi),%eax
 1605 0af2 50       	pushl %eax
 1606              	.LCFI87:
 1607 0af3 8D4607   	leal 7(%esi),%eax
 1608 0af6 50       	pushl %eax
 1609              	.LCFI88:
 1610 0af7 19DB     	sbbl %ebx,%ebx
 1611              	.LCFI89:
 1612 0af9 E8FCFFFF 	call escape_essid
 1612      FF
 1613 0afe 59       	popl %ecx
 1614              	.LCFI90:
 1615 0aff 5A       	popl %edx
 1616              	.LCFI91:
 1617 0b00 50       	pushl %eax
 1618              	.LCFI92:
 1619 0b01 83E30C   	andl $12,%ebx
 1620 0b04 68000000 	pushl $__func__.0
 1620      00
 1621              	.LCFI93:
 1622 0b09 83C349   	addl $73,%ebx
 1623 0b0c 53       	pushl %ebx
 1624              	.LCFI94:
 1625 0b0d 68B30000 	pushl $.LC22
 1625      00
 1626              	.LCFI95:
 1627 0b12 E8FCFFFF 	call printk
 1627      FF
 1628 0b17 83C42C   	addl $44,%esp
 1629              	.LCFI96:
 1630              	.L731:
 1631              	.LBB134:
 1632              	.loc 1 292 0
 1633 0b1a 8B965001 	movl 336(%esi),%edx
 1633      0000
 1634 0b20 8D82B0FE 	leal -336(%edx),%eax
 1634      FFFF
 1635              	.LBE134:
 1636 0b26 89C6     	movl %eax,%esi
 1637              	.LBB135:
 1638              	.loc 6 663 0
 1639 0b28 8B805001 	movl 336(%eax),%eax
 1639      0000
 1640              	.LBB136:
 1641              	.loc 6 664 0
 1642              	
GAS LISTING  			page 75


 1643              	661:
 1644 0b2e 8D742600 	.byte 0x8d,0x74,0x26,0x00
 1645              	
 1646              	662:
 1647              	.section .altinstructions,"a"
 1648 000b 00       	.align 4
 1649 000c 2E0B0000 	.long 661b
 1650 0010 03000000 	.long 663f
 1651 0014 19       	.byte 25
 1652 0015 04       	.byte 662b-661b
 1653 0016 03       	.byte 664f-663f
 1654              	.previous
 1655              	.section .altinstr_replacement,"ax"
 1656              	663:
 1657 0003 0F1800   	prefetchnta (%eax)
 1658              	664:
 1659              	.previous
 1660              	
 1661              	.LBE136:
 1662              	.LBE135:
 1663 0b32 8D85DC05 	leal 1500(%ebp),%eax
 1663      0000
 1664 0b38 39C2     	cmpl %eax,%edx
 1665 0b3a E92BFFFF 	jmp .L755
 1665      FF
 1666              	.L730:
 304:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 					     MAC_FMT ")' due to age (%dms).\n",
 305:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 					     escape_essid(network->ssid,
 306:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 							  network->ssid_len),
 307:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 					     MAC_ARG(network->bssid),
 308:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 					     jiffies_to_msecs(jiffies -
 309:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 							      network->
 310:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 							      last_scanned));
 311:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	}
 312:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 
 313:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	spin_unlock_irqrestore(&ieee->lock, flags);
 1667              	.loc 1 313 0
 1668              	
 1669 0b3f FF74240C 	pushl 12(%esp)
 1669      9D
 314:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 
 315:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	wrqu->data.length = ev - extra;
 1670              	.loc 1 315 0
 1671              	
 1672 0b44 89F8     	movl %edi,%eax
 1673 0b46 662B4424 	subw 52(%esp),%ax
 1673      34
 1674 0b4b 8B542430 	movl 48(%esp),%edx
 1675 0b4f 66894204 	movw %ax,4(%edx)
 316:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	wrqu->data.flags = 0;
 1676              	.loc 1 316 0
 1677 0b53 66C74206 	movw $0,6(%edx)
 1677      0000
 317:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 
 318:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	IEEE80211_DEBUG_WX("exit: %d networks returned.\n", i);
 1678              	.loc 1 318 0
 1679 0b59 F6050000 	testb $2,ieee80211_debug_level
GAS LISTING  			page 76


 1679      000002
 1680 0b60 7430     	je .L748
 1681              	.LBB137:
 1682              	.LBB138:
 1683              	.loc 5 91 0
 1684 0b62 B800E0FF 	movl $-8192,%eax
 1684      FF
 1685              	
 1686 0b67 21E0     	andl %esp,%eax
 1687              	
 1688              	.LBE138:
 1689              	.LBE137:
 1690              	.loc 5 89 0
 1691 0b69 8B4014   	movl 20(%eax),%eax
 1692 0b6c 2500FFFF 	andl $268435200,%eax
 1692      0F
 1693 0b71 83F801   	cmpl $1,%eax
 1694 0b74 19C0     	sbbl %eax,%eax
 1695 0b76 FF3424   	pushl (%esp)
 1696              	.LCFI97:
 1697 0b79 83E00C   	andl $12,%eax
 1698 0b7c 68000000 	pushl $__func__.0
 1698      00
 1699              	.LCFI98:
 1700 0b81 83C049   	addl $73,%eax
 1701 0b84 50       	pushl %eax
 1702              	.LCFI99:
 1703 0b85 68140100 	pushl $.LC23
 1703      00
 1704              	.LCFI100:
 1705 0b8a E8FCFFFF 	call printk
 1705      FF
 1706 0b8f 83C410   	addl $16,%esp
 1707              	.LCFI101:
 1708              	.L748:
 319:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 
 320:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	return err;
 321:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** }
 1709              	.loc 1 321 0
 1710 0b92 8B442408 	movl 8(%esp),%eax
 1711 0b96 83C414   	addl $20,%esp
 1712 0b99 5B       	popl %ebx
 1713 0b9a 5E       	popl %esi
 1714 0b9b 5F       	popl %edi
 1715 0b9c 5D       	popl %ebp
 1716 0b9d C3       	ret
 1717              	.LFE666:
 1719              	.section .rodata
 1722              	__func__.1:
 1723 0016 69656565 	.string "ieee80211_wx_set_encode"
 1723      38303231 
 1723      315F7778 
 1723      5F736574 
 1723      5F656E63 
 1724              	.section .rodata.str1.1
 1725              	.LC24:
 1726 0145 3C373E69 	.string "<7>ieee80211: %c %s SET_ENCODE\n"
GAS LISTING  			page 77


 1726      65656538 
 1726      30323131 
 1726      3A202563 
 1726      20257320 
 1727              	.LC25:
 1728 0165 70726F76 	.string "provided"
 1728      69646564 
 1728      00
 1729              	.LC26:
 1730 016e 64656661 	.string "default"
 1730      756C7400 
 1731              	.LC27:
 1732 0176 3C373E69 	.string "<7>ieee80211: %c %s Key: %d [%s]\n"
 1732      65656538 
 1732      30323131 
 1732      3A202563 
 1732      20257320 
 1733              	.LC28:
 1734 0198 3C373E69 	.string "<7>ieee80211: %c %s Disabling encryption on key %d.\n"
 1734      65656538 
 1734      30323131 
 1734      3A202563 
 1734      20257320 
 1735              	.LC29:
 1736 01cd 3C373E69 	.string "<7>ieee80211: %c %s Disabling encryption.\n"
 1736      65656538 
 1736      30323131 
 1736      3A202563 
 1736      20257320 
 1737              	.LC30:
 1738 01f8 57455000 	.string "WEP"
 1739              	.LC31:
 1740 01fc 69656565 	.string "ieee80211_crypt_wep"
 1740      38303231 
 1740      315F6372 
 1740      7970745F 
 1740      77657000 
 1741              	.LC32:
 1742 0210 3C343E25 	.string "<4>%s: could not initialize WEP: load module ieee80211_crypt_wep\n"
 1742      733A2063 
 1742      6F756C64 
 1742      206E6F74 
 1742      20696E69 
 1743              	.LC33:
 1744 0252 3C373E69 	.string "<7>ieee80211: %c %s Setting key %d to '%s' (%d:%d bytes)\n"
 1744      65656538 
 1744      30323131 
 1744      3A202563 
 1744      20257320 
 1745              	.LC34:
 1746 028c 3C373E69 	.string "<7>ieee80211: %c %s Setting key %d to all zero.\n"
 1746      65656538 
 1746      30323131 
 1746      3A202563 
 1746      20257320 
 1747              	.LC35:
 1748 02bd 3C373E69 	.string "<7>ieee80211: %c %s Setting key %d to default Tx key.\n"
GAS LISTING  			page 78


 1748      65656538 
 1748      30323131 
 1748      3A202563 
 1748      20257320 
 1749              	.LC36:
 1750 02f4 4F50454E 	.string "OPEN"
 1750      00
 1751              	.LC37:
 1752 02f9 53484152 	.string "SHARED KEY"
 1752      4544204B 
 1752      455900
 1753              	.LC38:
 1754 0304 3C373E69 	.string "<7>ieee80211: %c %s Auth: %s\n"
 1754      65656538 
 1754      30323131 
 1754      3A202563 
 1754      20257320 
 1755              	.LC39:
 1756 0322 3C373E25 	.string "<7>%s: reset_port failed\n"
 1756      733A2072 
 1756      65736574 
 1756      5F706F72 
 1756      74206661 
 1757              	.text
 1758              	.globl ieee80211_wx_set_encode
 1760              	ieee80211_wx_set_encode:
 1761              	.LFB667:
 322:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 
 323:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** int ieee80211_wx_set_encode(struct ieee80211_device *ieee,
 324:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 			    struct iw_request_info *info,
 325:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 			    union iwreq_data *wrqu, char *keybuf)
 326:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** {
 1762              	.loc 1 326 0
 1763 0b9e 55       	pushl %ebp
 1764              	.LCFI102:
 1765 0b9f 57       	pushl %edi
 1766              	.LCFI103:
 1767 0ba0 56       	pushl %esi
 1768              	.LCFI104:
 1769 0ba1 53       	pushl %ebx
 1770              	.LCFI105:
 1771 0ba2 81ECA800 	subl $168,%esp
 1771      0000
 1772              	.LCFI106:
 327:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	struct iw_point *erq = &(wrqu->encoding);
 328:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	struct net_device *dev = ieee->dev;
 1773              	.loc 1 328 0
 1774 0ba8 8B8424BC 	movl 188(%esp),%eax
 1774      000000
 1775 0baf 8B00     	movl (%eax),%eax
 1776 0bb1 89442414 	movl %eax,20(%esp)
 329:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	struct ieee80211_security sec = {
 1777              	.loc 1 329 0
 1778 0bb5 8D442418 	leal 24(%esp),%eax
 1779 0bb9 688D0000 	pushl $141
 1779      00
 1780              	.LCFI107:
GAS LISTING  			page 79


 1781 0bbe 6A00     	pushl $0
 1782              	.LCFI108:
 1783 0bc0 50       	pushl %eax
 1784              	.LCFI109:
 1785 0bc1 E8FCFFFF 	call memset
 1785      FF
 330:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		.flags = 0
 331:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	};
 332:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	int i, key, key_provided, len;
 333:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	struct ieee80211_crypt_data **crypt;
 334:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	int host_crypto = ieee->host_encrypt || ieee->host_decrypt || ieee->host_build_iv;
 1786              	.loc 1 334 0
 1787 0bc6 83C40C   	addl $12,%esp
 1788              	.LCFI110:
 1789 0bc9 8B9424BC 	movl 188(%esp),%edx
 1789      000000
 1790 0bd0 31ED     	xorl %ebp,%ebp
 1791 0bd2 83BA6806 	cmpl $0,1640(%edx)
 1791      000000
 1792 0bd9 7512     	jne .L758
 1793 0bdb 83BA7006 	cmpl $0,1648(%edx)
 1793      000000
 1794 0be2 7509     	jne .L758
 1795 0be4 83BA7C06 	cmpl $0,1660(%edx)
 1795      000000
 1796 0beb 7405     	je .L757
 1797              	.L758:
 1798 0bed BD010000 	movl $1,%ebp
 1798      00
 1799              	.L757:
 335:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 
 336:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	IEEE80211_DEBUG_WX("SET_ENCODE\n");
 1800              	.loc 1 336 0
 1801 0bf2 F6050000 	testb $2,ieee80211_debug_level
 1801      000002
 1802 0bf9 742D     	je .L759
 1803              	.LBB139:
 1804              	.LBB140:
 1805              	.loc 5 91 0
 1806 0bfb B800E0FF 	movl $-8192,%eax
 1806      FF
 1807              	
 1808 0c00 21E0     	andl %esp,%eax
 1809              	
 1810              	.LBE140:
 1811              	.LBE139:
 1812              	.loc 5 89 0
 1813 0c02 8B4014   	movl 20(%eax),%eax
 1814 0c05 2500FFFF 	andl $268435200,%eax
 1814      0F
 1815 0c0a 83F801   	cmpl $1,%eax
 1816 0c0d 19C0     	sbbl %eax,%eax
 1817 0c0f 83E00C   	andl $12,%eax
 1818 0c12 68160000 	pushl $__func__.1
 1818      00
 1819              	.LCFI111:
 1820 0c17 83C049   	addl $73,%eax
GAS LISTING  			page 80


 1821 0c1a 50       	pushl %eax
 1822              	.LCFI112:
 1823 0c1b 68450100 	pushl $.LC24
 1823      00
 1824              	.LCFI113:
 1825 0c20 E8FCFFFF 	call printk
 1825      FF
 1826 0c25 83C40C   	addl $12,%esp
 1827              	.LCFI114:
 1828              	.L759:
 337:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 
 338:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	key = erq->flags & IW_ENCODE_INDEX;
 1829              	.loc 1 338 0
 1830 0c28 8B8C24C4 	movl 196(%esp),%ecx
 1830      000000
 1831 0c2f 0FB64906 	movzbl 6(%ecx),%ecx
 339:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	if (key) {
 1832              	.loc 1 339 0
 1833 0c33 85C9     	testl %ecx,%ecx
 1834              	.loc 1 338 0
 1835 0c35 894C2410 	movl %ecx,16(%esp)
 1836              	.loc 1 339 0
 1837 0c39 741D     	je .L764
 340:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		if (key > WEP_KEYS)
 1838              	.loc 1 340 0
 1839 0c3b 83F904   	cmpl $4,%ecx
 341:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 			return -EINVAL;
 1840              	.loc 1 341 0
 1841 0c3e B8EAFFFF 	movl $-22,%eax
 1841      FF
 1842              	.loc 1 340 0
 1843 0c43 0F8F1106 	jg .L756
 1843      0000
 342:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		key--;
 1844              	.loc 1 342 0
 1845 0c49 49       	decl %ecx
 1846 0c4a 894C2410 	movl %ecx,16(%esp)
 343:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		key_provided = 1;
 1847              	.loc 1 343 0
 1848 0c4e C744240C 	movl $1,12(%esp)
 1848      01000000 
 1849 0c56 EB19     	jmp .L766
 1850              	.L764:
 344:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	} else {
 345:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		key_provided = 0;
 1851              	.loc 1 345 0
 1852 0c58 C744240C 	movl $0,12(%esp)
 1852      00000000 
 346:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		key = ieee->tx_keyidx;
 1853              	.loc 1 346 0
 1854 0c60 8B8424BC 	movl 188(%esp),%eax
 1854      000000
 1855 0c67 8B80B006 	movl 1712(%eax),%eax
 1855      0000
 1856 0c6d 89442410 	movl %eax,16(%esp)
 1857              	.L766:
 347:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	}
GAS LISTING  			page 81


 348:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 
 349:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	IEEE80211_DEBUG_WX("Key: %d [%s]\n", key, key_provided ?
 1858              	.loc 1 349 0
 1859 0c71 F6050000 	testb $2,ieee80211_debug_level
 1859      000002
 1860 0c78 7443     	je .L767
 1861              	.LBB141:
 1862              	.LBB142:
 1863              	.loc 5 91 0
 1864 0c7a B800E0FF 	movl $-8192,%eax
 1864      FF
 1865              	
 1866 0c7f 21E0     	andl %esp,%eax
 1867              	
 1868              	.LBE142:
 1869              	.LBE141:
 1870              	.loc 5 89 0
 1871 0c81 8B4014   	movl 20(%eax),%eax
 1872 0c84 2500FFFF 	andl $268435200,%eax
 1872      0F
 1873 0c89 83F801   	cmpl $1,%eax
 1874 0c8c 19C0     	sbbl %eax,%eax
 1875 0c8e 83E00C   	andl $12,%eax
 1876 0c91 83C049   	addl $73,%eax
 1877 0c94 837C240C 	cmpl $0,12(%esp)
 1877      00
 1878 0c99 BA650100 	movl $.LC25,%edx
 1878      00
 1879 0c9e 7505     	jne .L773
 1880 0ca0 BA6E0100 	movl $.LC26,%edx
 1880      00
 1881              	.L773:
 1882 0ca5 52       	pushl %edx
 1883              	.LCFI115:
 1884 0ca6 FF742414 	pushl 20(%esp)
 1885              	.LCFI116:
 1886 0caa 68160000 	pushl $__func__.1
 1886      00
 1887              	.LCFI117:
 1888 0caf 50       	pushl %eax
 1889              	.LCFI118:
 1890 0cb0 68760100 	pushl $.LC27
 1890      00
 1891              	.LCFI119:
 1892 0cb5 E8FCFFFF 	call printk
 1892      FF
 1893 0cba 83C414   	addl $20,%esp
 1894              	.LCFI120:
 1895              	.L767:
 350:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 			   "provided" : "default");
 351:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 
 352:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	crypt = &ieee->crypt[key];
 1896              	.loc 1 352 0
 1897 0cbd 8B542410 	movl 16(%esp),%edx
 1898 0cc1 8B8C24BC 	movl 188(%esp),%ecx
 1898      000000
 1899 0cc8 8D0491   	leal (%ecx,%edx,4),%eax
GAS LISTING  			page 82


 1900 0ccb 8D90A006 	leal 1696(%eax),%edx
 1900      0000
 1901 0cd1 89542408 	movl %edx,8(%esp)
 353:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 
 354:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	if (erq->flags & IW_ENCODE_DISABLED) {
 1902              	.loc 1 354 0
 1903 0cd5 8B8C24C4 	movl 196(%esp),%ecx
 1903      000000
 1904 0cdc 66837906 	cmpw $0,6(%ecx)
 1904      00
 1905 0ce1 0F89F700 	jns .L774
 1905      0000
 355:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		if (key_provided && *crypt) {
 1906              	.loc 1 355 0
 1907 0ce7 837C240C 	cmpl $0,12(%esp)
 1907      00
 1908 0cec 7457     	je .L775
 1909 0cee 83B8A006 	cmpl $0,1696(%eax)
 1909      000000
 1910 0cf5 744E     	je .L775
 356:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 			IEEE80211_DEBUG_WX("Disabling encryption on key %d.\n",
 1911              	.loc 1 356 0
 1912 0cf7 F6050000 	testb $2,ieee80211_debug_level
 1912      000002
 1913 0cfe 7431     	je .L776
 1914              	.LBB143:
 1915              	.LBB144:
 1916              	.loc 5 91 0
 1917 0d00 B800E0FF 	movl $-8192,%eax
 1917      FF
 1918              	
 1919 0d05 21E0     	andl %esp,%eax
 1920              	
 1921              	.LBE144:
 1922              	.LBE143:
 1923              	.loc 5 89 0
 1924 0d07 8B4014   	movl 20(%eax),%eax
 1925 0d0a 2500FFFF 	andl $268435200,%eax
 1925      0F
 1926 0d0f 83F801   	cmpl $1,%eax
 1927 0d12 19C0     	sbbl %eax,%eax
 1928 0d14 FF742410 	pushl 16(%esp)
 1929              	.LCFI121:
 1930 0d18 83E00C   	andl $12,%eax
 1931 0d1b 68160000 	pushl $__func__.1
 1931      00
 1932              	.LCFI122:
 1933 0d20 83C049   	addl $73,%eax
 1934 0d23 50       	pushl %eax
 1935              	.LCFI123:
 1936 0d24 68980100 	pushl $.LC28
 1936      00
 1937              	.LCFI124:
 1938 0d29 E8FCFFFF 	call printk
 1938      FF
 1939 0d2e 83C410   	addl $16,%esp
 1940              	.LCFI125:
GAS LISTING  			page 83


 1941              	.L776:
 357:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 					   key);
 358:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 			ieee80211_crypt_delayed_deinit(ieee, crypt);
 1942              	.loc 1 358 0
 1943 0d31 FF742408 	pushl 8(%esp)
 1944              	.LCFI126:
 1945 0d35 FFB424C0 	pushl 192(%esp)
 1945      000000
 1946              	.LCFI127:
 1947 0d3c E8FCFFFF 	call ieee80211_crypt_delayed_deinit
 1947      FF
 1948 0d41 58       	popl %eax
 1949              	.LCFI128:
 1950 0d42 5A       	popl %edx
 1951              	.LCFI129:
 1952 0d43 EB36     	jmp .L781
 1953              	.L775:
 359:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		} else
 360:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 			IEEE80211_DEBUG_WX("Disabling encryption.\n");
 1954              	.loc 1 360 0
 1955 0d45 F6050000 	testb $2,ieee80211_debug_level
 1955      000002
 1956 0d4c 742D     	je .L781
 1957              	.LBB145:
 1958              	.LBB146:
 1959              	.loc 5 91 0
 1960 0d4e B800E0FF 	movl $-8192,%eax
 1960      FF
 1961              	
 1962 0d53 21E0     	andl %esp,%eax
 1963              	
 1964              	.LBE146:
 1965              	.LBE145:
 1966              	.loc 5 89 0
 1967 0d55 8B4014   	movl 20(%eax),%eax
 1968 0d58 2500FFFF 	andl $268435200,%eax
 1968      0F
 1969 0d5d 83F801   	cmpl $1,%eax
 1970 0d60 19C0     	sbbl %eax,%eax
 1971 0d62 83E00C   	andl $12,%eax
 1972 0d65 68160000 	pushl $__func__.1
 1972      00
 1973              	.LCFI130:
 1974 0d6a 83C049   	addl $73,%eax
 1975 0d6d 50       	pushl %eax
 1976              	.LCFI131:
 1977 0d6e 68CD0100 	pushl $.LC29
 1977      00
 1978              	.LCFI132:
 1979 0d73 E8FCFFFF 	call printk
 1979      FF
 1980 0d78 83C40C   	addl $12,%esp
 1981              	.LCFI133:
 1982              	.L781:
 1983 0d7b 8B9C24BC 	movl 188(%esp),%ebx
 1983      000000
 361:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 
GAS LISTING  			page 84


 362:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		/* Check all the keys to see if any are still configured,
 363:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		 * and if no key index was provided, de-init them all */
 364:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		for (i = 0; i < WEP_KEYS; i++) {
 1984              	.loc 1 364 0
 1985 0d82 31F6     	xorl %esi,%esi
 1986 0d84 81C3A006 	addl $1696,%ebx
 1986      0000
 1987              	.L792:
 365:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 			if (ieee->crypt[i] != NULL) {
 1988              	.loc 1 365 0
 1989 0d8a 8B8424BC 	movl 188(%esp),%eax
 1989      000000
 1990 0d91 83BCB0A0 	cmpl $0,1696(%eax,%esi,4)
 1990      06000000 
 1991 0d99 7410     	je .L789
 366:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 				if (key_provided)
 1992              	.loc 1 366 0
 1993 0d9b 837C240C 	cmpl $0,12(%esp)
 1993      00
 1994 0da0 7512     	jne .L788
 367:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 					break;
 368:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 				ieee80211_crypt_delayed_deinit(ieee,
 1995              	.loc 1 368 0
 1996 0da2 53       	pushl %ebx
 1997              	.LCFI134:
 1998 0da3 50       	pushl %eax
 1999              	.LCFI135:
 2000 0da4 E8FCFFFF 	call ieee80211_crypt_delayed_deinit
 2000      FF
 2001 0da9 5D       	popl %ebp
 2002              	.LCFI136:
 2003 0daa 58       	popl %eax
 2004              	.LCFI137:
 2005              	.L789:
 2006              	.loc 1 364 0
 2007 0dab 46       	incl %esi
 2008 0dac 83C304   	addl $4,%ebx
 2009 0daf 83FE03   	cmpl $3,%esi
 2010 0db2 7ED6     	jle .L792
 2011              	.L788:
 369:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 							       &ieee->crypt[i]);
 370:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 			}
 371:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		}
 372:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 
 373:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		if (i == WEP_KEYS) {
 2012              	.loc 1 373 0
 2013 0db4 83FE04   	cmpl $4,%esi
 2014 0db7 0F853804 	jne .L794
 2014      0000
 374:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 			sec.enabled = 0;
 2015              	.loc 1 374 0
 2016 0dbd 80642418 	andb $-5,24(%esp)
 2016      FB
 375:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 			sec.encrypt = 0;
 2017              	.loc 1 375 0
 2018 0dc2 80642419 	andb $-5,25(%esp)
 2018      FB
GAS LISTING  			page 85


 376:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 			sec.level = SEC_LEVEL_0;
 377:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 			sec.flags |= SEC_ENABLED | SEC_LEVEL | SEC_ENCRYPT;
 2019              	.loc 1 377 0
 2020 0dc7 66818C24 	orw $896,163(%esp)
 2020      A3000000 
 2020      8003
 2021              	.loc 1 376 0
 2022 0dd1 C68424A2 	movb $0,162(%esp)
 2022      00000000 
 378:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		}
 379:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 
 380:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		goto done;
 2023              	.loc 1 380 0
 2024 0dd9 E9170400 	jmp .L794
 2024      00
 2025              	.L774:
 381:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	}
 382:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 
 383:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	sec.enabled = 1;
 2026              	.loc 1 383 0
 2027 0dde 804C2418 	orb $4,24(%esp)
 2027      04
 384:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	sec.encrypt = 1;
 2028              	.loc 1 384 0
 2029 0de3 804C2419 	orb $4,25(%esp)
 2029      04
 385:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	sec.flags |= SEC_ENABLED | SEC_ENCRYPT;
 2030              	.loc 1 385 0
 2031 0de8 66818C24 	orw $768,163(%esp)
 2031      A3000000 
 2031      0003
 386:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 
 387:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	if (*crypt != NULL && (*crypt)->ops != NULL &&
 2032              	.loc 1 387 0
 2033 0df2 8B80A006 	movl 1696(%eax),%eax
 2033      0000
 2034 0df8 85C0     	testl %eax,%eax
 2035 0dfa 7434     	je .L795
 2036 0dfc 8B4008   	movl 8(%eax),%eax
 2037 0dff 85C0     	testl %eax,%eax
 2038 0e01 742D     	je .L795
 2039              	.LBB147:
 2040              	.loc 2 104 0
 2041 0e03 8B30     	movl (%eax),%esi
 2042 0e05 BFF80100 	movl $.LC30,%edi
 2042      00
 2043              	.LBB148:
 2044              	.loc 2 107 0
 2045              	
 2046 0e0a AC       	1:lodsb
 2047 0e0b AE       	scasb
 2048 0e0c 7508     	jne 2f
 2049 0e0e 84C0     	testb %al,%al
 2050 0e10 75F8     	jne 1b
 2051 0e12 31C0     	xorl %eax,%eax
 2052 0e14 EB04     	jmp 3f
 2053 0e16 19C0     	2:sbbl %eax,%eax
GAS LISTING  			page 86


 2054 0e18 0C01     	orb $1,%al
 2055              	3:
 2056              	
 2057              	.LBE148:
 2058              	.LBE147:
 2059              	.loc 2 104 0
 2060 0e1a 85C0     	testl %eax,%eax
 2061 0e1c 7412     	je .L795
 388:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	    strcmp((*crypt)->ops->name, "WEP") != 0) {
 389:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		/* changing to use WEP; deinit previously used algorithm
 390:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		 * on this key */
 391:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		ieee80211_crypt_delayed_deinit(ieee, crypt);
 2062              	.loc 1 391 0
 2063 0e1e FF742408 	pushl 8(%esp)
 2064              	.LCFI138:
 2065 0e22 FFB424C0 	pushl 192(%esp)
 2065      000000
 2066              	.LCFI139:
 2067 0e29 E8FCFFFF 	call ieee80211_crypt_delayed_deinit
 2067      FF
 2068 0e2e 5E       	popl %esi
 2069              	.LCFI140:
 2070 0e2f 5F       	popl %edi
 2071              	.LCFI141:
 2072              	.L795:
 392:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	}
 393:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 
 394:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	if (*crypt == NULL && host_crypto) {
 2073              	.loc 1 394 0
 2074 0e30 8B542408 	movl 8(%esp),%edx
 2075 0e34 8B32     	movl (%edx),%esi
 2076 0e36 85F6     	testl %esi,%esi
 2077 0e38 0F85B900 	jne .L797
 2077      0000
 2078 0e3e 85ED     	testl %ebp,%ebp
 2079 0e40 0F84B100 	je .L797
 2079      0000
 2080              	.L800:
 2081              	.LBB149:
 2082              	.LBB150:
 2083              	.LBB151:
 2084              	.LBB152:
 2085              	.file 7 "include/linux/slab.h"
   1:include/linux/slab.h **** /*
   2:include/linux/slab.h ****  * linux/mm/slab.h
   3:include/linux/slab.h ****  * Written by Mark Hemment, 1996.
   4:include/linux/slab.h ****  * (markhe@nextd.demon.co.uk)
   5:include/linux/slab.h ****  */
   6:include/linux/slab.h **** 
   7:include/linux/slab.h **** #ifndef _LINUX_SLAB_H
   8:include/linux/slab.h **** #define	_LINUX_SLAB_H
   9:include/linux/slab.h **** 
  10:include/linux/slab.h **** #if	defined(__KERNEL__)
  11:include/linux/slab.h **** 
  12:include/linux/slab.h **** typedef struct kmem_cache_s kmem_cache_t;
  13:include/linux/slab.h **** 
  14:include/linux/slab.h **** #include	<linux/config.h>	/* kmalloc_sizes.h needs CONFIG_ options */
GAS LISTING  			page 87


  15:include/linux/slab.h **** #include	<linux/gfp.h>
  16:include/linux/slab.h **** #include	<linux/init.h>
  17:include/linux/slab.h **** #include	<linux/types.h>
  18:include/linux/slab.h **** #include	<asm/page.h>		/* kmalloc_sizes.h needs PAGE_SIZE */
  19:include/linux/slab.h **** #include	<asm/cache.h>		/* kmalloc_sizes.h needs L1_CACHE_BYTES */
  20:include/linux/slab.h **** 
  21:include/linux/slab.h **** /* flags for kmem_cache_alloc() */
  22:include/linux/slab.h **** #define	SLAB_NOFS		GFP_NOFS
  23:include/linux/slab.h **** #define	SLAB_NOIO		GFP_NOIO
  24:include/linux/slab.h **** #define	SLAB_ATOMIC		GFP_ATOMIC
  25:include/linux/slab.h **** #define	SLAB_USER		GFP_USER
  26:include/linux/slab.h **** #define	SLAB_KERNEL		GFP_KERNEL
  27:include/linux/slab.h **** #define	SLAB_DMA		GFP_DMA
  28:include/linux/slab.h **** 
  29:include/linux/slab.h **** #define SLAB_LEVEL_MASK		GFP_LEVEL_MASK
  30:include/linux/slab.h **** 
  31:include/linux/slab.h **** #define	SLAB_NO_GROW		__GFP_NO_GROW	/* don't grow a cache */
  32:include/linux/slab.h **** 
  33:include/linux/slab.h **** /* flags to pass to kmem_cache_create().
  34:include/linux/slab.h ****  * The first 3 are only valid when the allocator as been build
  35:include/linux/slab.h ****  * SLAB_DEBUG_SUPPORT.
  36:include/linux/slab.h ****  */
  37:include/linux/slab.h **** #define	SLAB_DEBUG_FREE		0x00000100UL	/* Peform (expensive) checks on free */
  38:include/linux/slab.h **** #define	SLAB_DEBUG_INITIAL	0x00000200UL	/* Call constructor (as verifier) */
  39:include/linux/slab.h **** #define	SLAB_RED_ZONE		0x00000400UL	/* Red zone objs in a cache */
  40:include/linux/slab.h **** #define	SLAB_POISON		0x00000800UL	/* Poison objects */
  41:include/linux/slab.h **** #define	SLAB_NO_REAP		0x00001000UL	/* never reap from the cache */
  42:include/linux/slab.h **** #define	SLAB_HWCACHE_ALIGN	0x00002000UL	/* align objs on a h/w cache lines */
  43:include/linux/slab.h **** #define SLAB_CACHE_DMA		0x00004000UL	/* use GFP_DMA memory */
  44:include/linux/slab.h **** #define SLAB_MUST_HWCACHE_ALIGN	0x00008000UL	/* force alignment */
  45:include/linux/slab.h **** #define SLAB_STORE_USER		0x00010000UL	/* store the last owner for bug hunting */
  46:include/linux/slab.h **** #define SLAB_RECLAIM_ACCOUNT	0x00020000UL	/* track pages allocated to indicate
  47:include/linux/slab.h **** 						   what is reclaimable later*/
  48:include/linux/slab.h **** #define SLAB_PANIC		0x00040000UL	/* panic if kmem_cache_create() fails */
  49:include/linux/slab.h **** #define SLAB_DESTROY_BY_RCU	0x00080000UL	/* defer freeing pages to RCU */
  50:include/linux/slab.h **** 
  51:include/linux/slab.h **** /* flags passed to a constructor func */
  52:include/linux/slab.h **** #define	SLAB_CTOR_CONSTRUCTOR	0x001UL		/* if not set, then deconstructor */
  53:include/linux/slab.h **** #define SLAB_CTOR_ATOMIC	0x002UL		/* tell constructor it can't sleep */
  54:include/linux/slab.h **** #define	SLAB_CTOR_VERIFY	0x004UL		/* tell constructor it's a verify call */
  55:include/linux/slab.h **** 
  56:include/linux/slab.h **** /* prototypes */
  57:include/linux/slab.h **** extern void __init kmem_cache_init(void);
  58:include/linux/slab.h **** 
  59:include/linux/slab.h **** extern kmem_cache_t *kmem_cache_create(const char *, size_t, size_t, unsigned long,
  60:include/linux/slab.h **** 				       void (*)(void *, kmem_cache_t *, unsigned long),
  61:include/linux/slab.h **** 				       void (*)(void *, kmem_cache_t *, unsigned long));
  62:include/linux/slab.h **** extern int kmem_cache_destroy(kmem_cache_t *);
  63:include/linux/slab.h **** extern int kmem_cache_shrink(kmem_cache_t *);
  64:include/linux/slab.h **** extern void *kmem_cache_alloc(kmem_cache_t *, unsigned int __nocast);
  65:include/linux/slab.h **** extern void kmem_cache_free(kmem_cache_t *, void *);
  66:include/linux/slab.h **** extern unsigned int kmem_cache_size(kmem_cache_t *);
  67:include/linux/slab.h **** extern kmem_cache_t *kmem_find_general_cachep(size_t size, int gfpflags);
  68:include/linux/slab.h **** 
  69:include/linux/slab.h **** /* Size description struct for general caches. */
  70:include/linux/slab.h **** struct cache_sizes {
  71:include/linux/slab.h **** 	size_t		 cs_size;
GAS LISTING  			page 88


  72:include/linux/slab.h **** 	kmem_cache_t	*cs_cachep;
  73:include/linux/slab.h **** 	kmem_cache_t	*cs_dmacachep;
  74:include/linux/slab.h **** };
  75:include/linux/slab.h **** extern struct cache_sizes malloc_sizes[];
  76:include/linux/slab.h **** extern void *__kmalloc(size_t, unsigned int __nocast);
  77:include/linux/slab.h **** 
  78:include/linux/slab.h **** static inline void *kmalloc(size_t size, unsigned int __nocast flags)
  79:include/linux/slab.h **** {
  80:include/linux/slab.h **** 	if (__builtin_constant_p(size)) {
  81:include/linux/slab.h **** 		int i = 0;
  82:include/linux/slab.h **** #define CACHE(x) \
  83:include/linux/slab.h **** 		if (size <= x) \
  84:include/linux/slab.h **** 			goto found; \
  85:include/linux/slab.h **** 		else \
  86:include/linux/slab.h **** 			i++;
  87:include/linux/slab.h **** #include "kmalloc_sizes.h"
  88:include/linux/slab.h **** #undef CACHE
  89:include/linux/slab.h **** 		{
  90:include/linux/slab.h **** 			extern void __you_cannot_kmalloc_that_much(void);
  91:include/linux/slab.h **** 			__you_cannot_kmalloc_that_much();
  92:include/linux/slab.h **** 		}
  93:include/linux/slab.h **** found:
 2086              	.loc 7 93 0
 2087 0e46 68D00000 	pushl $208
 2087      00
 2088              	.LCFI142:
 2089 0e4b FF350400 	pushl malloc_sizes+4
 2089      0000
 2090              	.LCFI143:
 2091 0e51 E8FCFFFF 	call kmem_cache_alloc
 2091      FF
 2092 0e56 59       	popl %ecx
 2093              	.LCFI144:
 2094 0e57 5B       	popl %ebx
 2095              	.LCFI145:
 2096 0e58 89C3     	movl %eax,%ebx
 2097              	.LBE152:
 2098              	.LBE151:
 2099              	.LBE150:
 395:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		struct ieee80211_crypt_data *new_crypt;
 396:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 
 397:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		/* take WEP into use */
 398:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		new_crypt = kmalloc(sizeof(struct ieee80211_crypt_data),
 399:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 				    GFP_KERNEL);
 400:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		if (new_crypt == NULL)
 2100              	.loc 1 400 0
 2101 0e5a 85DB     	testl %ebx,%ebx
 401:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 			return -ENOMEM;
 2102              	.loc 1 401 0
 2103 0e5c B8F4FFFF 	movl $-12,%eax
 2103      FF
 2104              	.loc 1 400 0
 2105 0e61 0F84F303 	je .L756
 2105      0000
 2106              	.LBB153:
 2107              	.LBB154:
 2108              	.LBB155:
GAS LISTING  			page 89


 2109              	.loc 2 448 0
 2110 0e67 B9050000 	movl $5,%ecx
 2110      00
 2111 0e6c 89DF     	movl %ebx,%edi
 2112 0e6e 89F0     	movl %esi,%eax
 2113              	
 2114 0e70 F3AB     	rep
 2115              	
 2116              	.LBE155:
 2117              	.LBE154:
 2118              	.LBE153:
 402:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		memset(new_crypt, 0, sizeof(struct ieee80211_crypt_data));
 403:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		new_crypt->ops = ieee80211_get_crypto_ops("WEP");
 2119              	.loc 1 403 0
 2120 0e72 68F80100 	pushl $.LC30
 2120      00
 2121              	.LCFI146:
 2122 0e77 E8FCFFFF 	call ieee80211_get_crypto_ops
 2122      FF
 2123 0e7c 894308   	movl %eax,8(%ebx)
 404:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		if (!new_crypt->ops) {
 2124              	.loc 1 404 0
 2125 0e7f 85C0     	testl %eax,%eax
 2126 0e81 5A       	popl %edx
 2127              	.LCFI147:
 2128 0e82 7519     	jne .L845
 405:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 			request_module("ieee80211_crypt_wep");
 2129              	.loc 1 405 0
 2130 0e84 68FC0100 	pushl $.LC31
 2130      00
 2131              	.LCFI148:
 2132 0e89 E8FCFFFF 	call request_module
 2132      FF
 406:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 			new_crypt->ops = ieee80211_get_crypto_ops("WEP");
 2133              	.loc 1 406 0
 2134 0e8e 68F80100 	pushl $.LC30
 2134      00
 2135              	.LCFI149:
 2136              	.LCFI150:
 2137 0e93 E8FCFFFF 	call ieee80211_get_crypto_ops
 2137      FF
 2138 0e98 894308   	movl %eax,8(%ebx)
 2139 0e9b 5F       	popl %edi
 2140              	.LCFI151:
 2141 0e9c 58       	popl %eax
 2142              	.LCFI152:
 2143              	.L845:
 407:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		}
 408:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 
 409:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		if (new_crypt->ops && try_module_get(new_crypt->ops->owner))
 2144              	.loc 1 409 0
 2145 0e9d 8B4308   	movl 8(%ebx),%eax
 2146 0ea0 85C0     	testl %eax,%eax
 2147 0ea2 742C     	je .L856
 2148              	.LBB156:
 2149              	.file 8 "include/linux/module.h"
   1:include/linux/module.h **** #ifndef _LINUX_MODULE_H
GAS LISTING  			page 90


   2:include/linux/module.h **** #define _LINUX_MODULE_H
   3:include/linux/module.h **** /*
   4:include/linux/module.h ****  * Dynamic loading of modules into the kernel.
   5:include/linux/module.h ****  *
   6:include/linux/module.h ****  * Rewritten by Richard Henderson <rth@tamu.edu> Dec 1996
   7:include/linux/module.h ****  * Rewritten again by Rusty Russell, 2002
   8:include/linux/module.h ****  */
   9:include/linux/module.h **** #include <linux/config.h>
  10:include/linux/module.h **** #include <linux/sched.h>
  11:include/linux/module.h **** #include <linux/spinlock.h>
  12:include/linux/module.h **** #include <linux/list.h>
  13:include/linux/module.h **** #include <linux/stat.h>
  14:include/linux/module.h **** #include <linux/compiler.h>
  15:include/linux/module.h **** #include <linux/cache.h>
  16:include/linux/module.h **** #include <linux/kmod.h>
  17:include/linux/module.h **** #include <linux/elf.h>
  18:include/linux/module.h **** #include <linux/stringify.h>
  19:include/linux/module.h **** #include <linux/kobject.h>
  20:include/linux/module.h **** #include <linux/moduleparam.h>
  21:include/linux/module.h **** #include <asm/local.h>
  22:include/linux/module.h **** 
  23:include/linux/module.h **** #include <asm/module.h>
  24:include/linux/module.h **** 
  25:include/linux/module.h **** /* Not Yet Implemented */
  26:include/linux/module.h **** #define MODULE_SUPPORTED_DEVICE(name)
  27:include/linux/module.h **** 
  28:include/linux/module.h **** /* v850 toolchain uses a `_' prefix for all user symbols */
  29:include/linux/module.h **** #ifndef MODULE_SYMBOL_PREFIX
  30:include/linux/module.h **** #define MODULE_SYMBOL_PREFIX ""
  31:include/linux/module.h **** #endif
  32:include/linux/module.h **** 
  33:include/linux/module.h **** #define MODULE_NAME_LEN (64 - sizeof(unsigned long))
  34:include/linux/module.h **** 
  35:include/linux/module.h **** struct kernel_symbol
  36:include/linux/module.h **** {
  37:include/linux/module.h **** 	unsigned long value;
  38:include/linux/module.h **** 	const char *name;
  39:include/linux/module.h **** };
  40:include/linux/module.h **** 
  41:include/linux/module.h **** struct modversion_info
  42:include/linux/module.h **** {
  43:include/linux/module.h **** 	unsigned long crc;
  44:include/linux/module.h **** 	char name[MODULE_NAME_LEN];
  45:include/linux/module.h **** };
  46:include/linux/module.h **** 
  47:include/linux/module.h **** struct module;
  48:include/linux/module.h **** 
  49:include/linux/module.h **** struct module_attribute {
  50:include/linux/module.h ****         struct attribute attr;
  51:include/linux/module.h ****         ssize_t (*show)(struct module_attribute *, struct module *, char *);
  52:include/linux/module.h ****         ssize_t (*store)(struct module_attribute *, struct module *,
  53:include/linux/module.h **** 			 const char *, size_t count);
  54:include/linux/module.h **** };
  55:include/linux/module.h **** 
  56:include/linux/module.h **** struct module_kobject
  57:include/linux/module.h **** {
  58:include/linux/module.h **** 	struct kobject kobj;
GAS LISTING  			page 91


  59:include/linux/module.h **** 	struct module *mod;
  60:include/linux/module.h **** };
  61:include/linux/module.h **** 
  62:include/linux/module.h **** /* These are either module local, or the kernel's dummy ones. */
  63:include/linux/module.h **** extern int init_module(void);
  64:include/linux/module.h **** extern void cleanup_module(void);
  65:include/linux/module.h **** 
  66:include/linux/module.h **** /* Archs provide a method of finding the correct exception table. */
  67:include/linux/module.h **** struct exception_table_entry;
  68:include/linux/module.h **** 
  69:include/linux/module.h **** const struct exception_table_entry *
  70:include/linux/module.h **** search_extable(const struct exception_table_entry *first,
  71:include/linux/module.h **** 	       const struct exception_table_entry *last,
  72:include/linux/module.h **** 	       unsigned long value);
  73:include/linux/module.h **** void sort_extable(struct exception_table_entry *start,
  74:include/linux/module.h **** 		  struct exception_table_entry *finish);
  75:include/linux/module.h **** void sort_main_extable(void);
  76:include/linux/module.h **** 
  77:include/linux/module.h **** extern struct subsystem module_subsys;
  78:include/linux/module.h **** 
  79:include/linux/module.h **** #ifdef MODULE
  80:include/linux/module.h **** #define MODULE_GENERIC_TABLE(gtype,name)			\
  81:include/linux/module.h **** extern const struct gtype##_id __mod_##gtype##_table		\
  82:include/linux/module.h ****   __attribute__ ((unused, alias(__stringify(name))))
  83:include/linux/module.h **** 
  84:include/linux/module.h **** extern struct module __this_module;
  85:include/linux/module.h **** #define THIS_MODULE (&__this_module)
  86:include/linux/module.h **** #else  /* !MODULE */
  87:include/linux/module.h **** #define MODULE_GENERIC_TABLE(gtype,name)
  88:include/linux/module.h **** #define THIS_MODULE ((struct module *)0)
  89:include/linux/module.h **** #endif
  90:include/linux/module.h **** 
  91:include/linux/module.h **** /* Generic info of form tag = "info" */
  92:include/linux/module.h **** #define MODULE_INFO(tag, info) __MODULE_INFO(tag, tag, info)
  93:include/linux/module.h **** 
  94:include/linux/module.h **** /* For userspace: you can also call me... */
  95:include/linux/module.h **** #define MODULE_ALIAS(_alias) MODULE_INFO(alias, _alias)
  96:include/linux/module.h **** 
  97:include/linux/module.h **** /*
  98:include/linux/module.h ****  * The following license idents are currently accepted as indicating free
  99:include/linux/module.h ****  * software modules
 100:include/linux/module.h ****  *
 101:include/linux/module.h ****  *	"GPL"				[GNU Public License v2 or later]
 102:include/linux/module.h ****  *	"GPL v2"			[GNU Public License v2]
 103:include/linux/module.h ****  *	"GPL and additional rights"	[GNU Public License v2 rights and more]
 104:include/linux/module.h ****  *	"Dual BSD/GPL"			[GNU Public License v2
 105:include/linux/module.h ****  *					 or BSD license choice]
 106:include/linux/module.h ****  *	"Dual MPL/GPL"			[GNU Public License v2
 107:include/linux/module.h ****  *					 or Mozilla license choice]
 108:include/linux/module.h ****  *
 109:include/linux/module.h ****  * The following other idents are available
 110:include/linux/module.h ****  *
 111:include/linux/module.h ****  *	"Proprietary"			[Non free products]
 112:include/linux/module.h ****  *
 113:include/linux/module.h ****  * There are dual licensed components, but when running with Linux it is the
 114:include/linux/module.h ****  * GPL that is relevant so this is a non issue. Similarly LGPL linked with GPL
 115:include/linux/module.h ****  * is a GPL combined work.
GAS LISTING  			page 92


 116:include/linux/module.h ****  *
 117:include/linux/module.h ****  * This exists for several reasons
 118:include/linux/module.h ****  * 1.	So modinfo can show license info for users wanting to vet their setup 
 119:include/linux/module.h ****  *	is free
 120:include/linux/module.h ****  * 2.	So the community can ignore bug reports including proprietary modules
 121:include/linux/module.h ****  * 3.	So vendors can do likewise based on their own policies
 122:include/linux/module.h ****  */
 123:include/linux/module.h **** #define MODULE_LICENSE(_license) MODULE_INFO(license, _license)
 124:include/linux/module.h **** 
 125:include/linux/module.h **** /* Author, ideally of form NAME <EMAIL>[, NAME <EMAIL>]*[ and NAME <EMAIL>] */
 126:include/linux/module.h **** #define MODULE_AUTHOR(_author) MODULE_INFO(author, _author)
 127:include/linux/module.h ****   
 128:include/linux/module.h **** /* What your module does. */
 129:include/linux/module.h **** #define MODULE_DESCRIPTION(_description) MODULE_INFO(description, _description)
 130:include/linux/module.h **** 
 131:include/linux/module.h **** /* One for each parameter, describing how to use it.  Some files do
 132:include/linux/module.h ****    multiple of these per line, so can't just use MODULE_INFO. */
 133:include/linux/module.h **** #define MODULE_PARM_DESC(_parm, desc) \
 134:include/linux/module.h **** 	__MODULE_INFO(parm, _parm, #_parm ":" desc)
 135:include/linux/module.h **** 
 136:include/linux/module.h **** #define MODULE_DEVICE_TABLE(type,name)		\
 137:include/linux/module.h ****   MODULE_GENERIC_TABLE(type##_device,name)
 138:include/linux/module.h **** 
 139:include/linux/module.h **** /* Version of form [<epoch>:]<version>[-<extra-version>].
 140:include/linux/module.h ****    Or for CVS/RCS ID version, everything but the number is stripped.
 141:include/linux/module.h ****   <epoch>: A (small) unsigned integer which allows you to start versions
 142:include/linux/module.h ****            anew. If not mentioned, it's zero.  eg. "2:1.0" is after
 143:include/linux/module.h **** 	   "1:2.0".
 144:include/linux/module.h ****   <version>: The <version> may contain only alphanumerics and the
 145:include/linux/module.h ****            character `.'.  Ordered by numeric sort for numeric parts,
 146:include/linux/module.h **** 	   ascii sort for ascii parts (as per RPM or DEB algorithm).
 147:include/linux/module.h ****   <extraversion>: Like <version>, but inserted for local
 148:include/linux/module.h ****            customizations, eg "rh3" or "rusty1".
 149:include/linux/module.h **** 
 150:include/linux/module.h ****   Using this automatically adds a checksum of the .c files and the
 151:include/linux/module.h ****   local headers in "srcversion".
 152:include/linux/module.h **** */
 153:include/linux/module.h **** #define MODULE_VERSION(_version) MODULE_INFO(version, _version)
 154:include/linux/module.h **** 
 155:include/linux/module.h **** /* Given an address, look for it in the exception tables */
 156:include/linux/module.h **** const struct exception_table_entry *search_exception_tables(unsigned long add);
 157:include/linux/module.h **** 
 158:include/linux/module.h **** struct notifier_block;
 159:include/linux/module.h **** 
 160:include/linux/module.h **** #ifdef CONFIG_MODULES
 161:include/linux/module.h **** 
 162:include/linux/module.h **** /* Get/put a kernel symbol (calls must be symmetric) */
 163:include/linux/module.h **** void *__symbol_get(const char *symbol);
 164:include/linux/module.h **** void *__symbol_get_gpl(const char *symbol);
 165:include/linux/module.h **** #define symbol_get(x) ((typeof(&x))(__symbol_get(MODULE_SYMBOL_PREFIX #x)))
 166:include/linux/module.h **** 
 167:include/linux/module.h **** #ifndef __GENKSYMS__
 168:include/linux/module.h **** #ifdef CONFIG_MODVERSIONS
 169:include/linux/module.h **** /* Mark the CRC weak since genksyms apparently decides not to
 170:include/linux/module.h ****  * generate a checksums for some symbols */
 171:include/linux/module.h **** #define __CRC_SYMBOL(sym, sec)					\
 172:include/linux/module.h **** 	extern void *__crc_##sym __attribute__((weak));		\
GAS LISTING  			page 93


 173:include/linux/module.h **** 	static const unsigned long __kcrctab_##sym		\
 174:include/linux/module.h **** 	__attribute_used__					\
 175:include/linux/module.h **** 	__attribute__((section("__kcrctab" sec), unused))	\
 176:include/linux/module.h **** 	= (unsigned long) &__crc_##sym;
 177:include/linux/module.h **** #else
 178:include/linux/module.h **** #define __CRC_SYMBOL(sym, sec)
 179:include/linux/module.h **** #endif
 180:include/linux/module.h **** 
 181:include/linux/module.h **** /* For every exported symbol, place a struct in the __ksymtab section */
 182:include/linux/module.h **** #define __EXPORT_SYMBOL(sym, sec)				\
 183:include/linux/module.h **** 	__CRC_SYMBOL(sym, sec)					\
 184:include/linux/module.h **** 	static const char __kstrtab_##sym[]			\
 185:include/linux/module.h **** 	__attribute__((section("__ksymtab_strings")))		\
 186:include/linux/module.h **** 	= MODULE_SYMBOL_PREFIX #sym;                    	\
 187:include/linux/module.h **** 	static const struct kernel_symbol __ksymtab_##sym	\
 188:include/linux/module.h **** 	__attribute_used__					\
 189:include/linux/module.h **** 	__attribute__((section("__ksymtab" sec), unused))	\
 190:include/linux/module.h **** 	= { (unsigned long)&sym, __kstrtab_##sym }
 191:include/linux/module.h **** 
 192:include/linux/module.h **** #define EXPORT_SYMBOL(sym)					\
 193:include/linux/module.h **** 	__EXPORT_SYMBOL(sym, "")
 194:include/linux/module.h **** 
 195:include/linux/module.h **** #define EXPORT_SYMBOL_GPL(sym)					\
 196:include/linux/module.h **** 	__EXPORT_SYMBOL(sym, "_gpl")
 197:include/linux/module.h **** 
 198:include/linux/module.h **** #endif
 199:include/linux/module.h **** 
 200:include/linux/module.h **** struct module_ref
 201:include/linux/module.h **** {
 202:include/linux/module.h **** 	local_t count;
 203:include/linux/module.h **** } ____cacheline_aligned;
 204:include/linux/module.h **** 
 205:include/linux/module.h **** enum module_state
 206:include/linux/module.h **** {
 207:include/linux/module.h **** 	MODULE_STATE_LIVE,
 208:include/linux/module.h **** 	MODULE_STATE_COMING,
 209:include/linux/module.h **** 	MODULE_STATE_GOING,
 210:include/linux/module.h **** };
 211:include/linux/module.h **** 
 212:include/linux/module.h **** /* Similar stuff for section attributes. */
 213:include/linux/module.h **** #define MODULE_SECT_NAME_LEN 32
 214:include/linux/module.h **** struct module_sect_attr
 215:include/linux/module.h **** {
 216:include/linux/module.h **** 	struct module_attribute mattr;
 217:include/linux/module.h **** 	char name[MODULE_SECT_NAME_LEN];
 218:include/linux/module.h **** 	unsigned long address;
 219:include/linux/module.h **** };
 220:include/linux/module.h **** 
 221:include/linux/module.h **** struct module_sect_attrs
 222:include/linux/module.h **** {
 223:include/linux/module.h **** 	struct attribute_group grp;
 224:include/linux/module.h **** 	struct module_sect_attr attrs[0];
 225:include/linux/module.h **** };
 226:include/linux/module.h **** 
 227:include/linux/module.h **** struct module_param_attrs;
 228:include/linux/module.h **** 
 229:include/linux/module.h **** struct module
GAS LISTING  			page 94


 230:include/linux/module.h **** {
 231:include/linux/module.h **** 	enum module_state state;
 232:include/linux/module.h **** 
 233:include/linux/module.h **** 	/* Member of list of modules */
 234:include/linux/module.h **** 	struct list_head list;
 235:include/linux/module.h **** 
 236:include/linux/module.h **** 	/* Unique handle for this module */
 237:include/linux/module.h **** 	char name[MODULE_NAME_LEN];
 238:include/linux/module.h **** 
 239:include/linux/module.h **** 	/* Sysfs stuff. */
 240:include/linux/module.h **** 	struct module_kobject mkobj;
 241:include/linux/module.h **** 	struct module_param_attrs *param_attrs;
 242:include/linux/module.h **** 
 243:include/linux/module.h **** 	/* Exported symbols */
 244:include/linux/module.h **** 	const struct kernel_symbol *syms;
 245:include/linux/module.h **** 	unsigned int num_syms;
 246:include/linux/module.h **** 	const unsigned long *crcs;
 247:include/linux/module.h **** 
 248:include/linux/module.h **** 	/* GPL-only exported symbols. */
 249:include/linux/module.h **** 	const struct kernel_symbol *gpl_syms;
 250:include/linux/module.h **** 	unsigned int num_gpl_syms;
 251:include/linux/module.h **** 	const unsigned long *gpl_crcs;
 252:include/linux/module.h **** 
 253:include/linux/module.h **** 	/* Exception table */
 254:include/linux/module.h **** 	unsigned int num_exentries;
 255:include/linux/module.h **** 	const struct exception_table_entry *extable;
 256:include/linux/module.h **** 
 257:include/linux/module.h **** 	/* Startup function. */
 258:include/linux/module.h **** 	int (*init)(void);
 259:include/linux/module.h **** 
 260:include/linux/module.h **** 	/* If this is non-NULL, vfree after init() returns */
 261:include/linux/module.h **** 	void *module_init;
 262:include/linux/module.h **** 
 263:include/linux/module.h **** 	/* Here is the actual code + data, vfree'd on unload. */
 264:include/linux/module.h **** 	void *module_core;
 265:include/linux/module.h **** 
 266:include/linux/module.h **** 	/* Here are the sizes of the init and core sections */
 267:include/linux/module.h **** 	unsigned long init_size, core_size;
 268:include/linux/module.h **** 
 269:include/linux/module.h **** 	/* The size of the executable code in each section.  */
 270:include/linux/module.h **** 	unsigned long init_text_size, core_text_size;
 271:include/linux/module.h **** 
 272:include/linux/module.h **** 	/* Arch-specific module values */
 273:include/linux/module.h **** 	struct mod_arch_specific arch;
 274:include/linux/module.h **** 
 275:include/linux/module.h **** 	/* Am I unsafe to unload? */
 276:include/linux/module.h **** 	int unsafe;
 277:include/linux/module.h **** 
 278:include/linux/module.h **** 	/* Am I GPL-compatible */
 279:include/linux/module.h **** 	int license_gplok;
 280:include/linux/module.h **** 
 281:include/linux/module.h **** #ifdef CONFIG_MODULE_UNLOAD
 282:include/linux/module.h **** 	/* Reference counts */
 283:include/linux/module.h **** 	struct module_ref ref[NR_CPUS];
 284:include/linux/module.h **** 
 285:include/linux/module.h **** 	/* What modules depend on me? */
 286:include/linux/module.h **** 	struct list_head modules_which_use_me;
GAS LISTING  			page 95


 287:include/linux/module.h **** 
 288:include/linux/module.h **** 	/* Who is waiting for us to be unloaded */
 289:include/linux/module.h **** 	struct task_struct *waiter;
 290:include/linux/module.h **** 
 291:include/linux/module.h **** 	/* Destruction function. */
 292:include/linux/module.h **** 	void (*exit)(void);
 293:include/linux/module.h **** #endif
 294:include/linux/module.h **** 
 295:include/linux/module.h **** #ifdef CONFIG_KALLSYMS
 296:include/linux/module.h **** 	/* We keep the symbol and string tables for kallsyms. */
 297:include/linux/module.h **** 	Elf_Sym *symtab;
 298:include/linux/module.h **** 	unsigned long num_symtab;
 299:include/linux/module.h **** 	char *strtab;
 300:include/linux/module.h **** 
 301:include/linux/module.h **** 	/* Section attributes */
 302:include/linux/module.h **** 	struct module_sect_attrs *sect_attrs;
 303:include/linux/module.h **** #endif
 304:include/linux/module.h **** 
 305:include/linux/module.h **** 	/* Per-cpu data. */
 306:include/linux/module.h **** 	void *percpu;
 307:include/linux/module.h **** 
 308:include/linux/module.h **** 	/* The command line arguments (may be mangled).  People like
 309:include/linux/module.h **** 	   keeping pointers to this stuff */
 310:include/linux/module.h **** 	char *args;
 311:include/linux/module.h **** };
 312:include/linux/module.h **** 
 313:include/linux/module.h **** /* FIXME: It'd be nice to isolate modules during init, too, so they
 314:include/linux/module.h ****    aren't used before they (may) fail.  But presently too much code
 315:include/linux/module.h ****    (IDE & SCSI) require entry into the module during init.*/
 316:include/linux/module.h **** static inline int module_is_live(struct module *mod)
 317:include/linux/module.h **** {
 318:include/linux/module.h **** 	return mod->state != MODULE_STATE_GOING;
 319:include/linux/module.h **** }
 320:include/linux/module.h **** 
 321:include/linux/module.h **** /* Is this address in a module? (second is with no locks, for oops) */
 322:include/linux/module.h **** struct module *module_text_address(unsigned long addr);
 323:include/linux/module.h **** struct module *__module_text_address(unsigned long addr);
 324:include/linux/module.h **** 
 325:include/linux/module.h **** /* Returns module and fills in value, defined and namebuf, or NULL if
 326:include/linux/module.h ****    symnum out of range. */
 327:include/linux/module.h **** struct module *module_get_kallsym(unsigned int symnum,
 328:include/linux/module.h **** 				  unsigned long *value,
 329:include/linux/module.h **** 				  char *type,
 330:include/linux/module.h **** 				  char namebuf[128]);
 331:include/linux/module.h **** 
 332:include/linux/module.h **** /* Look for this name: can be of form module:name. */
 333:include/linux/module.h **** unsigned long module_kallsyms_lookup_name(const char *name);
 334:include/linux/module.h **** 
 335:include/linux/module.h **** int is_exported(const char *name, const struct module *mod);
 336:include/linux/module.h **** 
 337:include/linux/module.h **** extern void __module_put_and_exit(struct module *mod, long code)
 338:include/linux/module.h **** 	__attribute__((noreturn));
 339:include/linux/module.h **** #define module_put_and_exit(code) __module_put_and_exit(THIS_MODULE, code);
 340:include/linux/module.h **** 
 341:include/linux/module.h **** #ifdef CONFIG_MODULE_UNLOAD
 342:include/linux/module.h **** unsigned int module_refcount(struct module *mod);
 343:include/linux/module.h **** void __symbol_put(const char *symbol);
GAS LISTING  			page 96


 344:include/linux/module.h **** #define symbol_put(x) __symbol_put(MODULE_SYMBOL_PREFIX #x)
 345:include/linux/module.h **** void symbol_put_addr(void *addr);
 346:include/linux/module.h **** 
 347:include/linux/module.h **** /* Sometimes we know we already have a refcount, and it's easier not
 348:include/linux/module.h ****    to handle the error case (which only happens with rmmod --wait). */
 349:include/linux/module.h **** static inline void __module_get(struct module *module)
 350:include/linux/module.h **** {
 351:include/linux/module.h **** 	if (module) {
 352:include/linux/module.h **** 		BUG_ON(module_refcount(module) == 0);
 353:include/linux/module.h **** 		local_inc(&module->ref[get_cpu()].count);
 354:include/linux/module.h **** 		put_cpu();
 355:include/linux/module.h **** 	}
 356:include/linux/module.h **** }
 357:include/linux/module.h **** 
 358:include/linux/module.h **** static inline int try_module_get(struct module *module)
 359:include/linux/module.h **** {
 2150              	.loc 8 359 0
 2151 0ea4 8B404C   	movl 76(%eax),%eax
 2152              	.LBB157:
 360:include/linux/module.h **** 	int ret = 1;
 361:include/linux/module.h **** 
 362:include/linux/module.h **** 	if (module) {
 2153              	.loc 8 362 0
 2154 0ea7 85C0     	testl %eax,%eax
 2155 0ea9 740B     	je .L949
 2156              	.LBB158:
 2157              	.loc 8 317 0
 2158 0eab 833802   	cmpl $2,(%eax)
 2159 0eae 7414     	je .L846
 2160              	.LBB159:
 2161              	.LBB160:
 2162              	.file 9 "include/asm/local.h"
   1:include/asm/local.h **** #ifndef _ARCH_I386_LOCAL_H
   2:include/asm/local.h **** #define _ARCH_I386_LOCAL_H
   3:include/asm/local.h **** 
   4:include/asm/local.h **** #include <linux/percpu.h>
   5:include/asm/local.h **** 
   6:include/asm/local.h **** typedef struct
   7:include/asm/local.h **** {
   8:include/asm/local.h **** 	volatile unsigned long counter;
   9:include/asm/local.h **** } local_t;
  10:include/asm/local.h **** 
  11:include/asm/local.h **** #define LOCAL_INIT(i)	{ (i) }
  12:include/asm/local.h **** 
  13:include/asm/local.h **** #define local_read(v)	((v)->counter)
  14:include/asm/local.h **** #define local_set(v,i)	(((v)->counter) = (i))
  15:include/asm/local.h **** 
  16:include/asm/local.h **** static __inline__ void local_inc(local_t *v)
  17:include/asm/local.h **** {
  18:include/asm/local.h **** 	__asm__ __volatile__(
 2163              	.loc 9 18 0
 2164              	
 2165 0eb0 FF800001 	incl 256(%eax)
 2165      0000
 2166              	
 2167              	.L949:
 2168              	.LBE160:
GAS LISTING  			page 97


 2169              	.LBE159:
 2170              	.LBE158:
 2171              	.LBE157:
 2172              	.LBE156:
 410:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 			new_crypt->priv = new_crypt->ops->init(key);
 2173              	.loc 1 410 0
 2174 0eb6 8B4308   	movl 8(%ebx),%eax
 2175 0eb9 FF742410 	pushl 16(%esp)
 2176              	.LCFI153:
 2177 0ebd FF500C   	call *12(%eax)
 2178 0ec0 89430C   	movl %eax,12(%ebx)
 2179 0ec3 5E       	popl %esi
 2180              	.LCFI154:
 2181              	.L846:
 411:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 
 412:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		if (!new_crypt->ops || !new_crypt->priv) {
 2182              	.loc 1 412 0
 2183 0ec4 837B0800 	cmpl $0,8(%ebx)
 2184 0ec8 7406     	je .L856
 2185 0eca 837B0C00 	cmpl $0,12(%ebx)
 2186 0ece 7521     	jne .L855
 2187              	.L856:
 413:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 			kfree(new_crypt);
 2188              	.loc 1 413 0
 2189 0ed0 53       	pushl %ebx
 2190              	.LCFI155:
 2191 0ed1 E8FCFFFF 	call kfree
 2191      FF
 414:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 			new_crypt = NULL;
 415:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 
 416:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 			printk(KERN_WARNING "%s: could not initialize WEP: "
 2192              	.loc 1 416 0
 2193 0ed6 FF742418 	pushl 24(%esp)
 2194              	.LCFI156:
 2195 0eda 68100200 	pushl $.LC32
 2195      00
 2196              	.LCFI157:
 2197              	.LCFI158:
 2198 0edf E8FCFFFF 	call printk
 2198      FF
 417:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 			       "load module ieee80211_crypt_wep\n", dev->name);
 418:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 			return -EOPNOTSUPP;
 2199              	.loc 1 418 0
 2200 0ee4 83C40C   	addl $12,%esp
 2201              	.LCFI159:
 2202 0ee7 B8A1FFFF 	movl $-95,%eax
 2202      FF
 2203 0eec E9690300 	jmp .L756
 2203      00
 2204              	.L855:
 419:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		}
 420:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		*crypt = new_crypt;
 2205              	.loc 1 420 0
 2206 0ef1 8B542408 	movl 8(%esp),%edx
 2207 0ef5 891A     	movl %ebx,(%edx)
 2208              	.L797:
 2209              	.LBE149:
GAS LISTING  			page 98


 421:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	}
 422:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 
 423:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	/* If a new key was provided, set it up */
 424:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	if (erq->length > 0) {
 2210              	.loc 1 424 0
 2211 0ef7 8B8C24C4 	movl 196(%esp),%ecx
 2211      000000
 2212 0efe 668B4104 	movw 4(%ecx),%ax
 2213 0f02 6685C0   	testw %ax,%ax
 2214 0f05 0F843101 	je .L857
 2214      0000
 425:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		len = erq->length <= 5 ? 5 : 13;
 2215              	.loc 1 425 0
 2216 0f0b 6683F806 	cmpw $6,%ax
 2217              	.LBB161:
 2218              	.loc 2 205 0
 2219 0f0f 8B542410 	movl 16(%esp),%edx
 2220              	.LBE161:
 2221              	.loc 1 425 0
 2222 0f13 19ED     	sbbl %ebp,%ebp
 2223              	.LBB162:
 2224              	.loc 2 205 0
 2225 0f15 C1E205   	sall $5,%edx
 2226 0f18 8D541418 	leal 24(%esp,%edx),%edx
 2227              	.LBE162:
 426:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		memcpy(sec.keys[key], keybuf, erq->length);
 2228              	.loc 1 426 0
 2229 0f1c 0FB7C0   	movzwl %ax,%eax
 2230              	.loc 1 425 0
 2231 0f1f 83E5F8   	andl $-8,%ebp
 2232              	.LBB163:
 2233              	.loc 2 205 0
 2234 0f22 891424   	movl %edx,(%esp)
 2235              	.LBB164:
 2236              	.loc 2 207 0
 2237 0f25 89C1     	movl %eax,%ecx
 2238              	.LBE164:
 2239              	.loc 2 205 0
 2240 0f27 83C20A   	addl $10,%edx
 2241              	.LBE163:
 2242              	.loc 1 425 0
 2243 0f2a 83C50D   	addl $13,%ebp
 2244              	.loc 1 426 0
 2245 0f2d 31DB     	xorl %ebx,%ebx
 2246              	.LBB165:
 2247              	.loc 2 205 0
 2248 0f2f 89542404 	movl %edx,4(%esp)
 2249              	.LBB166:
 2250              	.loc 2 207 0
 2251 0f33 C1E902   	shrl $2,%ecx
 2252 0f36 89D7     	movl %edx,%edi
 2253 0f38 8BB424C8 	movl 200(%esp),%esi
 2253      000000
 2254              	
 2255 0f3f F3A5     	rep
 2256 0f41 89C1     	movl %eax,%ecx
 2257 0f43 83E103   	andl $3,%ecx
GAS LISTING  			page 99


 2258 0f46 7402     	jz 1f
 2259 0f48 F3A4     	rep
 2260              	1:
 2261              	
 2262              	.LBE166:
 2263              	.LBE165:
 427:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		if (len > erq->length)
 2264              	.loc 1 427 0
 2265 0f4a 8B8424C4 	movl 196(%esp),%eax
 2265      000000
 2266 0f51 0FB75004 	movzwl 4(%eax),%edx
 2267 0f55 39D5     	cmpl %edx,%ebp
 2268 0f57 7E23     	jle .L885
 428:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 			memset(sec.keys[key] + erq->length, 0,
 2269              	.loc 1 428 0
 2270 0f59 89EE     	movl %ebp,%esi
 2271 0f5b 29D6     	subl %edx,%esi
 2272              	.LBB167:
 2273              	.loc 2 371 0
 2274 0f5d 8B0C24   	movl (%esp),%ecx
 2275 0f60 8D7C110A 	leal 10(%ecx,%edx),%edi
 2276              	.LBB168:
 2277              	.loc 2 373 0
 2278 0f64 89F1     	movl %esi,%ecx
 2279 0f66 C1E902   	shrl $2,%ecx
 2280 0f69 89D8     	movl %ebx,%eax
 2281 0f6b 89F2     	movl %esi,%edx
 2282              	
 2283 0f6d F3AB     	rep
 2284 0f6f F6C202   	testb $2,%dl
 2285 0f72 7402     	je 1f
 2286 0f74 66AB     	stosw
 2287 0f76 F6C201   	1:testb $1,%dl
 2288 0f79 7401     	je 2f
 2289 0f7b AA       	stosb
 2290              	2:
 2291              	
 2292              	.L885:
 2293              	.LBE168:
 2294              	.LBE167:
 429:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 			       len - erq->length);
 430:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		IEEE80211_DEBUG_WX("Setting key %d to '%s' (%d:%d bytes)\n",
 2295              	.loc 1 430 0
 2296 0f7c F6050000 	testb $2,ieee80211_debug_level
 2296      000002
 2297 0f83 7450     	je .L902
 2298              	.LBB169:
 2299              	.LBB170:
 2300              	.loc 5 91 0
 2301 0f85 B800E0FF 	movl $-8192,%eax
 2301      FF
 2302              	
 2303 0f8a 21E0     	andl %esp,%eax
 2304              	
 2305              	.LBE170:
 2306              	.LBE169:
 2307              	.loc 5 89 0
GAS LISTING  			page 100


 2308 0f8c 8B4014   	movl 20(%eax),%eax
 2309 0f8f 55       	pushl %ebp
 2310              	.LCFI160:
 2311 0f90 8B8C24C8 	movl 200(%esp),%ecx
 2311      000000
 2312 0f97 2500FFFF 	andl $268435200,%eax
 2312      0F
 2313 0f9c 83F801   	cmpl $1,%eax
 2314 0f9f 89EA     	movl %ebp,%edx
 2315 0fa1 0FB74104 	movzwl 4(%ecx),%eax
 2316 0fa5 50       	pushl %eax
 2317              	.LCFI161:
 2318 0fa6 0FB6C2   	movzbl %dl,%eax
 2319 0fa9 50       	pushl %eax
 2320              	.LCFI162:
 2321 0faa FF742410 	pushl 16(%esp)
 2322              	.LCFI163:
 2323 0fae 19DB     	sbbl %ebx,%ebx
 2324              	.LCFI164:
 2325 0fb0 E8FCFFFF 	call escape_essid
 2325      FF
 2326 0fb5 5A       	popl %edx
 2327              	.LCFI165:
 2328 0fb6 59       	popl %ecx
 2329              	.LCFI166:
 2330 0fb7 50       	pushl %eax
 2331              	.LCFI167:
 2332 0fb8 FF74241C 	pushl 28(%esp)
 2333              	.LCFI168:
 2334 0fbc 83E30C   	andl $12,%ebx
 2335 0fbf 68160000 	pushl $__func__.1
 2335      00
 2336              	.LCFI169:
 2337 0fc4 83C349   	addl $73,%ebx
 2338 0fc7 53       	pushl %ebx
 2339              	.LCFI170:
 2340 0fc8 68520200 	pushl $.LC33
 2340      00
 2341              	.LCFI171:
 2342 0fcd E8FCFFFF 	call printk
 2342      FF
 2343 0fd2 83C41C   	addl $28,%esp
 2344              	.LCFI172:
 2345              	.L902:
 431:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 				   key, escape_essid(sec.keys[key], len),
 432:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 				   erq->length, len);
 433:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		sec.key_sizes[key] = len;
 2346              	.loc 1 433 0
 2347 0fd5 89E9     	movl %ebp,%ecx
 2348 0fd7 8B442410 	movl 16(%esp),%eax
 2349 0fdb 884C041E 	movb %cl,30(%esp,%eax)
 434:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		if (*crypt)
 2350              	.loc 1 434 0
 2351 0fdf 8B4C2408 	movl 8(%esp),%ecx
 2352 0fe3 8B11     	movl (%ecx),%edx
 2353 0fe5 85D2     	testl %edx,%edx
 2354 0fe7 7413     	je .L907
GAS LISTING  			page 101


 435:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 			(*crypt)->ops->set_key(sec.keys[key], len, NULL,
 2355              	.loc 1 435 0
 2356 0fe9 8B4208   	movl 8(%edx),%eax
 2357 0fec FF720C   	pushl 12(%edx)
 2358              	.LCFI173:
 2359 0fef 6A00     	pushl $0
 2360              	.LCFI174:
 2361 0ff1 55       	pushl %ebp
 2362              	.LCFI175:
 2363 0ff2 FF742410 	pushl 16(%esp)
 2364              	.LCFI176:
 2365 0ff6 FF5028   	call *40(%eax)
 2366 0ff9 83C410   	addl $16,%esp
 2367              	.LCFI177:
 2368              	.L907:
 436:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 					       (*crypt)->priv);
 437:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		sec.flags |= (1 << key);
 2369              	.loc 1 437 0
 2370 0ffc B8010000 	movl $1,%eax
 2370      00
 2371 1001 8A4C2410 	movb 16(%esp),%cl
 2372 1005 D3E0     	sall %cl,%eax
 2373 1007 668B9424 	movw 163(%esp),%dx
 2373      A3000000 
 2374 100f 09C2     	orl %eax,%edx
 438:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		/* This ensures a key will be activated if no key is
 439:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		 * explicitely set */
 440:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		if (key == sec.active_key)
 2375              	.loc 1 440 0
 2376 1011 660FB644 	movzbw 24(%esp),%ax
 2376      2418
 2377 1017 83E003   	andl $3,%eax
 2378 101a 39442410 	cmpl %eax,16(%esp)
 2379              	.loc 1 437 0
 2380 101e 66899424 	movw %dx,163(%esp)
 2380      A3000000 
 2381              	.loc 1 440 0
 2382 1026 0F852401 	jne .L909
 2382      0000
 441:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 			sec.flags |= SEC_ACTIVE_KEY;
 2383              	.loc 1 441 0
 2384 102c 83CA10   	orl $16,%edx
 2385 102f 66899424 	movw %dx,163(%esp)
 2385      A3000000 
 2386 1037 E9140100 	jmp .L909
 2386      00
 2387              	.L857:
 442:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 
 443:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	} else {
 444:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		if (host_crypto) {
 2388              	.loc 1 444 0
 2389 103c 85ED     	testl %ebp,%ebp
 2390 103e 0F849D00 	je .L910
 2390      0000
 445:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 			len = (*crypt)->ops->get_key(sec.keys[key], WEP_KEY_LEN,
 2391              	.loc 1 445 0
 2392 1044 8B542408 	movl 8(%esp),%edx
GAS LISTING  			page 102


 2393 1048 8B02     	movl (%edx),%eax
 2394 104a 8B5008   	movl 8(%eax),%edx
 2395 104d FF700C   	pushl 12(%eax)
 2396              	.LCFI178:
 2397 1050 6A00     	pushl $0
 2398              	.LCFI179:
 2399 1052 6A0D     	pushl $13
 2400              	.LCFI180:
 2401 1054 8B44241C 	movl 28(%esp),%eax
 2402 1058 C1E005   	sall $5,%eax
 2403 105b 8D74042E 	leal 46(%esp,%eax),%esi
 2404 105f 56       	pushl %esi
 2405              	.LCFI181:
 2406 1060 FF522C   	call *44(%edx)
 446:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 						     NULL, (*crypt)->priv);
 447:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 			if (len == 0) {
 2407              	.loc 1 447 0
 2408 1063 83C410   	addl $16,%esp
 2409              	.LCFI182:
 2410 1066 85C0     	testl %eax,%eax
 2411              	.loc 1 445 0
 2412 1068 89C5     	movl %eax,%ebp
 2413              	.loc 1 447 0
 2414 106a 7575     	jne .L910
 448:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 				/* Set a default key of all 0 */
 449:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 				IEEE80211_DEBUG_WX("Setting key %d to all "
 2415              	.loc 1 449 0
 2416 106c F6050000 	testb $2,ieee80211_debug_level
 2416      000002
 2417 1073 7431     	je .L912
 2418              	.LBB171:
 2419              	.LBB172:
 2420              	.loc 5 91 0
 2421 1075 B800E0FF 	movl $-8192,%eax
 2421      FF
 2422              	
 2423 107a 21E0     	andl %esp,%eax
 2424              	
 2425              	.LBE172:
 2426              	.LBE171:
 2427              	.loc 5 89 0
 2428 107c 8B4014   	movl 20(%eax),%eax
 2429 107f 2500FFFF 	andl $268435200,%eax
 2429      0F
 2430 1084 83F801   	cmpl $1,%eax
 2431 1087 19C0     	sbbl %eax,%eax
 2432 1089 FF742410 	pushl 16(%esp)
 2433              	.LCFI183:
 2434 108d 83E00C   	andl $12,%eax
 2435 1090 68160000 	pushl $__func__.1
 2435      00
 2436              	.LCFI184:
 2437 1095 83C049   	addl $73,%eax
 2438 1098 50       	pushl %eax
 2439              	.LCFI185:
 2440 1099 688C0200 	pushl $.LC34
 2440      00
GAS LISTING  			page 103


 2441              	.LCFI186:
 2442 109e E8FCFFFF 	call printk
 2442      FF
 2443 10a3 83C410   	addl $16,%esp
 2444              	.LCFI187:
 2445              	.L912:
 2446              	.LBB173:
 2447              	.LBB174:
 2448              	.LBB175:
 2449              	.loc 2 447 0
 2450 10a6 BB010000 	movl $1,%ebx
 2450      00
 449:include/asm/string.h **** 		case 1: COMMON("\n\tstosb"); return s;
 2451              	.loc 2 449 0
 2452 10ab B9030000 	movl $3,%ecx
 2452      00
 2453 10b0 89F7     	movl %esi,%edi
 2454 10b2 89E8     	movl %ebp,%eax
 2455              	
 2456 10b4 F3AB     	rep
 2457 10b6 AA       	stosb
 2458              	
 2459              	.LBE175:
 2460              	.LBE174:
 2461              	.LBE173:
 450:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 						   "zero.\n", key);
 451:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 				memset(sec.keys[key], 0, 13);
 452:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 				(*crypt)->ops->set_key(sec.keys[key], 13, NULL,
 2462              	.loc 1 452 0
 2463 10b7 8B542408 	movl 8(%esp),%edx
 2464 10bb 8B02     	movl (%edx),%eax
 2465 10bd 8B5008   	movl 8(%eax),%edx
 2466 10c0 FF700C   	pushl 12(%eax)
 2467              	.LCFI188:
 2468 10c3 6A00     	pushl $0
 2469              	.LCFI189:
 2470 10c5 6A0D     	pushl $13
 2471              	.LCFI190:
 2472 10c7 56       	pushl %esi
 2473              	.LCFI191:
 2474 10c8 FF5228   	call *40(%edx)
 453:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 						       (*crypt)->priv);
 454:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 				sec.key_sizes[key] = 13;
 2475              	.loc 1 454 0
 2476 10cb 8B4C2420 	movl 32(%esp),%ecx
 455:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 				sec.flags |= (1 << key);
 2477              	.loc 1 455 0
 2478 10cf D3E3     	sall %cl,%ebx
 2479              	.loc 1 454 0
 2480 10d1 C6440C2E 	movb $13,46(%esp,%ecx)
 2480      0D
 2481              	.loc 1 455 0
 2482 10d6 66099C24 	orw %bx,179(%esp)
 2482      B3000000 
 2483 10de 83C410   	addl $16,%esp
 2484              	.LCFI192:
 2485              	.L910:
GAS LISTING  			page 104


 456:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 			}
 457:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		}
 458:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		/* No key data - just set the default TX key index */
 459:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		if (key_provided) {
 2486              	.loc 1 459 0
 2487 10e1 837C240C 	cmpl $0,12(%esp)
 2487      00
 2488 10e6 7468     	je .L909
 460:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 			IEEE80211_DEBUG_WX("Setting key %d to default Tx "
 2489              	.loc 1 460 0
 2490 10e8 F6050000 	testb $2,ieee80211_debug_level
 2490      000002
 2491 10ef 7431     	je .L931
 2492              	.LBB176:
 2493              	.LBB177:
 2494              	.loc 5 91 0
 2495 10f1 B800E0FF 	movl $-8192,%eax
 2495      FF
 2496              	
 2497 10f6 21E0     	andl %esp,%eax
 2498              	
 2499              	.LBE177:
 2500              	.LBE176:
 2501              	.loc 5 89 0
 2502 10f8 8B4014   	movl 20(%eax),%eax
 2503 10fb 2500FFFF 	andl $268435200,%eax
 2503      0F
 2504 1100 83F801   	cmpl $1,%eax
 2505 1103 19C0     	sbbl %eax,%eax
 2506 1105 FF742410 	pushl 16(%esp)
 2507              	.LCFI193:
 2508 1109 83E00C   	andl $12,%eax
 2509 110c 68160000 	pushl $__func__.1
 2509      00
 2510              	.LCFI194:
 2511 1111 83C049   	addl $73,%eax
 2512 1114 50       	pushl %eax
 2513              	.LCFI195:
 2514 1115 68BD0200 	pushl $.LC35
 2514      00
 2515              	.LCFI196:
 2516 111a E8FCFFFF 	call printk
 2516      FF
 2517 111f 83C410   	addl $16,%esp
 2518              	.LCFI197:
 2519              	.L931:
 461:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 					   "key.\n", key);
 462:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 			ieee->tx_keyidx = key;
 2520              	.loc 1 462 0
 2521 1122 8B542410 	movl 16(%esp),%edx
 2522 1126 8B8424BC 	movl 188(%esp),%eax
 2522      000000
 2523 112d 8990B006 	movl %edx,1712(%eax)
 2523      0000
 463:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 			sec.active_key = key;
 2524              	.loc 1 463 0
 2525 1133 8A442418 	movb 24(%esp),%al
GAS LISTING  			page 105


 2526 1137 8A542410 	movb 16(%esp),%dl
 2527 113b 83E203   	andl $3,%edx
 2528 113e 83E0FC   	andl $-4,%eax
 2529 1141 09D0     	orl %edx,%eax
 2530 1143 88442418 	movb %al,24(%esp)
 464:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 			sec.flags |= SEC_ACTIVE_KEY;
 2531              	.loc 1 464 0
 2532 1147 66838C24 	orw $16,163(%esp)
 2532      A3000000 
 2532      10
 2533              	.L909:
 465:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		}
 466:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	}
 467:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	if (erq->flags & (IW_ENCODE_OPEN | IW_ENCODE_RESTRICTED)) {
 2534              	.loc 1 467 0
 2535 1150 8B8C24C4 	movl 196(%esp),%ecx
 2535      000000
 2536 1157 0FB74106 	movzwl 6(%ecx),%eax
 2537 115b F6C460   	testb $96,%ah
 2538 115e 747A     	je .L936
 468:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		ieee->open_wep = !(erq->flags & IW_ENCODE_RESTRICTED);
 2539              	.loc 1 468 0
 2540 1160 C1E80E   	shrl $14,%eax
 2541 1163 83F001   	xorl $1,%eax
 2542 1166 83E001   	andl $1,%eax
 2543 1169 8B9424BC 	movl 188(%esp),%edx
 2543      000000
 469:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		sec.auth_mode = ieee->open_wep ? WLAN_AUTH_OPEN :
 2544              	.loc 1 469 0
 2545 1170 85C0     	testl %eax,%eax
 2546              	.loc 1 468 0
 2547 1172 89826006 	movl %eax,1632(%edx)
 2547      0000
 2548              	.loc 1 469 0
 2549 1178 8A542418 	movb 24(%esp),%dl
 2550 117c 0F94C0   	sete %al
 2551 117f C1E003   	sall $3,%eax
 2552 1182 83E2E7   	andl $-25,%edx
 2553 1185 09C2     	orl %eax,%edx
 470:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		    WLAN_AUTH_SHARED_KEY;
 471:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		sec.flags |= SEC_AUTH_MODE;
 2554              	.loc 1 471 0
 2555 1187 66838C24 	orw $32,163(%esp)
 2555      A3000000 
 2555      20
 472:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		IEEE80211_DEBUG_WX("Auth: %s\n",
 2556              	.loc 1 472 0
 2557 1190 F6050000 	testb $2,ieee80211_debug_level
 2557      000002
 2558              	.loc 1 469 0
 2559 1197 88542418 	movb %dl,24(%esp)
 2560              	.loc 1 472 0
 2561 119b 743D     	je .L936
 2562              	.LBB178:
 2563              	.LBB179:
 2564              	.loc 5 91 0
 2565 119d B800E0FF 	movl $-8192,%eax
GAS LISTING  			page 106


 2565      FF
 2566              	
 2567 11a2 21E0     	andl %esp,%eax
 2568              	
 2569              	.LBE179:
 2570              	.LBE178:
 2571              	.loc 5 89 0
 2572 11a4 8B4014   	movl 20(%eax),%eax
 2573 11a7 2500FFFF 	andl $268435200,%eax
 2573      0F
 2574 11ac 83F801   	cmpl $1,%eax
 2575 11af 19C0     	sbbl %eax,%eax
 2576 11b1 83E00C   	andl $12,%eax
 2577 11b4 83C049   	addl $73,%eax
 2578 11b7 80E208   	andb $8,%dl
 2579 11ba B9F40200 	movl $.LC36,%ecx
 2579      00
 2580 11bf 7405     	je .L945
 2581 11c1 B9F90200 	movl $.LC37,%ecx
 2581      00
 2582              	.L945:
 2583 11c6 51       	pushl %ecx
 2584              	.LCFI198:
 2585 11c7 68160000 	pushl $__func__.1
 2585      00
 2586              	.LCFI199:
 2587 11cc 50       	pushl %eax
 2588              	.LCFI200:
 2589 11cd 68040300 	pushl $.LC38
 2589      00
 2590              	.LCFI201:
 2591 11d2 E8FCFFFF 	call printk
 2591      FF
 2592 11d7 83C410   	addl $16,%esp
 2593              	.LCFI202:
 2594              	.L936:
 473:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 				   sec.auth_mode == WLAN_AUTH_OPEN ?
 474:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 				   "OPEN" : "SHARED KEY");
 475:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	}
 476:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 
 477:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	/* For now we just support WEP, so only set that security level...
 478:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	 * TODO: When WPA is added this is one place that needs to change */
 479:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	sec.flags |= SEC_LEVEL;
 480:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	sec.level = SEC_LEVEL_1;	/* 40 and 104 bit WEP */
 481:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	sec.encode_alg[key] = SEC_ALG_WEP;
 2595              	.loc 1 481 0
 2596 11da 8B4C2410 	movl 16(%esp),%ecx
 2597              	.loc 1 479 0
 2598 11de 66818C24 	orw $128,163(%esp)
 2598      A3000000 
 2598      8000
 2599              	.loc 1 480 0
 2600 11e8 C68424A2 	movb $1,162(%esp)
 2600      00000001 
 2601              	.loc 1 481 0
 2602 11f0 C6440C1A 	movb $1,26(%esp,%ecx)
 2602      01
GAS LISTING  			page 107


 2603              	.L794:
 482:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 
 483:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c ****       done:
 484:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	if (ieee->set_security)
 2604              	.loc 1 484 0
 2605 11f5 8B8424BC 	movl 188(%esp),%eax
 2605      000000
 2606 11fc 8B907407 	movl 1908(%eax),%edx
 2606      0000
 2607 1202 85D2     	testl %edx,%edx
 2608 1204 740D     	je .L946
 485:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		ieee->set_security(dev, &sec);
 2609              	.loc 1 485 0
 2610 1206 8D442418 	leal 24(%esp),%eax
 2611 120a 50       	pushl %eax
 2612              	.LCFI203:
 2613 120b FF742418 	pushl 24(%esp)
 2614              	.LCFI204:
 2615 120f FFD2     	call *%edx
 2616 1211 5F       	popl %edi
 2617              	.LCFI205:
 2618 1212 5D       	popl %ebp
 2619              	.LCFI206:
 2620              	.L946:
 486:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 
 487:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	/* Do not reset port if card is in Managed mode since resetting will
 488:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	 * generate new IEEE 802.11 authentication which may end up in looping
 489:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	 * with IEEE 802.1X.  If your hardware requires a reset after WEP
 490:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	 * configuration (for example... Prism2), implement the reset_port in
 491:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	 * the callbacks structures used to initialize the 802.11 stack. */
 492:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	if (ieee->reset_on_keychange &&
 2621              	.loc 1 492 0
 2622 1213 8B9424BC 	movl 188(%esp),%edx
 2622      000000
 2623 121a 83BA6406 	cmpl $0,1636(%edx)
 2623      000000
 2624 1221 7435     	je .L947
 2625 1223 83BAF005 	cmpl $2,1520(%edx)
 2625      000002
 2626 122a 742C     	je .L947
 2627 122c 8B827C07 	movl 1916(%edx),%eax
 2627      0000
 2628 1232 85C0     	testl %eax,%eax
 2629 1234 7422     	je .L947
 2630 1236 FF742414 	pushl 20(%esp)
 2631              	.LCFI207:
 2632 123a FFD0     	call *%eax
 2633 123c 85C0     	testl %eax,%eax
 2634 123e 5E       	popl %esi
 2635              	.LCFI208:
 2636 123f 7417     	je .L947
 493:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	    ieee->iw_mode != IW_MODE_INFRA &&
 494:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	    ieee->reset_port && ieee->reset_port(dev)) {
 495:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		printk(KERN_DEBUG "%s: reset_port failed\n", dev->name);
 2637              	.loc 1 495 0
 2638 1241 FF742414 	pushl 20(%esp)
 2639              	.LCFI209:
GAS LISTING  			page 108


 2640 1245 68220300 	pushl $.LC39
 2640      00
 2641              	.LCFI210:
 2642 124a E8FCFFFF 	call printk
 2642      FF
 496:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		return -EINVAL;
 2643              	.loc 1 496 0
 2644 124f 59       	popl %ecx
 2645              	.LCFI211:
 2646 1250 B8EAFFFF 	movl $-22,%eax
 2646      FF
 2647 1255 5B       	popl %ebx
 2648              	.LCFI212:
 2649 1256 EB02     	jmp .L756
 2650              	.L947:
 497:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	}
 498:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	return 0;
 2651              	.loc 1 498 0
 2652 1258 31C0     	xorl %eax,%eax
 2653              	.L756:
 499:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** }
 2654              	.loc 1 499 0
 2655 125a 81C4A800 	addl $168,%esp
 2655      0000
 2656 1260 5B       	popl %ebx
 2657 1261 5E       	popl %esi
 2658 1262 5F       	popl %edi
 2659 1263 5D       	popl %ebp
 2660 1264 C3       	ret
 2661              	.LFE667:
 2663              	.section .rodata
 2666              	__func__.2:
 2667 002e 69656565 	.string "ieee80211_wx_get_encode"
 2667      38303231 
 2667      315F7778 
 2667      5F676574 
 2667      5F656E63 
 2668              	.section .rodata.str1.1
 2669              	.LC40:
 2670 033c 3C373E69 	.string "<7>ieee80211: %c %s GET_ENCODE\n"
 2670      65656538 
 2670      30323131 
 2670      3A202563 
 2670      20257320 
 2671              	.text
 2672              	.globl ieee80211_wx_get_encode
 2674              	ieee80211_wx_get_encode:
 2675              	.LFB668:
 500:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 
 501:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** int ieee80211_wx_get_encode(struct ieee80211_device *ieee,
 502:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 			    struct iw_request_info *info,
 503:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 			    union iwreq_data *wrqu, char *keybuf)
 504:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** {
 2676              	.loc 1 504 0
 2677 1265 55       	pushl %ebp
 2678              	.LCFI213:
 2679 1266 57       	pushl %edi
GAS LISTING  			page 109


 2680              	.LCFI214:
 2681 1267 56       	pushl %esi
 2682              	.LCFI215:
 2683 1268 53       	pushl %ebx
 2684              	.LCFI216:
 2685              	.loc 1 504 0
 2686 1269 8B6C2414 	movl 20(%esp),%ebp
 505:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	struct iw_point *erq = &(wrqu->encoding);
 506:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	int len, key;
 507:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	struct ieee80211_crypt_data *crypt;
 508:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	struct ieee80211_security *sec = &ieee->sec;
 509:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 
 510:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	IEEE80211_DEBUG_WX("GET_ENCODE\n");
 2687              	.loc 1 510 0
 2688 126d F6050000 	testb $2,ieee80211_debug_level
 2688      000002
 2689              	.loc 1 504 0
 2690 1274 8B5C241C 	movl 28(%esp),%ebx
 2691 1278 8B7C2420 	movl 32(%esp),%edi
 2692              	.loc 1 508 0
 2693 127c 8D7504   	leal 4(%ebp),%esi
 2694              	.loc 1 510 0
 2695 127f 742D     	je .L952
 2696              	.LBB180:
 2697              	.LBB181:
 2698              	.loc 5 91 0
 2699 1281 B800E0FF 	movl $-8192,%eax
 2699      FF
 2700              	
 2701 1286 21E0     	andl %esp,%eax
 2702              	
 2703              	.LBE181:
 2704              	.LBE180:
 2705              	.loc 5 89 0
 2706 1288 8B4014   	movl 20(%eax),%eax
 2707 128b 2500FFFF 	andl $268435200,%eax
 2707      0F
 2708 1290 83F801   	cmpl $1,%eax
 2709 1293 19C0     	sbbl %eax,%eax
 2710 1295 83E00C   	andl $12,%eax
 2711 1298 682E0000 	pushl $__func__.2
 2711      00
 2712              	.LCFI217:
 2713 129d 83C049   	addl $73,%eax
 2714 12a0 50       	pushl %eax
 2715              	.LCFI218:
 2716 12a1 683C0300 	pushl $.LC40
 2716      00
 2717              	.LCFI219:
 2718 12a6 E8FCFFFF 	call printk
 2718      FF
 2719 12ab 83C40C   	addl $12,%esp
 2720              	.LCFI220:
 2721              	.L952:
 511:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 
 512:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	key = erq->flags & IW_ENCODE_INDEX;
 2722              	.loc 1 512 0
GAS LISTING  			page 110


 2723 12ae 0FB65306 	movzbl 6(%ebx),%edx
 513:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	if (key) {
 2724              	.loc 1 513 0
 2725 12b2 85D2     	testl %edx,%edx
 2726 12b4 740D     	je .L957
 514:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		if (key > WEP_KEYS)
 2727              	.loc 1 514 0
 2728 12b6 83FA04   	cmpl $4,%edx
 515:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 			return -EINVAL;
 2729              	.loc 1 515 0
 2730 12b9 B8EAFFFF 	movl $-22,%eax
 2730      FF
 2731              	.loc 1 514 0
 2732 12be 7F5C     	jg .L951
 516:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		key--;
 2733              	.loc 1 516 0
 2734 12c0 4A       	decl %edx
 2735 12c1 EB06     	jmp .L959
 2736              	.L957:
 517:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	} else
 518:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		key = ieee->tx_keyidx;
 2737              	.loc 1 518 0
 2738 12c3 8B95B006 	movl 1712(%ebp),%edx
 2738      0000
 2739              	.L959:
 519:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 
 520:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	crypt = ieee->crypt[key];
 521:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	erq->flags = key + 1;
 2740              	.loc 1 521 0
 2741 12c9 8D4201   	leal 1(%edx),%eax
 2742 12cc 66894306 	movw %ax,6(%ebx)
 522:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 
 523:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	if (!sec->enabled) {
 2743              	.loc 1 523 0
 2744 12d0 F60604   	testb $4,(%esi)
 2745 12d3 750C     	jne .L960
 524:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		erq->length = 0;
 525:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		erq->flags |= IW_ENCODE_DISABLED;
 2746              	.loc 1 525 0
 2747 12d5 660D0080 	orw $-32768,%ax
 2748              	.loc 1 524 0
 2749 12d9 66C74304 	movw $0,4(%ebx)
 2749      0000
 2750 12df EB35     	jmp .L989
 2751              	.L960:
 526:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		return 0;
 527:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	}
 528:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 
 529:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	len = sec->key_sizes[key];
 2752              	.loc 1 529 0
 2753 12e1 0FB64416 	movzbl 6(%esi,%edx),%eax
 2753      06
 2754              	.LBB182:
 2755              	.LBB183:
 2756              	.loc 2 207 0
 2757 12e6 89C1     	movl %eax,%ecx
 2758              	.LBE183:
GAS LISTING  			page 111


 2759              	.loc 2 205 0
 2760 12e8 C1E205   	sall $5,%edx
 2761 12eb 8D74160A 	leal 10(%esi,%edx),%esi
 2762              	.LBB184:
 2763              	.loc 2 207 0
 2764 12ef C1E902   	shrl $2,%ecx
 2765              	
 2766 12f2 F3A5     	rep
 2767 12f4 89C1     	movl %eax,%ecx
 2768 12f6 83E103   	andl $3,%ecx
 2769 12f9 7402     	jz 1f
 2770 12fb F3A4     	rep
 2771              	1:
 2772              	
 2773              	.LBE184:
 2774              	.LBE182:
 530:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	memcpy(keybuf, sec->keys[key], len);
 531:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 
 532:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	erq->length = (len >= 0 ? len : 0);
 2775              	.loc 1 532 0
 2776 12fd 66894304 	movw %ax,4(%ebx)
 533:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	erq->flags |= IW_ENCODE_ENABLED;
 534:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 
 535:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	if (ieee->open_wep)
 2777              	.loc 1 535 0
 2778 1301 83BD6006 	cmpl $0,1632(%ebp)
 2778      000000
 2779 1308 668B4306 	movw 6(%ebx),%ax
 2780 130c 7405     	je .L987
 536:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		erq->flags |= IW_ENCODE_OPEN;
 2781              	.loc 1 536 0
 2782 130e 80CC20   	orb $32,%ah
 2783 1311 EB03     	jmp .L989
 2784              	.L987:
 537:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	else
 538:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 		erq->flags |= IW_ENCODE_RESTRICTED;
 2785              	.loc 1 538 0
 2786 1313 80CC40   	orb $64,%ah
 2787              	.L989:
 2788 1316 66894306 	movw %ax,6(%ebx)
 539:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 
 540:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** 	return 0;
 2789              	.loc 1 540 0
 2790 131a 31C0     	xorl %eax,%eax
 2791              	.L951:
 541:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_wx.c **** }
 2792              	.loc 1 541 0
 2793 131c 5B       	popl %ebx
 2794 131d 5E       	popl %esi
 2795 131e 5F       	popl %edi
 2796 131f 5D       	popl %ebp
 2797 1320 C3       	ret
 2798              	.LFE668:
 2800              	.section __kcrctab,"a",@progbits
 2801              	.align 4
 2804              	__kcrctab_ieee80211_wx_get_scan:
 2805 0000 00000000 	.long __crc_ieee80211_wx_get_scan
GAS LISTING  			page 112


 2806              	.section __ksymtab_strings,"a",@progbits
 2809              	__kstrtab_ieee80211_wx_get_scan:
 2810 0000 69656565 	.string "ieee80211_wx_get_scan"
 2810      38303231 
 2810      315F7778 
 2810      5F676574 
 2810      5F736361 
 2811              	.section __ksymtab,"a",@progbits
 2812              	.align 4
 2815              	__ksymtab_ieee80211_wx_get_scan:
 2816 0000 00000000 	.long ieee80211_wx_get_scan
 2817 0004 00000000 	.long __kstrtab_ieee80211_wx_get_scan
 2818              	.section __kcrctab
 2819              	.align 4
 2822              	__kcrctab_ieee80211_wx_set_encode:
 2823 0004 00000000 	.long __crc_ieee80211_wx_set_encode
 2824              	.section __ksymtab_strings
 2827              	__kstrtab_ieee80211_wx_set_encode:
 2828 0016 69656565 	.string "ieee80211_wx_set_encode"
 2828      38303231 
 2828      315F7778 
 2828      5F736574 
 2828      5F656E63 
 2829              	.section __ksymtab
 2830              	.align 4
 2833              	__ksymtab_ieee80211_wx_set_encode:
 2834 0008 00000000 	.long ieee80211_wx_set_encode
 2835 000c 16000000 	.long __kstrtab_ieee80211_wx_set_encode
 2836              	.section __kcrctab
 2837              	.align 4
 2840              	__kcrctab_ieee80211_wx_get_encode:
 2841 0008 00000000 	.long __crc_ieee80211_wx_get_encode
 2842              	.section __ksymtab_strings
 2845              	__kstrtab_ieee80211_wx_get_encode:
 2846 002e 69656565 	.string "ieee80211_wx_get_encode"
 2846      38303231 
 2846      315F7778 
 2846      5F676574 
 2846      5F656E63 
 2847              	.section __ksymtab
 2848              	.align 4
 2851              	__ksymtab_ieee80211_wx_get_encode:
 2852 0010 00000000 	.long ieee80211_wx_get_encode
 2853 0014 2E000000 	.long __kstrtab_ieee80211_wx_get_encode
 2854              	.weak __crc_ieee80211_wx_get_encode
 2855              	.weak __crc_ieee80211_wx_set_encode
 2856              	.weak __crc_ieee80211_wx_get_scan
 4290              	.Letext0:
 32204              	.ident "GCC: (GNU) 3.4.5 20050809 (prerelease) (Ubuntu 3.4.4-6ubuntu8.1)"
GAS LISTING  			page 113


DEFINED SYMBOLS
                            *ABS*:0000000000000000 ieee80211_wx.c
 {entrada estndar}:31     .data:0000000000000000 ieee80211_modes
 {entrada estndar}:69     .text:0000000000000000 ipw2100_translate_scan
 {entrada estndar}:1411   .rodata:0000000000000000 __func__.0
 {entrada estndar}:1423   .text:00000000000009d5 ieee80211_wx_get_scan
 {entrada estndar}:1722   .rodata:0000000000000016 __func__.1
 {entrada estndar}:1760   .text:0000000000000b9e ieee80211_wx_set_encode
 {entrada estndar}:2666   .rodata:000000000000002e __func__.2
 {entrada estndar}:2674   .text:0000000000001265 ieee80211_wx_get_encode
 {entrada estndar}:2804   __kcrctab:0000000000000000 __kcrctab_ieee80211_wx_get_scan
 {entrada estndar}:2809   __ksymtab_strings:0000000000000000 __kstrtab_ieee80211_wx_get_scan
 {entrada estndar}:2815   __ksymtab:0000000000000000 __ksymtab_ieee80211_wx_get_scan
 {entrada estndar}:2822   __kcrctab:0000000000000004 __kcrctab_ieee80211_wx_set_encode
 {entrada estndar}:2827   __ksymtab_strings:0000000000000016 __kstrtab_ieee80211_wx_set_encode
 {entrada estndar}:2833   __ksymtab:0000000000000008 __ksymtab_ieee80211_wx_set_encode
 {entrada estndar}:2840   __kcrctab:0000000000000008 __kcrctab_ieee80211_wx_get_encode
 {entrada estndar}:2845   __ksymtab_strings:000000000000002e __kstrtab_ieee80211_wx_get_encode
 {entrada estndar}:2851   __ksymtab:0000000000000010 __ksymtab_ieee80211_wx_get_encode

UNDEFINED SYMBOLS
snprintf
sprintf
jiffies
ieee80211_get_channel_flags
ieee80211_debug_level
printk
escape_essid
memset
ieee80211_crypt_delayed_deinit
malloc_sizes
kmem_cache_alloc
ieee80211_get_crypto_ops
request_module
kfree
__crc_ieee80211_wx_get_scan
__crc_ieee80211_wx_set_encode
__crc_ieee80211_wx_get_encode
