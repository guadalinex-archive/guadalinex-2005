GAS LISTING  			page 1


   1              	.file "ieee80211_crypt_wep.c"
   9              	.Ltext0:
  10              	.section .modinfo,"a",@progbits
  13              	__mod_author26:
  14 0000 61757468 	.string "author=Jouni Malinen"
  14      6F723D4A 
  14      6F756E69 
  14      204D616C 
  14      696E656E 
  17              	__mod_description27:
  18 0015 64657363 	.string "description=Host AP crypt: WEP"
  18      72697074 
  18      696F6E3D 
  18      486F7374 
  18      20415020 
  21              	__mod_license28:
  22 0034 6C696365 	.string "license=GPL"
  22      6E73653D 
  22      47504C00 
  23              	.section .rodata.str1.1,"aMS",@progbits,1
  24              	.LC0:
  25 0000 61726334 	.string "arc4"
  25      00
  26              	.LC1:
  27 0005 3C373E69 	.string "<7>ieee80211_crypt_wep: could not allocate crypto API arc4\n"
  27      65656538 
  27      30323131 
  27      5F637279 
  27      70745F77 
  28              	.text
  30              	prism2_wep_init:
  31              	.LFB687:
  32              	.file 1 "/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c"
   1:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** /*
   2:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c ****  * Host AP crypt: host-based WEP encryption implementation for Host AP driver
   3:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c ****  *
   4:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c ****  * Copyright (c) 2002-2004, Jouni Malinen <jkmaline@cc.hut.fi>
   5:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c ****  *
   6:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c ****  * This program is free software; you can redistribute it and/or modify
   7:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c ****  * it under the terms of the GNU General Public License version 2 as
   8:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c ****  * published by the Free Software Foundation. See README and COPYING for
   9:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c ****  * more details.
  10:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c ****  */
  11:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 
  12:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** #include <linux/config.h>
  13:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** #include <linux/module.h>
  14:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** #include <linux/init.h>
  15:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** #include <linux/slab.h>
  16:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** #include <linux/random.h>
  17:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** #include <linux/skbuff.h>
  18:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** #include <asm/string.h>
  19:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 
  20:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** #include <net/ieee80211.h>
  21:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 
  22:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** #include <linux/crypto.h>
  23:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** #include <asm/scatterlist.h>
  24:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** #include <linux/crc32.h>
GAS LISTING  			page 2


  25:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 
  26:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** MODULE_AUTHOR("Jouni Malinen");
  27:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** MODULE_DESCRIPTION("Host AP crypt: WEP");
  28:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** MODULE_LICENSE("GPL");
  29:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 
  30:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** struct prism2_wep_data {
  31:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	u32 iv;
  32:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** #define WEP_KEY_LEN 13
  33:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	u8 key[WEP_KEY_LEN + 1];
  34:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	u8 key_len;
  35:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	u8 key_idx;
  36:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	struct crypto_tfm *tfm;
  37:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** };
  38:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 
  39:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** static void *prism2_wep_init(int keyidx)
  40:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** {
  33              	.loc 1 40 0
  34              	.L4:
  35 0000 57       	pushl %edi
  36              	.LCFI0:
  37 0001 56       	pushl %esi
  38              	.LCFI1:
  39 0002 53       	pushl %ebx
  40              	.LCFI2:
  41              	.loc 1 40 0
  42 0003 51       	pushl %ecx
  43              	.LCFI3:
  44              	.LBB2:
  45              	.LBB3:
  46              	.LBB4:
  47              	.file 2 "include/linux/slab.h"
   1:include/linux/slab.h **** /*
   2:include/linux/slab.h ****  * linux/mm/slab.h
   3:include/linux/slab.h ****  * Written by Mark Hemment, 1996.
   4:include/linux/slab.h ****  * (markhe@nextd.demon.co.uk)
   5:include/linux/slab.h ****  */
   6:include/linux/slab.h **** 
   7:include/linux/slab.h **** #ifndef _LINUX_SLAB_H
   8:include/linux/slab.h **** #define	_LINUX_SLAB_H
   9:include/linux/slab.h **** 
  10:include/linux/slab.h **** #if	defined(__KERNEL__)
  11:include/linux/slab.h **** 
  12:include/linux/slab.h **** typedef struct kmem_cache_s kmem_cache_t;
  13:include/linux/slab.h **** 
  14:include/linux/slab.h **** #include	<linux/config.h>	/* kmalloc_sizes.h needs CONFIG_ options */
  15:include/linux/slab.h **** #include	<linux/gfp.h>
  16:include/linux/slab.h **** #include	<linux/init.h>
  17:include/linux/slab.h **** #include	<linux/types.h>
  18:include/linux/slab.h **** #include	<asm/page.h>		/* kmalloc_sizes.h needs PAGE_SIZE */
  19:include/linux/slab.h **** #include	<asm/cache.h>		/* kmalloc_sizes.h needs L1_CACHE_BYTES */
  20:include/linux/slab.h **** 
  21:include/linux/slab.h **** /* flags for kmem_cache_alloc() */
  22:include/linux/slab.h **** #define	SLAB_NOFS		GFP_NOFS
  23:include/linux/slab.h **** #define	SLAB_NOIO		GFP_NOIO
  24:include/linux/slab.h **** #define	SLAB_ATOMIC		GFP_ATOMIC
  25:include/linux/slab.h **** #define	SLAB_USER		GFP_USER
  26:include/linux/slab.h **** #define	SLAB_KERNEL		GFP_KERNEL
GAS LISTING  			page 3


  27:include/linux/slab.h **** #define	SLAB_DMA		GFP_DMA
  28:include/linux/slab.h **** 
  29:include/linux/slab.h **** #define SLAB_LEVEL_MASK		GFP_LEVEL_MASK
  30:include/linux/slab.h **** 
  31:include/linux/slab.h **** #define	SLAB_NO_GROW		__GFP_NO_GROW	/* don't grow a cache */
  32:include/linux/slab.h **** 
  33:include/linux/slab.h **** /* flags to pass to kmem_cache_create().
  34:include/linux/slab.h ****  * The first 3 are only valid when the allocator as been build
  35:include/linux/slab.h ****  * SLAB_DEBUG_SUPPORT.
  36:include/linux/slab.h ****  */
  37:include/linux/slab.h **** #define	SLAB_DEBUG_FREE		0x00000100UL	/* Peform (expensive) checks on free */
  38:include/linux/slab.h **** #define	SLAB_DEBUG_INITIAL	0x00000200UL	/* Call constructor (as verifier) */
  39:include/linux/slab.h **** #define	SLAB_RED_ZONE		0x00000400UL	/* Red zone objs in a cache */
  40:include/linux/slab.h **** #define	SLAB_POISON		0x00000800UL	/* Poison objects */
  41:include/linux/slab.h **** #define	SLAB_NO_REAP		0x00001000UL	/* never reap from the cache */
  42:include/linux/slab.h **** #define	SLAB_HWCACHE_ALIGN	0x00002000UL	/* align objs on a h/w cache lines */
  43:include/linux/slab.h **** #define SLAB_CACHE_DMA		0x00004000UL	/* use GFP_DMA memory */
  44:include/linux/slab.h **** #define SLAB_MUST_HWCACHE_ALIGN	0x00008000UL	/* force alignment */
  45:include/linux/slab.h **** #define SLAB_STORE_USER		0x00010000UL	/* store the last owner for bug hunting */
  46:include/linux/slab.h **** #define SLAB_RECLAIM_ACCOUNT	0x00020000UL	/* track pages allocated to indicate
  47:include/linux/slab.h **** 						   what is reclaimable later*/
  48:include/linux/slab.h **** #define SLAB_PANIC		0x00040000UL	/* panic if kmem_cache_create() fails */
  49:include/linux/slab.h **** #define SLAB_DESTROY_BY_RCU	0x00080000UL	/* defer freeing pages to RCU */
  50:include/linux/slab.h **** 
  51:include/linux/slab.h **** /* flags passed to a constructor func */
  52:include/linux/slab.h **** #define	SLAB_CTOR_CONSTRUCTOR	0x001UL		/* if not set, then deconstructor */
  53:include/linux/slab.h **** #define SLAB_CTOR_ATOMIC	0x002UL		/* tell constructor it can't sleep */
  54:include/linux/slab.h **** #define	SLAB_CTOR_VERIFY	0x004UL		/* tell constructor it's a verify call */
  55:include/linux/slab.h **** 
  56:include/linux/slab.h **** /* prototypes */
  57:include/linux/slab.h **** extern void __init kmem_cache_init(void);
  58:include/linux/slab.h **** 
  59:include/linux/slab.h **** extern kmem_cache_t *kmem_cache_create(const char *, size_t, size_t, unsigned long,
  60:include/linux/slab.h **** 				       void (*)(void *, kmem_cache_t *, unsigned long),
  61:include/linux/slab.h **** 				       void (*)(void *, kmem_cache_t *, unsigned long));
  62:include/linux/slab.h **** extern int kmem_cache_destroy(kmem_cache_t *);
  63:include/linux/slab.h **** extern int kmem_cache_shrink(kmem_cache_t *);
  64:include/linux/slab.h **** extern void *kmem_cache_alloc(kmem_cache_t *, unsigned int __nocast);
  65:include/linux/slab.h **** extern void kmem_cache_free(kmem_cache_t *, void *);
  66:include/linux/slab.h **** extern unsigned int kmem_cache_size(kmem_cache_t *);
  67:include/linux/slab.h **** extern kmem_cache_t *kmem_find_general_cachep(size_t size, int gfpflags);
  68:include/linux/slab.h **** 
  69:include/linux/slab.h **** /* Size description struct for general caches. */
  70:include/linux/slab.h **** struct cache_sizes {
  71:include/linux/slab.h **** 	size_t		 cs_size;
  72:include/linux/slab.h **** 	kmem_cache_t	*cs_cachep;
  73:include/linux/slab.h **** 	kmem_cache_t	*cs_dmacachep;
  74:include/linux/slab.h **** };
  75:include/linux/slab.h **** extern struct cache_sizes malloc_sizes[];
  76:include/linux/slab.h **** extern void *__kmalloc(size_t, unsigned int __nocast);
  77:include/linux/slab.h **** 
  78:include/linux/slab.h **** static inline void *kmalloc(size_t size, unsigned int __nocast flags)
  79:include/linux/slab.h **** {
  80:include/linux/slab.h **** 	if (__builtin_constant_p(size)) {
  81:include/linux/slab.h **** 		int i = 0;
  82:include/linux/slab.h **** #define CACHE(x) \
  83:include/linux/slab.h **** 		if (size <= x) \
GAS LISTING  			page 4


  84:include/linux/slab.h **** 			goto found; \
  85:include/linux/slab.h **** 		else \
  86:include/linux/slab.h **** 			i++;
  87:include/linux/slab.h **** #include "kmalloc_sizes.h"
  88:include/linux/slab.h **** #undef CACHE
  89:include/linux/slab.h **** 		{
  90:include/linux/slab.h **** 			extern void __you_cannot_kmalloc_that_much(void);
  91:include/linux/slab.h **** 			__you_cannot_kmalloc_that_much();
  92:include/linux/slab.h **** 		}
  93:include/linux/slab.h **** found:
  48              	.loc 2 93 0
  49 0004 6A20     	pushl $32
  50              	.LCFI4:
  51 0006 FF350400 	pushl malloc_sizes+4
  51      0000
  52              	.LCFI5:
  53              	.LCFI6:
  54 000c E8FCFFFF 	call kmem_cache_alloc
  54      FF
  55              	.loc 2 81 0
  56 0011 31F6     	xorl %esi,%esi
  57              	.loc 2 93 0
  58 0013 5F       	popl %edi
  59              	.LCFI7:
  60              	.LBE4:
  61              	.LBE3:
  62              	.LBE2:
  41:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	struct prism2_wep_data *priv;
  42:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 
  43:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	priv = kmalloc(sizeof(*priv), GFP_ATOMIC);
  44:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	if (priv == NULL)
  63              	.loc 1 44 0
  64 0014 85C0     	testl %eax,%eax
  65              	.LBB5:
  66              	.LBB6:
  67              	.LBB7:
  68              	.loc 2 93 0
  69 0016 5A       	popl %edx
  70              	.LCFI8:
  71 0017 89C3     	movl %eax,%ebx
  72              	.LBE7:
  73              	.LBE6:
  74              	.LBE5:
  75              	.loc 1 44 0
  76 0019 7455     	je .L49
  77              	.LBB8:
  78              	.LBB9:
  79              	.LBB10:
  80              	.file 3 "include/asm/string.h"
   1:include/asm/string.h **** #ifndef _I386_STRING_H_
   2:include/asm/string.h **** #define _I386_STRING_H_
   3:include/asm/string.h **** 
   4:include/asm/string.h **** #ifdef __KERNEL__
   5:include/asm/string.h **** #include <linux/config.h>
   6:include/asm/string.h **** /*
   7:include/asm/string.h ****  * On a 486 or Pentium, we are better off not using the
   8:include/asm/string.h ****  * byte string operations. But on a 386 or a PPro the
GAS LISTING  			page 5


   9:include/asm/string.h ****  * byte string ops are faster than doing it by hand
  10:include/asm/string.h ****  * (MUCH faster on a Pentium).
  11:include/asm/string.h ****  */
  12:include/asm/string.h **** 
  13:include/asm/string.h **** /*
  14:include/asm/string.h ****  * This string-include defines all string functions as inline
  15:include/asm/string.h ****  * functions. Use gcc. It also assumes ds=es=data space, this should be
  16:include/asm/string.h ****  * normal. Most of the string-functions are rather heavily hand-optimized,
  17:include/asm/string.h ****  * see especially strsep,strstr,str[c]spn. They should work, but are not
  18:include/asm/string.h ****  * very easy to understand. Everything is done entirely within the register
  19:include/asm/string.h ****  * set, making the functions fast and clean. String instructions have been
  20:include/asm/string.h ****  * used through-out, making for "slightly" unclear code :-)
  21:include/asm/string.h ****  *
  22:include/asm/string.h ****  *		NO Copyright (C) 1991, 1992 Linus Torvalds,
  23:include/asm/string.h ****  *		consider these trivial functions to be PD.
  24:include/asm/string.h ****  */
  25:include/asm/string.h **** 
  26:include/asm/string.h **** /* AK: in fact I bet it would be better to move this stuff all out of line.
  27:include/asm/string.h ****  */
  28:include/asm/string.h **** 
  29:include/asm/string.h **** #define __HAVE_ARCH_STRCPY
  30:include/asm/string.h **** static inline char * strcpy(char * dest,const char *src)
  31:include/asm/string.h **** {
  32:include/asm/string.h **** int d0, d1, d2;
  33:include/asm/string.h **** __asm__ __volatile__(
  34:include/asm/string.h **** 	"1:\tlodsb\n\t"
  35:include/asm/string.h **** 	"stosb\n\t"
  36:include/asm/string.h **** 	"testb %%al,%%al\n\t"
  37:include/asm/string.h **** 	"jne 1b"
  38:include/asm/string.h **** 	: "=&S" (d0), "=&D" (d1), "=&a" (d2)
  39:include/asm/string.h **** 	:"0" (src),"1" (dest) : "memory");
  40:include/asm/string.h **** return dest;
  41:include/asm/string.h **** }
  42:include/asm/string.h **** 
  43:include/asm/string.h **** #define __HAVE_ARCH_STRNCPY
  44:include/asm/string.h **** static inline char * strncpy(char * dest,const char *src,size_t count)
  45:include/asm/string.h **** {
  46:include/asm/string.h **** int d0, d1, d2, d3;
  47:include/asm/string.h **** __asm__ __volatile__(
  48:include/asm/string.h **** 	"1:\tdecl %2\n\t"
  49:include/asm/string.h **** 	"js 2f\n\t"
  50:include/asm/string.h **** 	"lodsb\n\t"
  51:include/asm/string.h **** 	"stosb\n\t"
  52:include/asm/string.h **** 	"testb %%al,%%al\n\t"
  53:include/asm/string.h **** 	"jne 1b\n\t"
  54:include/asm/string.h **** 	"rep\n\t"
  55:include/asm/string.h **** 	"stosb\n"
  56:include/asm/string.h **** 	"2:"
  57:include/asm/string.h **** 	: "=&S" (d0), "=&D" (d1), "=&c" (d2), "=&a" (d3)
  58:include/asm/string.h **** 	:"0" (src),"1" (dest),"2" (count) : "memory");
  59:include/asm/string.h **** return dest;
  60:include/asm/string.h **** }
  61:include/asm/string.h **** 
  62:include/asm/string.h **** #define __HAVE_ARCH_STRCAT
  63:include/asm/string.h **** static inline char * strcat(char * dest,const char * src)
  64:include/asm/string.h **** {
  65:include/asm/string.h **** int d0, d1, d2, d3;
GAS LISTING  			page 6


  66:include/asm/string.h **** __asm__ __volatile__(
  67:include/asm/string.h **** 	"repne\n\t"
  68:include/asm/string.h **** 	"scasb\n\t"
  69:include/asm/string.h **** 	"decl %1\n"
  70:include/asm/string.h **** 	"1:\tlodsb\n\t"
  71:include/asm/string.h **** 	"stosb\n\t"
  72:include/asm/string.h **** 	"testb %%al,%%al\n\t"
  73:include/asm/string.h **** 	"jne 1b"
  74:include/asm/string.h **** 	: "=&S" (d0), "=&D" (d1), "=&a" (d2), "=&c" (d3)
  75:include/asm/string.h **** 	: "0" (src), "1" (dest), "2" (0), "3" (0xffffffffu):"memory");
  76:include/asm/string.h **** return dest;
  77:include/asm/string.h **** }
  78:include/asm/string.h **** 
  79:include/asm/string.h **** #define __HAVE_ARCH_STRNCAT
  80:include/asm/string.h **** static inline char * strncat(char * dest,const char * src,size_t count)
  81:include/asm/string.h **** {
  82:include/asm/string.h **** int d0, d1, d2, d3;
  83:include/asm/string.h **** __asm__ __volatile__(
  84:include/asm/string.h **** 	"repne\n\t"
  85:include/asm/string.h **** 	"scasb\n\t"
  86:include/asm/string.h **** 	"decl %1\n\t"
  87:include/asm/string.h **** 	"movl %8,%3\n"
  88:include/asm/string.h **** 	"1:\tdecl %3\n\t"
  89:include/asm/string.h **** 	"js 2f\n\t"
  90:include/asm/string.h **** 	"lodsb\n\t"
  91:include/asm/string.h **** 	"stosb\n\t"
  92:include/asm/string.h **** 	"testb %%al,%%al\n\t"
  93:include/asm/string.h **** 	"jne 1b\n"
  94:include/asm/string.h **** 	"2:\txorl %2,%2\n\t"
  95:include/asm/string.h **** 	"stosb"
  96:include/asm/string.h **** 	: "=&S" (d0), "=&D" (d1), "=&a" (d2), "=&c" (d3)
  97:include/asm/string.h **** 	: "0" (src),"1" (dest),"2" (0),"3" (0xffffffffu), "g" (count)
  98:include/asm/string.h **** 	: "memory");
  99:include/asm/string.h **** return dest;
 100:include/asm/string.h **** }
 101:include/asm/string.h **** 
 102:include/asm/string.h **** #define __HAVE_ARCH_STRCMP
 103:include/asm/string.h **** static inline int strcmp(const char * cs,const char * ct)
 104:include/asm/string.h **** {
 105:include/asm/string.h **** int d0, d1;
 106:include/asm/string.h **** register int __res;
 107:include/asm/string.h **** __asm__ __volatile__(
 108:include/asm/string.h **** 	"1:\tlodsb\n\t"
 109:include/asm/string.h **** 	"scasb\n\t"
 110:include/asm/string.h **** 	"jne 2f\n\t"
 111:include/asm/string.h **** 	"testb %%al,%%al\n\t"
 112:include/asm/string.h **** 	"jne 1b\n\t"
 113:include/asm/string.h **** 	"xorl %%eax,%%eax\n\t"
 114:include/asm/string.h **** 	"jmp 3f\n"
 115:include/asm/string.h **** 	"2:\tsbbl %%eax,%%eax\n\t"
 116:include/asm/string.h **** 	"orb $1,%%al\n"
 117:include/asm/string.h **** 	"3:"
 118:include/asm/string.h **** 	:"=a" (__res), "=&S" (d0), "=&D" (d1)
 119:include/asm/string.h **** 	:"1" (cs),"2" (ct)
 120:include/asm/string.h **** 	:"memory");
 121:include/asm/string.h **** return __res;
 122:include/asm/string.h **** }
GAS LISTING  			page 7


 123:include/asm/string.h **** 
 124:include/asm/string.h **** #define __HAVE_ARCH_STRNCMP
 125:include/asm/string.h **** static inline int strncmp(const char * cs,const char * ct,size_t count)
 126:include/asm/string.h **** {
 127:include/asm/string.h **** register int __res;
 128:include/asm/string.h **** int d0, d1, d2;
 129:include/asm/string.h **** __asm__ __volatile__(
 130:include/asm/string.h **** 	"1:\tdecl %3\n\t"
 131:include/asm/string.h **** 	"js 2f\n\t"
 132:include/asm/string.h **** 	"lodsb\n\t"
 133:include/asm/string.h **** 	"scasb\n\t"
 134:include/asm/string.h **** 	"jne 3f\n\t"
 135:include/asm/string.h **** 	"testb %%al,%%al\n\t"
 136:include/asm/string.h **** 	"jne 1b\n"
 137:include/asm/string.h **** 	"2:\txorl %%eax,%%eax\n\t"
 138:include/asm/string.h **** 	"jmp 4f\n"
 139:include/asm/string.h **** 	"3:\tsbbl %%eax,%%eax\n\t"
 140:include/asm/string.h **** 	"orb $1,%%al\n"
 141:include/asm/string.h **** 	"4:"
 142:include/asm/string.h **** 	:"=a" (__res), "=&S" (d0), "=&D" (d1), "=&c" (d2)
 143:include/asm/string.h **** 	:"1" (cs),"2" (ct),"3" (count)
 144:include/asm/string.h **** 	:"memory");
 145:include/asm/string.h **** return __res;
 146:include/asm/string.h **** }
 147:include/asm/string.h **** 
 148:include/asm/string.h **** #define __HAVE_ARCH_STRCHR
 149:include/asm/string.h **** static inline char * strchr(const char * s, int c)
 150:include/asm/string.h **** {
 151:include/asm/string.h **** int d0;
 152:include/asm/string.h **** register char * __res;
 153:include/asm/string.h **** __asm__ __volatile__(
 154:include/asm/string.h **** 	"movb %%al,%%ah\n"
 155:include/asm/string.h **** 	"1:\tlodsb\n\t"
 156:include/asm/string.h **** 	"cmpb %%ah,%%al\n\t"
 157:include/asm/string.h **** 	"je 2f\n\t"
 158:include/asm/string.h **** 	"testb %%al,%%al\n\t"
 159:include/asm/string.h **** 	"jne 1b\n\t"
 160:include/asm/string.h **** 	"movl $1,%1\n"
 161:include/asm/string.h **** 	"2:\tmovl %1,%0\n\t"
 162:include/asm/string.h **** 	"decl %0"
 163:include/asm/string.h **** 	:"=a" (__res), "=&S" (d0)
 164:include/asm/string.h **** 	:"1" (s),"0" (c)
 165:include/asm/string.h **** 	:"memory");
 166:include/asm/string.h **** return __res;
 167:include/asm/string.h **** }
 168:include/asm/string.h **** 
 169:include/asm/string.h **** #define __HAVE_ARCH_STRRCHR
 170:include/asm/string.h **** static inline char * strrchr(const char * s, int c)
 171:include/asm/string.h **** {
 172:include/asm/string.h **** int d0, d1;
 173:include/asm/string.h **** register char * __res;
 174:include/asm/string.h **** __asm__ __volatile__(
 175:include/asm/string.h **** 	"movb %%al,%%ah\n"
 176:include/asm/string.h **** 	"1:\tlodsb\n\t"
 177:include/asm/string.h **** 	"cmpb %%ah,%%al\n\t"
 178:include/asm/string.h **** 	"jne 2f\n\t"
 179:include/asm/string.h **** 	"leal -1(%%esi),%0\n"
GAS LISTING  			page 8


 180:include/asm/string.h **** 	"2:\ttestb %%al,%%al\n\t"
 181:include/asm/string.h **** 	"jne 1b"
 182:include/asm/string.h **** 	:"=g" (__res), "=&S" (d0), "=&a" (d1)
 183:include/asm/string.h **** 	:"0" (0),"1" (s),"2" (c)
 184:include/asm/string.h **** 	:"memory");
 185:include/asm/string.h **** return __res;
 186:include/asm/string.h **** }
 187:include/asm/string.h **** 
 188:include/asm/string.h **** #define __HAVE_ARCH_STRLEN
 189:include/asm/string.h **** static inline size_t strlen(const char * s)
 190:include/asm/string.h **** {
 191:include/asm/string.h **** int d0;
 192:include/asm/string.h **** register int __res;
 193:include/asm/string.h **** __asm__ __volatile__(
 194:include/asm/string.h **** 	"repne\n\t"
 195:include/asm/string.h **** 	"scasb\n\t"
 196:include/asm/string.h **** 	"notl %0\n\t"
 197:include/asm/string.h **** 	"decl %0"
 198:include/asm/string.h **** 	:"=c" (__res), "=&D" (d0)
 199:include/asm/string.h **** 	:"1" (s),"a" (0), "0" (0xffffffffu)
 200:include/asm/string.h **** 	:"memory");
 201:include/asm/string.h **** return __res;
 202:include/asm/string.h **** }
 203:include/asm/string.h **** 
 204:include/asm/string.h **** static inline void * __memcpy(void * to, const void * from, size_t n)
 205:include/asm/string.h **** {
 206:include/asm/string.h **** int d0, d1, d2;
 207:include/asm/string.h **** __asm__ __volatile__(
 208:include/asm/string.h **** 	"rep ; movsl\n\t"
 209:include/asm/string.h **** 	"movl %4,%%ecx\n\t"
 210:include/asm/string.h **** 	"andl $3,%%ecx\n\t"
 211:include/asm/string.h **** #if 1	/* want to pay 2 byte penalty for a chance to skip microcoded rep? */
 212:include/asm/string.h **** 	"jz 1f\n\t"
 213:include/asm/string.h **** #endif
 214:include/asm/string.h **** 	"rep ; movsb\n\t"
 215:include/asm/string.h **** 	"1:"
 216:include/asm/string.h **** 	: "=&c" (d0), "=&D" (d1), "=&S" (d2)
 217:include/asm/string.h **** 	: "0" (n/4), "g" (n), "1" ((long) to), "2" ((long) from)
 218:include/asm/string.h **** 	: "memory");
 219:include/asm/string.h **** return (to);
 220:include/asm/string.h **** }
 221:include/asm/string.h **** 
 222:include/asm/string.h **** /*
 223:include/asm/string.h ****  * This looks ugly, but the compiler can optimize it totally,
 224:include/asm/string.h ****  * as the count is constant.
 225:include/asm/string.h ****  */
 226:include/asm/string.h **** static inline void * __constant_memcpy(void * to, const void * from, size_t n)
 227:include/asm/string.h **** {
 228:include/asm/string.h **** 	long esi, edi;
 229:include/asm/string.h **** 	if (!n) return to;
 230:include/asm/string.h **** #if 1	/* want to do small copies with non-string ops? */
 231:include/asm/string.h **** 	switch (n) {
 232:include/asm/string.h **** 		case 1: *(char*)to = *(char*)from; return to;
 233:include/asm/string.h **** 		case 2: *(short*)to = *(short*)from; return to;
 234:include/asm/string.h **** 		case 4: *(int*)to = *(int*)from; return to;
 235:include/asm/string.h **** #if 1	/* including those doable with two moves? */
 236:include/asm/string.h **** 		case 3: *(short*)to = *(short*)from;
GAS LISTING  			page 9


 237:include/asm/string.h **** 			*((char*)to+2) = *((char*)from+2); return to;
 238:include/asm/string.h **** 		case 5: *(int*)to = *(int*)from;
 239:include/asm/string.h **** 			*((char*)to+4) = *((char*)from+4); return to;
 240:include/asm/string.h **** 		case 6: *(int*)to = *(int*)from;
 241:include/asm/string.h **** 			*((short*)to+2) = *((short*)from+2); return to;
 242:include/asm/string.h **** 		case 8: *(int*)to = *(int*)from;
 243:include/asm/string.h **** 			*((int*)to+1) = *((int*)from+1); return to;
 244:include/asm/string.h **** #endif
 245:include/asm/string.h **** 	}
 246:include/asm/string.h **** #endif
 247:include/asm/string.h **** 	esi = (long) from;
 248:include/asm/string.h **** 	edi = (long) to;
 249:include/asm/string.h **** 	if (n >= 5*4) {
 250:include/asm/string.h **** 		/* large block: use rep prefix */
 251:include/asm/string.h **** 		int ecx;
 252:include/asm/string.h **** 		__asm__ __volatile__(
 253:include/asm/string.h **** 			"rep ; movsl"
 254:include/asm/string.h **** 			: "=&c" (ecx), "=&D" (edi), "=&S" (esi)
 255:include/asm/string.h **** 			: "0" (n/4), "1" (edi),"2" (esi)
 256:include/asm/string.h **** 			: "memory"
 257:include/asm/string.h **** 		);
 258:include/asm/string.h **** 	} else {
 259:include/asm/string.h **** 		/* small block: don't clobber ecx + smaller code */
 260:include/asm/string.h **** 		if (n >= 4*4) __asm__ __volatile__("movsl"
 261:include/asm/string.h **** 			:"=&D"(edi),"=&S"(esi):"0"(edi),"1"(esi):"memory");
 262:include/asm/string.h **** 		if (n >= 3*4) __asm__ __volatile__("movsl"
 263:include/asm/string.h **** 			:"=&D"(edi),"=&S"(esi):"0"(edi),"1"(esi):"memory");
 264:include/asm/string.h **** 		if (n >= 2*4) __asm__ __volatile__("movsl"
 265:include/asm/string.h **** 			:"=&D"(edi),"=&S"(esi):"0"(edi),"1"(esi):"memory");
 266:include/asm/string.h **** 		if (n >= 1*4) __asm__ __volatile__("movsl"
 267:include/asm/string.h **** 			:"=&D"(edi),"=&S"(esi):"0"(edi),"1"(esi):"memory");
 268:include/asm/string.h **** 	}
 269:include/asm/string.h **** 	switch (n % 4) {
 270:include/asm/string.h **** 		/* tail */
 271:include/asm/string.h **** 		case 0: return to;
 272:include/asm/string.h **** 		case 1: __asm__ __volatile__("movsb"
 273:include/asm/string.h **** 			:"=&D"(edi),"=&S"(esi):"0"(edi),"1"(esi):"memory");
 274:include/asm/string.h **** 			return to;
 275:include/asm/string.h **** 		case 2: __asm__ __volatile__("movsw"
 276:include/asm/string.h **** 			:"=&D"(edi),"=&S"(esi):"0"(edi),"1"(esi):"memory");
 277:include/asm/string.h **** 			return to;
 278:include/asm/string.h **** 		default: __asm__ __volatile__("movsw\n\tmovsb"
 279:include/asm/string.h **** 			:"=&D"(edi),"=&S"(esi):"0"(edi),"1"(esi):"memory");
 280:include/asm/string.h **** 			return to;
 281:include/asm/string.h **** 	}
 282:include/asm/string.h **** }
 283:include/asm/string.h **** 
 284:include/asm/string.h **** #define __HAVE_ARCH_MEMCPY
 285:include/asm/string.h **** 
 286:include/asm/string.h **** #ifdef CONFIG_X86_USE_3DNOW
 287:include/asm/string.h **** 
 288:include/asm/string.h **** #include <asm/mmx.h>
 289:include/asm/string.h **** 
 290:include/asm/string.h **** /*
 291:include/asm/string.h ****  *	This CPU favours 3DNow strongly (eg AMD Athlon)
 292:include/asm/string.h ****  */
 293:include/asm/string.h **** 
GAS LISTING  			page 10


 294:include/asm/string.h **** static inline void * __constant_memcpy3d(void * to, const void * from, size_t len)
 295:include/asm/string.h **** {
 296:include/asm/string.h **** 	if (len < 512)
 297:include/asm/string.h **** 		return __constant_memcpy(to, from, len);
 298:include/asm/string.h **** 	return _mmx_memcpy(to, from, len);
 299:include/asm/string.h **** }
 300:include/asm/string.h **** 
 301:include/asm/string.h **** static __inline__ void *__memcpy3d(void *to, const void *from, size_t len)
 302:include/asm/string.h **** {
 303:include/asm/string.h **** 	if (len < 512)
 304:include/asm/string.h **** 		return __memcpy(to, from, len);
 305:include/asm/string.h **** 	return _mmx_memcpy(to, from, len);
 306:include/asm/string.h **** }
 307:include/asm/string.h **** 
 308:include/asm/string.h **** #define memcpy(t, f, n) \
 309:include/asm/string.h **** (__builtin_constant_p(n) ? \
 310:include/asm/string.h ****  __constant_memcpy3d((t),(f),(n)) : \
 311:include/asm/string.h ****  __memcpy3d((t),(f),(n)))
 312:include/asm/string.h **** 
 313:include/asm/string.h **** #else
 314:include/asm/string.h **** 
 315:include/asm/string.h **** /*
 316:include/asm/string.h ****  *	No 3D Now!
 317:include/asm/string.h ****  */
 318:include/asm/string.h ****  
 319:include/asm/string.h **** #define memcpy(t, f, n) \
 320:include/asm/string.h **** (__builtin_constant_p(n) ? \
 321:include/asm/string.h ****  __constant_memcpy((t),(f),(n)) : \
 322:include/asm/string.h ****  __memcpy((t),(f),(n)))
 323:include/asm/string.h **** 
 324:include/asm/string.h **** #endif
 325:include/asm/string.h **** 
 326:include/asm/string.h **** #define __HAVE_ARCH_MEMMOVE
 327:include/asm/string.h **** void *memmove(void * dest,const void * src, size_t n);
 328:include/asm/string.h **** 
 329:include/asm/string.h **** #define memcmp __builtin_memcmp
 330:include/asm/string.h **** 
 331:include/asm/string.h **** #define __HAVE_ARCH_MEMCHR
 332:include/asm/string.h **** static inline void * memchr(const void * cs,int c,size_t count)
 333:include/asm/string.h **** {
 334:include/asm/string.h **** int d0;
 335:include/asm/string.h **** register void * __res;
 336:include/asm/string.h **** if (!count)
 337:include/asm/string.h **** 	return NULL;
 338:include/asm/string.h **** __asm__ __volatile__(
 339:include/asm/string.h **** 	"repne\n\t"
 340:include/asm/string.h **** 	"scasb\n\t"
 341:include/asm/string.h **** 	"je 1f\n\t"
 342:include/asm/string.h **** 	"movl $1,%0\n"
 343:include/asm/string.h **** 	"1:\tdecl %0"
 344:include/asm/string.h **** 	:"=D" (__res), "=&c" (d0)
 345:include/asm/string.h **** 	:"a" (c),"0" (cs),"1" (count)
 346:include/asm/string.h **** 	:"memory");
 347:include/asm/string.h **** return __res;
 348:include/asm/string.h **** }
 349:include/asm/string.h **** 
 350:include/asm/string.h **** static inline void * __memset_generic(void * s, char c,size_t count)
GAS LISTING  			page 11


 351:include/asm/string.h **** {
 352:include/asm/string.h **** int d0, d1;
 353:include/asm/string.h **** __asm__ __volatile__(
 354:include/asm/string.h **** 	"rep\n\t"
 355:include/asm/string.h **** 	"stosb"
 356:include/asm/string.h **** 	: "=&c" (d0), "=&D" (d1)
 357:include/asm/string.h **** 	:"a" (c),"1" (s),"0" (count)
 358:include/asm/string.h **** 	:"memory");
 359:include/asm/string.h **** return s;
 360:include/asm/string.h **** }
 361:include/asm/string.h **** 
 362:include/asm/string.h **** /* we might want to write optimized versions of these later */
 363:include/asm/string.h **** #define __constant_count_memset(s,c,count) __memset_generic((s),(c),(count))
 364:include/asm/string.h **** 
 365:include/asm/string.h **** /*
 366:include/asm/string.h ****  * memset(x,0,y) is a reasonably common thing to do, so we want to fill
 367:include/asm/string.h ****  * things 32 bits at a time even when we don't know the size of the
 368:include/asm/string.h ****  * area at compile-time..
 369:include/asm/string.h ****  */
 370:include/asm/string.h **** static inline void * __constant_c_memset(void * s, unsigned long c, size_t count)
 371:include/asm/string.h **** {
 372:include/asm/string.h **** int d0, d1;
 373:include/asm/string.h **** __asm__ __volatile__(
 374:include/asm/string.h **** 	"rep ; stosl\n\t"
 375:include/asm/string.h **** 	"testb $2,%b3\n\t"
 376:include/asm/string.h **** 	"je 1f\n\t"
 377:include/asm/string.h **** 	"stosw\n"
 378:include/asm/string.h **** 	"1:\ttestb $1,%b3\n\t"
 379:include/asm/string.h **** 	"je 2f\n\t"
 380:include/asm/string.h **** 	"stosb\n"
 381:include/asm/string.h **** 	"2:"
 382:include/asm/string.h **** 	:"=&c" (d0), "=&D" (d1)
 383:include/asm/string.h **** 	:"a" (c), "q" (count), "0" (count/4), "1" ((long) s)
 384:include/asm/string.h **** 	:"memory");
 385:include/asm/string.h **** return (s);	
 386:include/asm/string.h **** }
 387:include/asm/string.h **** 
 388:include/asm/string.h **** /* Added by Gertjan van Wingerde to make minix and sysv module work */
 389:include/asm/string.h **** #define __HAVE_ARCH_STRNLEN
 390:include/asm/string.h **** static inline size_t strnlen(const char * s, size_t count)
 391:include/asm/string.h **** {
 392:include/asm/string.h **** int d0;
 393:include/asm/string.h **** register int __res;
 394:include/asm/string.h **** __asm__ __volatile__(
 395:include/asm/string.h **** 	"movl %2,%0\n\t"
 396:include/asm/string.h **** 	"jmp 2f\n"
 397:include/asm/string.h **** 	"1:\tcmpb $0,(%0)\n\t"
 398:include/asm/string.h **** 	"je 3f\n\t"
 399:include/asm/string.h **** 	"incl %0\n"
 400:include/asm/string.h **** 	"2:\tdecl %1\n\t"
 401:include/asm/string.h **** 	"cmpl $-1,%1\n\t"
 402:include/asm/string.h **** 	"jne 1b\n"
 403:include/asm/string.h **** 	"3:\tsubl %2,%0"
 404:include/asm/string.h **** 	:"=a" (__res), "=&d" (d0)
 405:include/asm/string.h **** 	:"c" (s),"1" (count)
 406:include/asm/string.h **** 	:"memory");
 407:include/asm/string.h **** return __res;
GAS LISTING  			page 12


 408:include/asm/string.h **** }
 409:include/asm/string.h **** /* end of additional stuff */
 410:include/asm/string.h **** 
 411:include/asm/string.h **** #define __HAVE_ARCH_STRSTR
 412:include/asm/string.h **** 
 413:include/asm/string.h **** extern char *strstr(const char *cs, const char *ct);
 414:include/asm/string.h **** 
 415:include/asm/string.h **** /*
 416:include/asm/string.h ****  * This looks horribly ugly, but the compiler can optimize it totally,
 417:include/asm/string.h ****  * as we by now know that both pattern and count is constant..
 418:include/asm/string.h ****  */
 419:include/asm/string.h **** static inline void * __constant_c_and_count_memset(void * s, unsigned long pattern, size_t count)
 420:include/asm/string.h **** {
 421:include/asm/string.h **** 	switch (count) {
 422:include/asm/string.h **** 		case 0:
 423:include/asm/string.h **** 			return s;
 424:include/asm/string.h **** 		case 1:
 425:include/asm/string.h **** 			*(unsigned char *)s = pattern;
 426:include/asm/string.h **** 			return s;
 427:include/asm/string.h **** 		case 2:
 428:include/asm/string.h **** 			*(unsigned short *)s = pattern;
 429:include/asm/string.h **** 			return s;
 430:include/asm/string.h **** 		case 3:
 431:include/asm/string.h **** 			*(unsigned short *)s = pattern;
 432:include/asm/string.h **** 			*(2+(unsigned char *)s) = pattern;
 433:include/asm/string.h **** 			return s;
 434:include/asm/string.h **** 		case 4:
 435:include/asm/string.h **** 			*(unsigned long *)s = pattern;
 436:include/asm/string.h **** 			return s;
 437:include/asm/string.h **** 	}
 438:include/asm/string.h **** #define COMMON(x) \
 439:include/asm/string.h **** __asm__  __volatile__( \
 440:include/asm/string.h **** 	"rep ; stosl" \
 441:include/asm/string.h **** 	x \
 442:include/asm/string.h **** 	: "=&c" (d0), "=&D" (d1) \
 443:include/asm/string.h **** 	: "a" (pattern),"0" (count/4),"1" ((long) s) \
 444:include/asm/string.h **** 	: "memory")
 445:include/asm/string.h **** {
 446:include/asm/string.h **** 	int d0, d1;
 447:include/asm/string.h **** 	switch (count % 4) {
 448:include/asm/string.h **** 		case 0: COMMON(""); return s;
  81              	.loc 3 448 0
  82 001b 89C7     	movl %eax,%edi
  83 001d B9060000 	movl $6,%ecx
  83      00
  84 0022 89F0     	movl %esi,%eax
  85              	
  86 0024 F3AB     	rep
  87              	
  88              	.LBE10:
  89              	.LBE9:
  90              	.LBE8:
  45:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 		goto fail;
  46:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	memset(priv, 0, sizeof(*priv));
  47:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	priv->key_idx = keyidx;
  91              	.loc 1 47 0
  92 0026 8B442414 	movl 20(%esp),%eax
GAS LISTING  			page 13


  93 002a 884313   	movb %al,19(%ebx)
  48:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 
  49:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	priv->tfm = crypto_alloc_tfm("arc4", 0);
  94              	.loc 1 49 0
  95 002d 6A00     	pushl $0
  96              	.LCFI9:
  97 002f 68000000 	pushl $.LC0
  97      00
  98              	.LCFI10:
  99              	.LCFI11:
 100 0034 E8FCFFFF 	call crypto_alloc_tfm
 100      FF
 101 0039 894314   	movl %eax,20(%ebx)
  50:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	if (priv->tfm == NULL) {
 102              	.loc 1 50 0
 103 003c 59       	popl %ecx
 104              	.LCFI12:
 105 003d 85C0     	testl %eax,%eax
 106 003f 5E       	popl %esi
 107              	.LCFI13:
 108 0040 740E     	je .L51
  51:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 		printk(KERN_DEBUG "ieee80211_crypt_wep: could not allocate "
  52:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 		       "crypto API arc4\n");
  53:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 		goto fail;
  54:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	}
  55:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 
  56:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	/* start WEP IV from a random value */
  57:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	get_random_bytes(&priv->iv, 4);
 109              	.loc 1 57 0
 110 0042 6A04     	pushl $4
 111              	.LCFI14:
 112 0044 53       	pushl %ebx
 113              	.LCFI15:
 114              	.LCFI16:
 115 0045 E8FCFFFF 	call get_random_bytes
 115      FF
  58:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 
  59:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	return priv;
 116              	.loc 1 59 0
 117 004a 58       	popl %eax
 118              	.LCFI17:
 119 004b 89DF     	movl %ebx,%edi
 120 004d 5A       	popl %edx
 121              	.LCFI18:
 122 004e EB22     	jmp .L1
 123              	.LCFI19:
 124              	.L51:
 125              	.L34:
 126              	.loc 1 51 0
 127 0050 68050000 	pushl $.LC1
 127      00
 128              	.LCFI20:
 129 0055 E8FCFFFF 	call printk
 129      FF
  60:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 
  61:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c ****       fail:
  62:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	if (priv) {
GAS LISTING  			page 14


  63:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 		if (priv->tfm)
 130              	.loc 1 63 0
 131 005a 8B4314   	movl 20(%ebx),%eax
 132 005d 85C0     	testl %eax,%eax
 133              	.loc 1 53 0
 134 005f 5F       	popl %edi
 135              	.LCFI21:
 136              	.loc 1 63 0
 137 0060 7407     	je .L50
  64:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 			crypto_free_tfm(priv->tfm);
 138              	.loc 1 64 0
 139 0062 50       	pushl %eax
 140              	.LCFI22:
 141 0063 E8FCFFFF 	call crypto_free_tfm
 141      FF
 142 0068 5E       	popl %esi
 143              	.LCFI23:
 144              	.L50:
  65:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 		kfree(priv);
 145              	.loc 1 65 0
 146 0069 53       	pushl %ebx
 147              	.LCFI24:
 148 006a E8FCFFFF 	call kfree
 148      FF
 149 006f 59       	popl %ecx
 150              	.LCFI25:
 151              	.L49:
  66:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	}
  67:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	return NULL;
 152              	.loc 1 67 0
 153 0070 31FF     	xorl %edi,%edi
 154              	.L1:
  68:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** }
 155              	.loc 1 68 0
 156 0072 5A       	popl %edx
 157              	.LCFI26:
 158 0073 5B       	popl %ebx
 159 0074 5E       	popl %esi
 160 0075 89F8     	movl %edi,%eax
 161 0077 5F       	popl %edi
 162 0078 C3       	ret
 163              	.LFE687:
 166              	prism2_wep_deinit:
 167              	.LFB688:
  69:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 
  70:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** static void prism2_wep_deinit(void *priv)
  71:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** {
 168              	.loc 1 71 0
 169 0079 53       	pushl %ebx
 170              	.LCFI27:
 171              	.loc 1 71 0
 172 007a 8B5C2408 	movl 8(%esp),%ebx
  72:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	struct prism2_wep_data *_priv = priv;
  73:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	if (_priv && _priv->tfm)
 173              	.loc 1 73 0
 174 007e 85DB     	testl %ebx,%ebx
 175 0080 740E     	je .L53
GAS LISTING  			page 15


 176 0082 8B4314   	movl 20(%ebx),%eax
 177 0085 85C0     	testl %eax,%eax
 178 0087 7407     	je .L53
  74:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 		crypto_free_tfm(_priv->tfm);
 179              	.loc 1 74 0
 180 0089 50       	pushl %eax
 181              	.LCFI28:
 182 008a E8FCFFFF 	call crypto_free_tfm
 182      FF
 183 008f 58       	popl %eax
 184              	.LCFI29:
 185              	.L53:
  75:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	kfree(priv);
 186              	.loc 1 75 0
 187 0090 895C2408 	movl %ebx,8(%esp)
 188 0094 5B       	popl %ebx
 189              	.LCFI30:
 190 0095 E9FCFFFF 	jmp kfree
 190      FF
 191              	.LFE688:
 194              	prism2_wep_build_iv:
 195              	.LFB689:
  76:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** }
  77:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 
  78:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** /* Add WEP IV/key info to a frame that has at least 4 bytes of headroom */
  79:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** static int prism2_wep_build_iv(struct sk_buff *skb, int hdr_len,
  80:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 			       u8 *key, int keylen, void *priv)
  81:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** {
 196              	.loc 1 81 0
 197 009a 57       	pushl %edi
 198              	.LCFI31:
 199 009b 56       	pushl %esi
 200              	.LCFI32:
 201 009c 53       	pushl %ebx
 202              	.LCFI33:
 203              	.loc 1 81 0
 204 009d 8B5C2410 	movl 16(%esp),%ebx
 205              	.LBB11:
 206              	.LBB12:
 207              	.file 4 "include/linux/skbuff.h"
   1:include/linux/skbuff.h **** /*
   2:include/linux/skbuff.h ****  *	Definitions for the 'struct sk_buff' memory handlers.
   3:include/linux/skbuff.h ****  *
   4:include/linux/skbuff.h ****  *	Authors:
   5:include/linux/skbuff.h ****  *		Alan Cox, <gw4pts@gw4pts.ampr.org>
   6:include/linux/skbuff.h ****  *		Florian La Roche, <rzsfl@rz.uni-sb.de>
   7:include/linux/skbuff.h ****  *
   8:include/linux/skbuff.h ****  *	This program is free software; you can redistribute it and/or
   9:include/linux/skbuff.h ****  *	modify it under the terms of the GNU General Public License
  10:include/linux/skbuff.h ****  *	as published by the Free Software Foundation; either version
  11:include/linux/skbuff.h ****  *	2 of the License, or (at your option) any later version.
  12:include/linux/skbuff.h ****  */
  13:include/linux/skbuff.h **** 
  14:include/linux/skbuff.h **** #ifndef _LINUX_SKBUFF_H
  15:include/linux/skbuff.h **** #define _LINUX_SKBUFF_H
  16:include/linux/skbuff.h **** 
  17:include/linux/skbuff.h **** #include <linux/config.h>
GAS LISTING  			page 16


  18:include/linux/skbuff.h **** #include <linux/kernel.h>
  19:include/linux/skbuff.h **** #include <linux/compiler.h>
  20:include/linux/skbuff.h **** #include <linux/time.h>
  21:include/linux/skbuff.h **** #include <linux/cache.h>
  22:include/linux/skbuff.h **** 
  23:include/linux/skbuff.h **** #include <asm/atomic.h>
  24:include/linux/skbuff.h **** #include <asm/types.h>
  25:include/linux/skbuff.h **** #include <linux/spinlock.h>
  26:include/linux/skbuff.h **** #include <linux/mm.h>
  27:include/linux/skbuff.h **** #include <linux/highmem.h>
  28:include/linux/skbuff.h **** #include <linux/poll.h>
  29:include/linux/skbuff.h **** #include <linux/net.h>
  30:include/linux/skbuff.h **** #include <net/checksum.h>
  31:include/linux/skbuff.h **** 
  32:include/linux/skbuff.h **** #define HAVE_ALLOC_SKB		/* For the drivers to know */
  33:include/linux/skbuff.h **** #define HAVE_ALIGNABLE_SKB	/* Ditto 8)		   */
  34:include/linux/skbuff.h **** #define SLAB_SKB 		/* Slabified skbuffs 	   */
  35:include/linux/skbuff.h **** 
  36:include/linux/skbuff.h **** #define CHECKSUM_NONE 0
  37:include/linux/skbuff.h **** #define CHECKSUM_HW 1
  38:include/linux/skbuff.h **** #define CHECKSUM_UNNECESSARY 2
  39:include/linux/skbuff.h **** 
  40:include/linux/skbuff.h **** #define SKB_DATA_ALIGN(X)	(((X) + (SMP_CACHE_BYTES - 1)) & \
  41:include/linux/skbuff.h **** 				 ~(SMP_CACHE_BYTES - 1))
  42:include/linux/skbuff.h **** #define SKB_MAX_ORDER(X, ORDER)	(((PAGE_SIZE << (ORDER)) - (X) - \
  43:include/linux/skbuff.h **** 				  sizeof(struct skb_shared_info)) & \
  44:include/linux/skbuff.h **** 				  ~(SMP_CACHE_BYTES - 1))
  45:include/linux/skbuff.h **** #define SKB_MAX_HEAD(X)		(SKB_MAX_ORDER((X), 0))
  46:include/linux/skbuff.h **** #define SKB_MAX_ALLOC		(SKB_MAX_ORDER(0, 2))
  47:include/linux/skbuff.h **** 
  48:include/linux/skbuff.h **** /* A. Checksumming of received packets by device.
  49:include/linux/skbuff.h ****  *
  50:include/linux/skbuff.h ****  *	NONE: device failed to checksum this packet.
  51:include/linux/skbuff.h ****  *		skb->csum is undefined.
  52:include/linux/skbuff.h ****  *
  53:include/linux/skbuff.h ****  *	UNNECESSARY: device parsed packet and wouldbe verified checksum.
  54:include/linux/skbuff.h ****  *		skb->csum is undefined.
  55:include/linux/skbuff.h ****  *	      It is bad option, but, unfortunately, many of vendors do this.
  56:include/linux/skbuff.h ****  *	      Apparently with secret goal to sell you new device, when you
  57:include/linux/skbuff.h ****  *	      will add new protocol to your host. F.e. IPv6. 8)
  58:include/linux/skbuff.h ****  *
  59:include/linux/skbuff.h ****  *	HW: the most generic way. Device supplied checksum of _all_
  60:include/linux/skbuff.h ****  *	    the packet as seen by netif_rx in skb->csum.
  61:include/linux/skbuff.h ****  *	    NOTE: Even if device supports only some protocols, but
  62:include/linux/skbuff.h ****  *	    is able to produce some skb->csum, it MUST use HW,
  63:include/linux/skbuff.h ****  *	    not UNNECESSARY.
  64:include/linux/skbuff.h ****  *
  65:include/linux/skbuff.h ****  * B. Checksumming on output.
  66:include/linux/skbuff.h ****  *
  67:include/linux/skbuff.h ****  *	NONE: skb is checksummed by protocol or csum is not required.
  68:include/linux/skbuff.h ****  *
  69:include/linux/skbuff.h ****  *	HW: device is required to csum packet as seen by hard_start_xmit
  70:include/linux/skbuff.h ****  *	from skb->h.raw to the end and to record the checksum
  71:include/linux/skbuff.h ****  *	at skb->h.raw+skb->csum.
  72:include/linux/skbuff.h ****  *
  73:include/linux/skbuff.h ****  *	Device must show its capabilities in dev->features, set
  74:include/linux/skbuff.h ****  *	at device setup time.
GAS LISTING  			page 17


  75:include/linux/skbuff.h ****  *	NETIF_F_HW_CSUM	- it is clever device, it is able to checksum
  76:include/linux/skbuff.h ****  *			  everything.
  77:include/linux/skbuff.h ****  *	NETIF_F_NO_CSUM - loopback or reliable single hop media.
  78:include/linux/skbuff.h ****  *	NETIF_F_IP_CSUM - device is dumb. It is able to csum only
  79:include/linux/skbuff.h ****  *			  TCP/UDP over IPv4. Sigh. Vendors like this
  80:include/linux/skbuff.h ****  *			  way by an unknown reason. Though, see comment above
  81:include/linux/skbuff.h ****  *			  about CHECKSUM_UNNECESSARY. 8)
  82:include/linux/skbuff.h ****  *
  83:include/linux/skbuff.h ****  *	Any questions? No questions, good. 		--ANK
  84:include/linux/skbuff.h ****  */
  85:include/linux/skbuff.h **** 
  86:include/linux/skbuff.h **** struct net_device;
  87:include/linux/skbuff.h **** 
  88:include/linux/skbuff.h **** #ifdef CONFIG_NETFILTER
  89:include/linux/skbuff.h **** struct nf_conntrack {
  90:include/linux/skbuff.h **** 	atomic_t use;
  91:include/linux/skbuff.h **** 	void (*destroy)(struct nf_conntrack *);
  92:include/linux/skbuff.h **** };
  93:include/linux/skbuff.h **** 
  94:include/linux/skbuff.h **** #ifdef CONFIG_BRIDGE_NETFILTER
  95:include/linux/skbuff.h **** struct nf_bridge_info {
  96:include/linux/skbuff.h **** 	atomic_t use;
  97:include/linux/skbuff.h **** 	struct net_device *physindev;
  98:include/linux/skbuff.h **** 	struct net_device *physoutdev;
  99:include/linux/skbuff.h **** #if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)
 100:include/linux/skbuff.h **** 	struct net_device *netoutdev;
 101:include/linux/skbuff.h **** #endif
 102:include/linux/skbuff.h **** 	unsigned int mask;
 103:include/linux/skbuff.h **** 	unsigned long data[32 / sizeof(unsigned long)];
 104:include/linux/skbuff.h **** };
 105:include/linux/skbuff.h **** #endif
 106:include/linux/skbuff.h **** 
 107:include/linux/skbuff.h **** #endif
 108:include/linux/skbuff.h **** 
 109:include/linux/skbuff.h **** struct sk_buff_head {
 110:include/linux/skbuff.h **** 	/* These two members must be first. */
 111:include/linux/skbuff.h **** 	struct sk_buff	*next;
 112:include/linux/skbuff.h **** 	struct sk_buff	*prev;
 113:include/linux/skbuff.h **** 
 114:include/linux/skbuff.h **** 	__u32		qlen;
 115:include/linux/skbuff.h **** 	spinlock_t	lock;
 116:include/linux/skbuff.h **** };
 117:include/linux/skbuff.h **** 
 118:include/linux/skbuff.h **** struct sk_buff;
 119:include/linux/skbuff.h **** 
 120:include/linux/skbuff.h **** /* To allow 64K frame to be packed as single skb without frag_list */
 121:include/linux/skbuff.h **** #define MAX_SKB_FRAGS (65536/PAGE_SIZE + 2)
 122:include/linux/skbuff.h **** 
 123:include/linux/skbuff.h **** typedef struct skb_frag_struct skb_frag_t;
 124:include/linux/skbuff.h **** 
 125:include/linux/skbuff.h **** struct skb_frag_struct {
 126:include/linux/skbuff.h **** 	struct page *page;
 127:include/linux/skbuff.h **** 	__u16 page_offset;
 128:include/linux/skbuff.h **** 	__u16 size;
 129:include/linux/skbuff.h **** };
 130:include/linux/skbuff.h **** 
 131:include/linux/skbuff.h **** /* This data is invariant across clones and lives at
GAS LISTING  			page 18


 132:include/linux/skbuff.h ****  * the end of the header data, ie. at skb->end.
 133:include/linux/skbuff.h ****  */
 134:include/linux/skbuff.h **** struct skb_shared_info {
 135:include/linux/skbuff.h **** 	atomic_t	dataref;
 136:include/linux/skbuff.h **** 	unsigned int	nr_frags;
 137:include/linux/skbuff.h **** 	unsigned short	tso_size;
 138:include/linux/skbuff.h **** 	unsigned short	tso_segs;
 139:include/linux/skbuff.h **** 	struct sk_buff	*frag_list;
 140:include/linux/skbuff.h **** 	skb_frag_t	frags[MAX_SKB_FRAGS];
 141:include/linux/skbuff.h **** };
 142:include/linux/skbuff.h **** 
 143:include/linux/skbuff.h **** /* We divide dataref into two halves.  The higher 16 bits hold references
 144:include/linux/skbuff.h ****  * to the payload part of skb->data.  The lower 16 bits hold references to
 145:include/linux/skbuff.h ****  * the entire skb->data.  It is up to the users of the skb to agree on
 146:include/linux/skbuff.h ****  * where the payload starts.
 147:include/linux/skbuff.h ****  *
 148:include/linux/skbuff.h ****  * All users must obey the rule that the skb->data reference count must be
 149:include/linux/skbuff.h ****  * greater than or equal to the payload reference count.
 150:include/linux/skbuff.h ****  *
 151:include/linux/skbuff.h ****  * Holding a reference to the payload part means that the user does not
 152:include/linux/skbuff.h ****  * care about modifications to the header part of skb->data.
 153:include/linux/skbuff.h ****  */
 154:include/linux/skbuff.h **** #define SKB_DATAREF_SHIFT 16
 155:include/linux/skbuff.h **** #define SKB_DATAREF_MASK ((1 << SKB_DATAREF_SHIFT) - 1)
 156:include/linux/skbuff.h **** 
 157:include/linux/skbuff.h **** /** 
 158:include/linux/skbuff.h ****  *	struct sk_buff - socket buffer
 159:include/linux/skbuff.h ****  *	@next: Next buffer in list
 160:include/linux/skbuff.h ****  *	@prev: Previous buffer in list
 161:include/linux/skbuff.h ****  *	@list: List we are on
 162:include/linux/skbuff.h ****  *	@sk: Socket we are owned by
 163:include/linux/skbuff.h ****  *	@stamp: Time we arrived
 164:include/linux/skbuff.h ****  *	@dev: Device we arrived on/are leaving by
 165:include/linux/skbuff.h ****  *	@input_dev: Device we arrived on
 166:include/linux/skbuff.h ****  *      @real_dev: The real device we are using
 167:include/linux/skbuff.h ****  *	@h: Transport layer header
 168:include/linux/skbuff.h ****  *	@nh: Network layer header
 169:include/linux/skbuff.h ****  *	@mac: Link layer header
 170:include/linux/skbuff.h ****  *	@dst: destination entry
 171:include/linux/skbuff.h ****  *	@sp: the security path, used for xfrm
 172:include/linux/skbuff.h ****  *	@cb: Control buffer. Free for use by every layer. Put private vars here
 173:include/linux/skbuff.h ****  *	@len: Length of actual data
 174:include/linux/skbuff.h ****  *	@data_len: Data length
 175:include/linux/skbuff.h ****  *	@mac_len: Length of link layer header
 176:include/linux/skbuff.h ****  *	@csum: Checksum
 177:include/linux/skbuff.h ****  *	@local_df: allow local fragmentation
 178:include/linux/skbuff.h ****  *	@cloned: Head may be cloned (check refcnt to be sure)
 179:include/linux/skbuff.h ****  *	@nohdr: Payload reference only, must not modify header
 180:include/linux/skbuff.h ****  *	@pkt_type: Packet class
 181:include/linux/skbuff.h ****  *	@ip_summed: Driver fed us an IP checksum
 182:include/linux/skbuff.h ****  *	@priority: Packet queueing priority
 183:include/linux/skbuff.h ****  *	@users: User count - see {datagram,tcp}.c
 184:include/linux/skbuff.h ****  *	@protocol: Packet protocol from driver
 185:include/linux/skbuff.h ****  *	@security: Security level of packet
 186:include/linux/skbuff.h ****  *	@truesize: Buffer size 
 187:include/linux/skbuff.h ****  *	@head: Head of buffer
 188:include/linux/skbuff.h ****  *	@data: Data head pointer
GAS LISTING  			page 19


 189:include/linux/skbuff.h ****  *	@tail: Tail pointer
 190:include/linux/skbuff.h ****  *	@end: End pointer
 191:include/linux/skbuff.h ****  *	@destructor: Destruct function
 192:include/linux/skbuff.h ****  *	@nfmark: Can be used for communication between hooks
 193:include/linux/skbuff.h ****  *	@nfcache: Cache info
 194:include/linux/skbuff.h ****  *	@nfct: Associated connection, if any
 195:include/linux/skbuff.h ****  *	@nfctinfo: Relationship of this skb to the connection
 196:include/linux/skbuff.h ****  *	@nf_debug: Netfilter debugging
 197:include/linux/skbuff.h ****  *	@nf_bridge: Saved data about a bridged frame - see br_netfilter.c
 198:include/linux/skbuff.h ****  *      @private: Data which is private to the HIPPI implementation
 199:include/linux/skbuff.h ****  *	@tc_index: Traffic control index
 200:include/linux/skbuff.h ****  *	@tc_verd: traffic control verdict
 201:include/linux/skbuff.h ****  *	@tc_classid: traffic control classid
 202:include/linux/skbuff.h ****  */
 203:include/linux/skbuff.h **** 
 204:include/linux/skbuff.h **** struct sk_buff {
 205:include/linux/skbuff.h **** 	/* These two members must be first. */
 206:include/linux/skbuff.h **** 	struct sk_buff		*next;
 207:include/linux/skbuff.h **** 	struct sk_buff		*prev;
 208:include/linux/skbuff.h **** 
 209:include/linux/skbuff.h **** 	struct sk_buff_head	*list;
 210:include/linux/skbuff.h **** 	struct sock		*sk;
 211:include/linux/skbuff.h **** 	struct timeval		stamp;
 212:include/linux/skbuff.h **** 	struct net_device	*dev;
 213:include/linux/skbuff.h **** 	struct net_device	*input_dev;
 214:include/linux/skbuff.h **** 	struct net_device	*real_dev;
 215:include/linux/skbuff.h **** 
 216:include/linux/skbuff.h **** 	union {
 217:include/linux/skbuff.h **** 		struct tcphdr	*th;
 218:include/linux/skbuff.h **** 		struct udphdr	*uh;
 219:include/linux/skbuff.h **** 		struct icmphdr	*icmph;
 220:include/linux/skbuff.h **** 		struct igmphdr	*igmph;
 221:include/linux/skbuff.h **** 		struct iphdr	*ipiph;
 222:include/linux/skbuff.h **** 		struct ipv6hdr	*ipv6h;
 223:include/linux/skbuff.h **** 		unsigned char	*raw;
 224:include/linux/skbuff.h **** 	} h;
 225:include/linux/skbuff.h **** 
 226:include/linux/skbuff.h **** 	union {
 227:include/linux/skbuff.h **** 		struct iphdr	*iph;
 228:include/linux/skbuff.h **** 		struct ipv6hdr	*ipv6h;
 229:include/linux/skbuff.h **** 		struct arphdr	*arph;
 230:include/linux/skbuff.h **** 		unsigned char	*raw;
 231:include/linux/skbuff.h **** 	} nh;
 232:include/linux/skbuff.h **** 
 233:include/linux/skbuff.h **** 	union {
 234:include/linux/skbuff.h **** 	  	unsigned char 	*raw;
 235:include/linux/skbuff.h **** 	} mac;
 236:include/linux/skbuff.h **** 
 237:include/linux/skbuff.h **** 	struct  dst_entry	*dst;
 238:include/linux/skbuff.h **** 	struct	sec_path	*sp;
 239:include/linux/skbuff.h **** 
 240:include/linux/skbuff.h **** 	/*
 241:include/linux/skbuff.h **** 	 * This is the control buffer. It is free to use for every
 242:include/linux/skbuff.h **** 	 * layer. Please put your private variables there. If you
 243:include/linux/skbuff.h **** 	 * want to keep them across layers you have to do a skb_clone()
 244:include/linux/skbuff.h **** 	 * first. This is owned by whoever has the skb queued ATM.
 245:include/linux/skbuff.h **** 	 */
GAS LISTING  			page 20


 246:include/linux/skbuff.h **** 	char			cb[40];
 247:include/linux/skbuff.h **** 
 248:include/linux/skbuff.h **** 	unsigned int		len,
 249:include/linux/skbuff.h **** 				data_len,
 250:include/linux/skbuff.h **** 				mac_len,
 251:include/linux/skbuff.h **** 				csum;
 252:include/linux/skbuff.h **** 	unsigned char		local_df,
 253:include/linux/skbuff.h **** 				cloned:1,
 254:include/linux/skbuff.h **** 				nohdr:1,
 255:include/linux/skbuff.h **** 				pkt_type,
 256:include/linux/skbuff.h **** 				ip_summed;
 257:include/linux/skbuff.h **** 	__u32			priority;
 258:include/linux/skbuff.h **** 	unsigned short		protocol,
 259:include/linux/skbuff.h **** 				security;
 260:include/linux/skbuff.h **** 
 261:include/linux/skbuff.h **** 	void			(*destructor)(struct sk_buff *skb);
 262:include/linux/skbuff.h **** #ifdef CONFIG_NETFILTER
 263:include/linux/skbuff.h ****         unsigned long		nfmark;
 264:include/linux/skbuff.h **** 	__u32			nfcache;
 265:include/linux/skbuff.h **** 	__u32			nfctinfo;
 266:include/linux/skbuff.h **** 	struct nf_conntrack	*nfct;
 267:include/linux/skbuff.h **** #ifdef CONFIG_NETFILTER_DEBUG
 268:include/linux/skbuff.h ****         unsigned int		nf_debug;
 269:include/linux/skbuff.h **** #endif
 270:include/linux/skbuff.h **** #ifdef CONFIG_BRIDGE_NETFILTER
 271:include/linux/skbuff.h **** 	struct nf_bridge_info	*nf_bridge;
 272:include/linux/skbuff.h **** #endif
 273:include/linux/skbuff.h **** #endif /* CONFIG_NETFILTER */
 274:include/linux/skbuff.h **** #if defined(CONFIG_HIPPI)
 275:include/linux/skbuff.h **** 	union {
 276:include/linux/skbuff.h **** 		__u32		ifield;
 277:include/linux/skbuff.h **** 	} private;
 278:include/linux/skbuff.h **** #endif
 279:include/linux/skbuff.h **** #ifdef CONFIG_NET_SCHED
 280:include/linux/skbuff.h ****        __u32			tc_index;        /* traffic control index */
 281:include/linux/skbuff.h **** #ifdef CONFIG_NET_CLS_ACT
 282:include/linux/skbuff.h **** 	__u32           tc_verd;               /* traffic control verdict */
 283:include/linux/skbuff.h **** 	__u32           tc_classid;            /* traffic control classid */
 284:include/linux/skbuff.h **** #endif
 285:include/linux/skbuff.h **** 
 286:include/linux/skbuff.h **** #endif
 287:include/linux/skbuff.h **** 
 288:include/linux/skbuff.h **** 
 289:include/linux/skbuff.h **** 	/* These elements must be at the end, see alloc_skb() for details.  */
 290:include/linux/skbuff.h **** 	unsigned int		truesize;
 291:include/linux/skbuff.h **** 	atomic_t		users;
 292:include/linux/skbuff.h **** 	unsigned char		*head,
 293:include/linux/skbuff.h **** 				*data,
 294:include/linux/skbuff.h **** 				*tail,
 295:include/linux/skbuff.h **** 				*end;
 296:include/linux/skbuff.h **** };
 297:include/linux/skbuff.h **** 
 298:include/linux/skbuff.h **** #ifdef __KERNEL__
 299:include/linux/skbuff.h **** /*
 300:include/linux/skbuff.h ****  *	Handling routines are only of interest to the kernel
 301:include/linux/skbuff.h ****  */
 302:include/linux/skbuff.h **** #include <linux/slab.h>
GAS LISTING  			page 21


 303:include/linux/skbuff.h **** 
 304:include/linux/skbuff.h **** #include <asm/system.h>
 305:include/linux/skbuff.h **** 
 306:include/linux/skbuff.h **** extern void	       __kfree_skb(struct sk_buff *skb);
 307:include/linux/skbuff.h **** extern struct sk_buff *alloc_skb(unsigned int size, int priority);
 308:include/linux/skbuff.h **** extern struct sk_buff *alloc_skb_from_cache(kmem_cache_t *cp,
 309:include/linux/skbuff.h **** 					    unsigned int size, int priority);
 310:include/linux/skbuff.h **** extern void	       kfree_skbmem(struct sk_buff *skb);
 311:include/linux/skbuff.h **** extern struct sk_buff *skb_clone(struct sk_buff *skb, int priority);
 312:include/linux/skbuff.h **** extern struct sk_buff *skb_copy(const struct sk_buff *skb, int priority);
 313:include/linux/skbuff.h **** extern struct sk_buff *pskb_copy(struct sk_buff *skb, int gfp_mask);
 314:include/linux/skbuff.h **** extern int	       pskb_expand_head(struct sk_buff *skb,
 315:include/linux/skbuff.h **** 					int nhead, int ntail, int gfp_mask);
 316:include/linux/skbuff.h **** extern struct sk_buff *skb_realloc_headroom(struct sk_buff *skb,
 317:include/linux/skbuff.h **** 					    unsigned int headroom);
 318:include/linux/skbuff.h **** extern struct sk_buff *skb_copy_expand(const struct sk_buff *skb,
 319:include/linux/skbuff.h **** 				       int newheadroom, int newtailroom,
 320:include/linux/skbuff.h **** 				       int priority);
 321:include/linux/skbuff.h **** extern struct sk_buff *		skb_pad(struct sk_buff *skb, int pad);
 322:include/linux/skbuff.h **** #define dev_kfree_skb(a)	kfree_skb(a)
 323:include/linux/skbuff.h **** extern void	      skb_over_panic(struct sk_buff *skb, int len,
 324:include/linux/skbuff.h **** 				     void *here);
 325:include/linux/skbuff.h **** extern void	      skb_under_panic(struct sk_buff *skb, int len,
 326:include/linux/skbuff.h **** 				      void *here);
 327:include/linux/skbuff.h **** 
 328:include/linux/skbuff.h **** /* Internal */
 329:include/linux/skbuff.h **** #define skb_shinfo(SKB)		((struct skb_shared_info *)((SKB)->end))
 330:include/linux/skbuff.h **** 
 331:include/linux/skbuff.h **** /**
 332:include/linux/skbuff.h ****  *	skb_queue_empty - check if a queue is empty
 333:include/linux/skbuff.h ****  *	@list: queue head
 334:include/linux/skbuff.h ****  *
 335:include/linux/skbuff.h ****  *	Returns true if the queue is empty, false otherwise.
 336:include/linux/skbuff.h ****  */
 337:include/linux/skbuff.h **** static inline int skb_queue_empty(const struct sk_buff_head *list)
 338:include/linux/skbuff.h **** {
 339:include/linux/skbuff.h **** 	return list->next == (struct sk_buff *)list;
 340:include/linux/skbuff.h **** }
 341:include/linux/skbuff.h **** 
 342:include/linux/skbuff.h **** /**
 343:include/linux/skbuff.h ****  *	skb_get - reference buffer
 344:include/linux/skbuff.h ****  *	@skb: buffer to reference
 345:include/linux/skbuff.h ****  *
 346:include/linux/skbuff.h ****  *	Makes another reference to a socket buffer and returns a pointer
 347:include/linux/skbuff.h ****  *	to the buffer.
 348:include/linux/skbuff.h ****  */
 349:include/linux/skbuff.h **** static inline struct sk_buff *skb_get(struct sk_buff *skb)
 350:include/linux/skbuff.h **** {
 351:include/linux/skbuff.h **** 	atomic_inc(&skb->users);
 352:include/linux/skbuff.h **** 	return skb;
 353:include/linux/skbuff.h **** }
 354:include/linux/skbuff.h **** 
 355:include/linux/skbuff.h **** /*
 356:include/linux/skbuff.h ****  * If users == 1, we are the only owner and are can avoid redundant
 357:include/linux/skbuff.h ****  * atomic change.
 358:include/linux/skbuff.h ****  */
 359:include/linux/skbuff.h **** 
GAS LISTING  			page 22


 360:include/linux/skbuff.h **** /**
 361:include/linux/skbuff.h ****  *	kfree_skb - free an sk_buff
 362:include/linux/skbuff.h ****  *	@skb: buffer to free
 363:include/linux/skbuff.h ****  *
 364:include/linux/skbuff.h ****  *	Drop a reference to the buffer and free it if the usage count has
 365:include/linux/skbuff.h ****  *	hit zero.
 366:include/linux/skbuff.h ****  */
 367:include/linux/skbuff.h **** static inline void kfree_skb(struct sk_buff *skb)
 368:include/linux/skbuff.h **** {
 369:include/linux/skbuff.h **** 	if (likely(atomic_read(&skb->users) == 1))
 370:include/linux/skbuff.h **** 		smp_rmb();
 371:include/linux/skbuff.h **** 	else if (likely(!atomic_dec_and_test(&skb->users)))
 372:include/linux/skbuff.h **** 		return;
 373:include/linux/skbuff.h **** 	__kfree_skb(skb);
 374:include/linux/skbuff.h **** }
 375:include/linux/skbuff.h **** 
 376:include/linux/skbuff.h **** /**
 377:include/linux/skbuff.h ****  *	skb_cloned - is the buffer a clone
 378:include/linux/skbuff.h ****  *	@skb: buffer to check
 379:include/linux/skbuff.h ****  *
 380:include/linux/skbuff.h ****  *	Returns true if the buffer was generated with skb_clone() and is
 381:include/linux/skbuff.h ****  *	one of multiple shared copies of the buffer. Cloned buffers are
 382:include/linux/skbuff.h ****  *	shared data so must not be written to under normal circumstances.
 383:include/linux/skbuff.h ****  */
 384:include/linux/skbuff.h **** static inline int skb_cloned(const struct sk_buff *skb)
 385:include/linux/skbuff.h **** {
 386:include/linux/skbuff.h **** 	return skb->cloned &&
 387:include/linux/skbuff.h **** 	       (atomic_read(&skb_shinfo(skb)->dataref) & SKB_DATAREF_MASK) != 1;
 388:include/linux/skbuff.h **** }
 389:include/linux/skbuff.h **** 
 390:include/linux/skbuff.h **** /**
 391:include/linux/skbuff.h ****  *	skb_header_cloned - is the header a clone
 392:include/linux/skbuff.h ****  *	@skb: buffer to check
 393:include/linux/skbuff.h ****  *
 394:include/linux/skbuff.h ****  *	Returns true if modifying the header part of the buffer requires
 395:include/linux/skbuff.h ****  *	the data to be copied.
 396:include/linux/skbuff.h ****  */
 397:include/linux/skbuff.h **** static inline int skb_header_cloned(const struct sk_buff *skb)
 398:include/linux/skbuff.h **** {
 399:include/linux/skbuff.h **** 	int dataref;
 400:include/linux/skbuff.h **** 
 401:include/linux/skbuff.h **** 	if (!skb->cloned)
 402:include/linux/skbuff.h **** 		return 0;
 403:include/linux/skbuff.h **** 
 404:include/linux/skbuff.h **** 	dataref = atomic_read(&skb_shinfo(skb)->dataref);
 405:include/linux/skbuff.h **** 	dataref = (dataref & SKB_DATAREF_MASK) - (dataref >> SKB_DATAREF_SHIFT);
 406:include/linux/skbuff.h **** 	return dataref != 1;
 407:include/linux/skbuff.h **** }
 408:include/linux/skbuff.h **** 
 409:include/linux/skbuff.h **** /**
 410:include/linux/skbuff.h ****  *	skb_header_release - release reference to header
 411:include/linux/skbuff.h ****  *	@skb: buffer to operate on
 412:include/linux/skbuff.h ****  *
 413:include/linux/skbuff.h ****  *	Drop a reference to the header part of the buffer.  This is done
 414:include/linux/skbuff.h ****  *	by acquiring a payload reference.  You must not read from the header
 415:include/linux/skbuff.h ****  *	part of skb->data after this.
 416:include/linux/skbuff.h ****  */
GAS LISTING  			page 23


 417:include/linux/skbuff.h **** static inline void skb_header_release(struct sk_buff *skb)
 418:include/linux/skbuff.h **** {
 419:include/linux/skbuff.h **** 	BUG_ON(skb->nohdr);
 420:include/linux/skbuff.h **** 	skb->nohdr = 1;
 421:include/linux/skbuff.h **** 	atomic_add(1 << SKB_DATAREF_SHIFT, &skb_shinfo(skb)->dataref);
 422:include/linux/skbuff.h **** }
 423:include/linux/skbuff.h **** 
 424:include/linux/skbuff.h **** /**
 425:include/linux/skbuff.h ****  *	skb_shared - is the buffer shared
 426:include/linux/skbuff.h ****  *	@skb: buffer to check
 427:include/linux/skbuff.h ****  *
 428:include/linux/skbuff.h ****  *	Returns true if more than one person has a reference to this
 429:include/linux/skbuff.h ****  *	buffer.
 430:include/linux/skbuff.h ****  */
 431:include/linux/skbuff.h **** static inline int skb_shared(const struct sk_buff *skb)
 432:include/linux/skbuff.h **** {
 433:include/linux/skbuff.h **** 	return atomic_read(&skb->users) != 1;
 434:include/linux/skbuff.h **** }
 435:include/linux/skbuff.h **** 
 436:include/linux/skbuff.h **** /**
 437:include/linux/skbuff.h ****  *	skb_share_check - check if buffer is shared and if so clone it
 438:include/linux/skbuff.h ****  *	@skb: buffer to check
 439:include/linux/skbuff.h ****  *	@pri: priority for memory allocation
 440:include/linux/skbuff.h ****  *
 441:include/linux/skbuff.h ****  *	If the buffer is shared the buffer is cloned and the old copy
 442:include/linux/skbuff.h ****  *	drops a reference. A new clone with a single reference is returned.
 443:include/linux/skbuff.h ****  *	If the buffer is not shared the original buffer is returned. When
 444:include/linux/skbuff.h ****  *	being called from interrupt status or with spinlocks held pri must
 445:include/linux/skbuff.h ****  *	be GFP_ATOMIC.
 446:include/linux/skbuff.h ****  *
 447:include/linux/skbuff.h ****  *	NULL is returned on a memory allocation failure.
 448:include/linux/skbuff.h ****  */
 449:include/linux/skbuff.h **** static inline struct sk_buff *skb_share_check(struct sk_buff *skb, int pri)
 450:include/linux/skbuff.h **** {
 451:include/linux/skbuff.h **** 	might_sleep_if(pri & __GFP_WAIT);
 452:include/linux/skbuff.h **** 	if (skb_shared(skb)) {
 453:include/linux/skbuff.h **** 		struct sk_buff *nskb = skb_clone(skb, pri);
 454:include/linux/skbuff.h **** 		kfree_skb(skb);
 455:include/linux/skbuff.h **** 		skb = nskb;
 456:include/linux/skbuff.h **** 	}
 457:include/linux/skbuff.h **** 	return skb;
 458:include/linux/skbuff.h **** }
 459:include/linux/skbuff.h **** 
 460:include/linux/skbuff.h **** /*
 461:include/linux/skbuff.h ****  *	Copy shared buffers into a new sk_buff. We effectively do COW on
 462:include/linux/skbuff.h ****  *	packets to handle cases where we have a local reader and forward
 463:include/linux/skbuff.h ****  *	and a couple of other messy ones. The normal one is tcpdumping
 464:include/linux/skbuff.h ****  *	a packet thats being forwarded.
 465:include/linux/skbuff.h ****  */
 466:include/linux/skbuff.h **** 
 467:include/linux/skbuff.h **** /**
 468:include/linux/skbuff.h ****  *	skb_unshare - make a copy of a shared buffer
 469:include/linux/skbuff.h ****  *	@skb: buffer to check
 470:include/linux/skbuff.h ****  *	@pri: priority for memory allocation
 471:include/linux/skbuff.h ****  *
 472:include/linux/skbuff.h ****  *	If the socket buffer is a clone then this function creates a new
 473:include/linux/skbuff.h ****  *	copy of the data, drops a reference count on the old copy and returns
GAS LISTING  			page 24


 474:include/linux/skbuff.h ****  *	the new copy with the reference count at 1. If the buffer is not a clone
 475:include/linux/skbuff.h ****  *	the original buffer is returned. When called with a spinlock held or
 476:include/linux/skbuff.h ****  *	from interrupt state @pri must be %GFP_ATOMIC
 477:include/linux/skbuff.h ****  *
 478:include/linux/skbuff.h ****  *	%NULL is returned on a memory allocation failure.
 479:include/linux/skbuff.h ****  */
 480:include/linux/skbuff.h **** static inline struct sk_buff *skb_unshare(struct sk_buff *skb, int pri)
 481:include/linux/skbuff.h **** {
 482:include/linux/skbuff.h **** 	might_sleep_if(pri & __GFP_WAIT);
 483:include/linux/skbuff.h **** 	if (skb_cloned(skb)) {
 484:include/linux/skbuff.h **** 		struct sk_buff *nskb = skb_copy(skb, pri);
 485:include/linux/skbuff.h **** 		kfree_skb(skb);	/* Free our shared copy */
 486:include/linux/skbuff.h **** 		skb = nskb;
 487:include/linux/skbuff.h **** 	}
 488:include/linux/skbuff.h **** 	return skb;
 489:include/linux/skbuff.h **** }
 490:include/linux/skbuff.h **** 
 491:include/linux/skbuff.h **** /**
 492:include/linux/skbuff.h ****  *	skb_peek
 493:include/linux/skbuff.h ****  *	@list_: list to peek at
 494:include/linux/skbuff.h ****  *
 495:include/linux/skbuff.h ****  *	Peek an &sk_buff. Unlike most other operations you _MUST_
 496:include/linux/skbuff.h ****  *	be careful with this one. A peek leaves the buffer on the
 497:include/linux/skbuff.h ****  *	list and someone else may run off with it. You must hold
 498:include/linux/skbuff.h ****  *	the appropriate locks or have a private queue to do this.
 499:include/linux/skbuff.h ****  *
 500:include/linux/skbuff.h ****  *	Returns %NULL for an empty list or a pointer to the head element.
 501:include/linux/skbuff.h ****  *	The reference count is not incremented and the reference is therefore
 502:include/linux/skbuff.h ****  *	volatile. Use with caution.
 503:include/linux/skbuff.h ****  */
 504:include/linux/skbuff.h **** static inline struct sk_buff *skb_peek(struct sk_buff_head *list_)
 505:include/linux/skbuff.h **** {
 506:include/linux/skbuff.h **** 	struct sk_buff *list = ((struct sk_buff *)list_)->next;
 507:include/linux/skbuff.h **** 	if (list == (struct sk_buff *)list_)
 508:include/linux/skbuff.h **** 		list = NULL;
 509:include/linux/skbuff.h **** 	return list;
 510:include/linux/skbuff.h **** }
 511:include/linux/skbuff.h **** 
 512:include/linux/skbuff.h **** /**
 513:include/linux/skbuff.h ****  *	skb_peek_tail
 514:include/linux/skbuff.h ****  *	@list_: list to peek at
 515:include/linux/skbuff.h ****  *
 516:include/linux/skbuff.h ****  *	Peek an &sk_buff. Unlike most other operations you _MUST_
 517:include/linux/skbuff.h ****  *	be careful with this one. A peek leaves the buffer on the
 518:include/linux/skbuff.h ****  *	list and someone else may run off with it. You must hold
 519:include/linux/skbuff.h ****  *	the appropriate locks or have a private queue to do this.
 520:include/linux/skbuff.h ****  *
 521:include/linux/skbuff.h ****  *	Returns %NULL for an empty list or a pointer to the tail element.
 522:include/linux/skbuff.h ****  *	The reference count is not incremented and the reference is therefore
 523:include/linux/skbuff.h ****  *	volatile. Use with caution.
 524:include/linux/skbuff.h ****  */
 525:include/linux/skbuff.h **** static inline struct sk_buff *skb_peek_tail(struct sk_buff_head *list_)
 526:include/linux/skbuff.h **** {
 527:include/linux/skbuff.h **** 	struct sk_buff *list = ((struct sk_buff *)list_)->prev;
 528:include/linux/skbuff.h **** 	if (list == (struct sk_buff *)list_)
 529:include/linux/skbuff.h **** 		list = NULL;
 530:include/linux/skbuff.h **** 	return list;
GAS LISTING  			page 25


 531:include/linux/skbuff.h **** }
 532:include/linux/skbuff.h **** 
 533:include/linux/skbuff.h **** /**
 534:include/linux/skbuff.h ****  *	skb_queue_len	- get queue length
 535:include/linux/skbuff.h ****  *	@list_: list to measure
 536:include/linux/skbuff.h ****  *
 537:include/linux/skbuff.h ****  *	Return the length of an &sk_buff queue.
 538:include/linux/skbuff.h ****  */
 539:include/linux/skbuff.h **** static inline __u32 skb_queue_len(const struct sk_buff_head *list_)
 540:include/linux/skbuff.h **** {
 541:include/linux/skbuff.h **** 	return list_->qlen;
 542:include/linux/skbuff.h **** }
 543:include/linux/skbuff.h **** 
 544:include/linux/skbuff.h **** static inline void skb_queue_head_init(struct sk_buff_head *list)
 545:include/linux/skbuff.h **** {
 546:include/linux/skbuff.h **** 	spin_lock_init(&list->lock);
 547:include/linux/skbuff.h **** 	list->prev = list->next = (struct sk_buff *)list;
 548:include/linux/skbuff.h **** 	list->qlen = 0;
 549:include/linux/skbuff.h **** }
 550:include/linux/skbuff.h **** 
 551:include/linux/skbuff.h **** /*
 552:include/linux/skbuff.h ****  *	Insert an sk_buff at the start of a list.
 553:include/linux/skbuff.h ****  *
 554:include/linux/skbuff.h ****  *	The "__skb_xxxx()" functions are the non-atomic ones that
 555:include/linux/skbuff.h ****  *	can only be called with interrupts disabled.
 556:include/linux/skbuff.h ****  */
 557:include/linux/skbuff.h **** 
 558:include/linux/skbuff.h **** /**
 559:include/linux/skbuff.h ****  *	__skb_queue_head - queue a buffer at the list head
 560:include/linux/skbuff.h ****  *	@list: list to use
 561:include/linux/skbuff.h ****  *	@newsk: buffer to queue
 562:include/linux/skbuff.h ****  *
 563:include/linux/skbuff.h ****  *	Queue a buffer at the start of a list. This function takes no locks
 564:include/linux/skbuff.h ****  *	and you must therefore hold required locks before calling it.
 565:include/linux/skbuff.h ****  *
 566:include/linux/skbuff.h ****  *	A buffer cannot be placed on two lists at the same time.
 567:include/linux/skbuff.h ****  */
 568:include/linux/skbuff.h **** extern void skb_queue_head(struct sk_buff_head *list, struct sk_buff *newsk);
 569:include/linux/skbuff.h **** static inline void __skb_queue_head(struct sk_buff_head *list,
 570:include/linux/skbuff.h **** 				    struct sk_buff *newsk)
 571:include/linux/skbuff.h **** {
 572:include/linux/skbuff.h **** 	struct sk_buff *prev, *next;
 573:include/linux/skbuff.h **** 
 574:include/linux/skbuff.h **** 	newsk->list = list;
 575:include/linux/skbuff.h **** 	list->qlen++;
 576:include/linux/skbuff.h **** 	prev = (struct sk_buff *)list;
 577:include/linux/skbuff.h **** 	next = prev->next;
 578:include/linux/skbuff.h **** 	newsk->next = next;
 579:include/linux/skbuff.h **** 	newsk->prev = prev;
 580:include/linux/skbuff.h **** 	next->prev  = prev->next = newsk;
 581:include/linux/skbuff.h **** }
 582:include/linux/skbuff.h **** 
 583:include/linux/skbuff.h **** /**
 584:include/linux/skbuff.h ****  *	__skb_queue_tail - queue a buffer at the list tail
 585:include/linux/skbuff.h ****  *	@list: list to use
 586:include/linux/skbuff.h ****  *	@newsk: buffer to queue
 587:include/linux/skbuff.h ****  *
GAS LISTING  			page 26


 588:include/linux/skbuff.h ****  *	Queue a buffer at the end of a list. This function takes no locks
 589:include/linux/skbuff.h ****  *	and you must therefore hold required locks before calling it.
 590:include/linux/skbuff.h ****  *
 591:include/linux/skbuff.h ****  *	A buffer cannot be placed on two lists at the same time.
 592:include/linux/skbuff.h ****  */
 593:include/linux/skbuff.h **** extern void skb_queue_tail(struct sk_buff_head *list, struct sk_buff *newsk);
 594:include/linux/skbuff.h **** static inline void __skb_queue_tail(struct sk_buff_head *list,
 595:include/linux/skbuff.h **** 				   struct sk_buff *newsk)
 596:include/linux/skbuff.h **** {
 597:include/linux/skbuff.h **** 	struct sk_buff *prev, *next;
 598:include/linux/skbuff.h **** 
 599:include/linux/skbuff.h **** 	newsk->list = list;
 600:include/linux/skbuff.h **** 	list->qlen++;
 601:include/linux/skbuff.h **** 	next = (struct sk_buff *)list;
 602:include/linux/skbuff.h **** 	prev = next->prev;
 603:include/linux/skbuff.h **** 	newsk->next = next;
 604:include/linux/skbuff.h **** 	newsk->prev = prev;
 605:include/linux/skbuff.h **** 	next->prev  = prev->next = newsk;
 606:include/linux/skbuff.h **** }
 607:include/linux/skbuff.h **** 
 608:include/linux/skbuff.h **** 
 609:include/linux/skbuff.h **** /**
 610:include/linux/skbuff.h ****  *	__skb_dequeue - remove from the head of the queue
 611:include/linux/skbuff.h ****  *	@list: list to dequeue from
 612:include/linux/skbuff.h ****  *
 613:include/linux/skbuff.h ****  *	Remove the head of the list. This function does not take any locks
 614:include/linux/skbuff.h ****  *	so must be used with appropriate locks held only. The head item is
 615:include/linux/skbuff.h ****  *	returned or %NULL if the list is empty.
 616:include/linux/skbuff.h ****  */
 617:include/linux/skbuff.h **** extern struct sk_buff *skb_dequeue(struct sk_buff_head *list);
 618:include/linux/skbuff.h **** static inline struct sk_buff *__skb_dequeue(struct sk_buff_head *list)
 619:include/linux/skbuff.h **** {
 620:include/linux/skbuff.h **** 	struct sk_buff *next, *prev, *result;
 621:include/linux/skbuff.h **** 
 622:include/linux/skbuff.h **** 	prev = (struct sk_buff *) list;
 623:include/linux/skbuff.h **** 	next = prev->next;
 624:include/linux/skbuff.h **** 	result = NULL;
 625:include/linux/skbuff.h **** 	if (next != prev) {
 626:include/linux/skbuff.h **** 		result	     = next;
 627:include/linux/skbuff.h **** 		next	     = next->next;
 628:include/linux/skbuff.h **** 		list->qlen--;
 629:include/linux/skbuff.h **** 		next->prev   = prev;
 630:include/linux/skbuff.h **** 		prev->next   = next;
 631:include/linux/skbuff.h **** 		result->next = result->prev = NULL;
 632:include/linux/skbuff.h **** 		result->list = NULL;
 633:include/linux/skbuff.h **** 	}
 634:include/linux/skbuff.h **** 	return result;
 635:include/linux/skbuff.h **** }
 636:include/linux/skbuff.h **** 
 637:include/linux/skbuff.h **** 
 638:include/linux/skbuff.h **** /*
 639:include/linux/skbuff.h ****  *	Insert a packet on a list.
 640:include/linux/skbuff.h ****  */
 641:include/linux/skbuff.h **** extern void        skb_insert(struct sk_buff *old, struct sk_buff *newsk);
 642:include/linux/skbuff.h **** static inline void __skb_insert(struct sk_buff *newsk,
 643:include/linux/skbuff.h **** 				struct sk_buff *prev, struct sk_buff *next,
 644:include/linux/skbuff.h **** 				struct sk_buff_head *list)
GAS LISTING  			page 27


 645:include/linux/skbuff.h **** {
 646:include/linux/skbuff.h **** 	newsk->next = next;
 647:include/linux/skbuff.h **** 	newsk->prev = prev;
 648:include/linux/skbuff.h **** 	next->prev  = prev->next = newsk;
 649:include/linux/skbuff.h **** 	newsk->list = list;
 650:include/linux/skbuff.h **** 	list->qlen++;
 651:include/linux/skbuff.h **** }
 652:include/linux/skbuff.h **** 
 653:include/linux/skbuff.h **** /*
 654:include/linux/skbuff.h ****  *	Place a packet after a given packet in a list.
 655:include/linux/skbuff.h ****  */
 656:include/linux/skbuff.h **** extern void	   skb_append(struct sk_buff *old, struct sk_buff *newsk);
 657:include/linux/skbuff.h **** static inline void __skb_append(struct sk_buff *old, struct sk_buff *newsk)
 658:include/linux/skbuff.h **** {
 659:include/linux/skbuff.h **** 	__skb_insert(newsk, old, old->next, old->list);
 660:include/linux/skbuff.h **** }
 661:include/linux/skbuff.h **** 
 662:include/linux/skbuff.h **** /*
 663:include/linux/skbuff.h ****  * remove sk_buff from list. _Must_ be called atomically, and with
 664:include/linux/skbuff.h ****  * the list known..
 665:include/linux/skbuff.h ****  */
 666:include/linux/skbuff.h **** extern void	   skb_unlink(struct sk_buff *skb);
 667:include/linux/skbuff.h **** static inline void __skb_unlink(struct sk_buff *skb, struct sk_buff_head *list)
 668:include/linux/skbuff.h **** {
 669:include/linux/skbuff.h **** 	struct sk_buff *next, *prev;
 670:include/linux/skbuff.h **** 
 671:include/linux/skbuff.h **** 	list->qlen--;
 672:include/linux/skbuff.h **** 	next	   = skb->next;
 673:include/linux/skbuff.h **** 	prev	   = skb->prev;
 674:include/linux/skbuff.h **** 	skb->next  = skb->prev = NULL;
 675:include/linux/skbuff.h **** 	skb->list  = NULL;
 676:include/linux/skbuff.h **** 	next->prev = prev;
 677:include/linux/skbuff.h **** 	prev->next = next;
 678:include/linux/skbuff.h **** }
 679:include/linux/skbuff.h **** 
 680:include/linux/skbuff.h **** 
 681:include/linux/skbuff.h **** /* XXX: more streamlined implementation */
 682:include/linux/skbuff.h **** 
 683:include/linux/skbuff.h **** /**
 684:include/linux/skbuff.h ****  *	__skb_dequeue_tail - remove from the tail of the queue
 685:include/linux/skbuff.h ****  *	@list: list to dequeue from
 686:include/linux/skbuff.h ****  *
 687:include/linux/skbuff.h ****  *	Remove the tail of the list. This function does not take any locks
 688:include/linux/skbuff.h ****  *	so must be used with appropriate locks held only. The tail item is
 689:include/linux/skbuff.h ****  *	returned or %NULL if the list is empty.
 690:include/linux/skbuff.h ****  */
 691:include/linux/skbuff.h **** extern struct sk_buff *skb_dequeue_tail(struct sk_buff_head *list);
 692:include/linux/skbuff.h **** static inline struct sk_buff *__skb_dequeue_tail(struct sk_buff_head *list)
 693:include/linux/skbuff.h **** {
 694:include/linux/skbuff.h **** 	struct sk_buff *skb = skb_peek_tail(list);
 695:include/linux/skbuff.h **** 	if (skb)
 696:include/linux/skbuff.h **** 		__skb_unlink(skb, list);
 697:include/linux/skbuff.h **** 	return skb;
 698:include/linux/skbuff.h **** }
 699:include/linux/skbuff.h **** 
 700:include/linux/skbuff.h **** 
 701:include/linux/skbuff.h **** static inline int skb_is_nonlinear(const struct sk_buff *skb)
GAS LISTING  			page 28


 702:include/linux/skbuff.h **** {
 703:include/linux/skbuff.h **** 	return skb->data_len;
 704:include/linux/skbuff.h **** }
 705:include/linux/skbuff.h **** 
 706:include/linux/skbuff.h **** static inline unsigned int skb_headlen(const struct sk_buff *skb)
 707:include/linux/skbuff.h **** {
 708:include/linux/skbuff.h **** 	return skb->len - skb->data_len;
 709:include/linux/skbuff.h **** }
 710:include/linux/skbuff.h **** 
 711:include/linux/skbuff.h **** static inline int skb_pagelen(const struct sk_buff *skb)
 712:include/linux/skbuff.h **** {
 713:include/linux/skbuff.h **** 	int i, len = 0;
 714:include/linux/skbuff.h **** 
 715:include/linux/skbuff.h **** 	for (i = (int)skb_shinfo(skb)->nr_frags - 1; i >= 0; i--)
 716:include/linux/skbuff.h **** 		len += skb_shinfo(skb)->frags[i].size;
 717:include/linux/skbuff.h **** 	return len + skb_headlen(skb);
 718:include/linux/skbuff.h **** }
 719:include/linux/skbuff.h **** 
 720:include/linux/skbuff.h **** static inline void skb_fill_page_desc(struct sk_buff *skb, int i,
 721:include/linux/skbuff.h **** 				      struct page *page, int off, int size)
 722:include/linux/skbuff.h **** {
 723:include/linux/skbuff.h **** 	skb_frag_t *frag = &skb_shinfo(skb)->frags[i];
 724:include/linux/skbuff.h **** 
 725:include/linux/skbuff.h **** 	frag->page		  = page;
 726:include/linux/skbuff.h **** 	frag->page_offset	  = off;
 727:include/linux/skbuff.h **** 	frag->size		  = size;
 728:include/linux/skbuff.h **** 	skb_shinfo(skb)->nr_frags = i + 1;
 729:include/linux/skbuff.h **** }
 730:include/linux/skbuff.h **** 
 731:include/linux/skbuff.h **** #define SKB_PAGE_ASSERT(skb) 	BUG_ON(skb_shinfo(skb)->nr_frags)
 732:include/linux/skbuff.h **** #define SKB_FRAG_ASSERT(skb) 	BUG_ON(skb_shinfo(skb)->frag_list)
 733:include/linux/skbuff.h **** #define SKB_LINEAR_ASSERT(skb)  BUG_ON(skb_is_nonlinear(skb))
 734:include/linux/skbuff.h **** 
 735:include/linux/skbuff.h **** /*
 736:include/linux/skbuff.h ****  *	Add data to an sk_buff
 737:include/linux/skbuff.h ****  */
 738:include/linux/skbuff.h **** static inline unsigned char *__skb_put(struct sk_buff *skb, unsigned int len)
 739:include/linux/skbuff.h **** {
 740:include/linux/skbuff.h **** 	unsigned char *tmp = skb->tail;
 741:include/linux/skbuff.h **** 	SKB_LINEAR_ASSERT(skb);
 742:include/linux/skbuff.h **** 	skb->tail += len;
 743:include/linux/skbuff.h **** 	skb->len  += len;
 744:include/linux/skbuff.h **** 	return tmp;
 745:include/linux/skbuff.h **** }
 746:include/linux/skbuff.h **** 
 747:include/linux/skbuff.h **** /**
 748:include/linux/skbuff.h ****  *	skb_put - add data to a buffer
 749:include/linux/skbuff.h ****  *	@skb: buffer to use
 750:include/linux/skbuff.h ****  *	@len: amount of data to add
 751:include/linux/skbuff.h ****  *
 752:include/linux/skbuff.h ****  *	This function extends the used data area of the buffer. If this would
 753:include/linux/skbuff.h ****  *	exceed the total buffer size the kernel will panic. A pointer to the
 754:include/linux/skbuff.h ****  *	first byte of the extra data is returned.
 755:include/linux/skbuff.h ****  */
 756:include/linux/skbuff.h **** static inline unsigned char *skb_put(struct sk_buff *skb, unsigned int len)
 757:include/linux/skbuff.h **** {
 758:include/linux/skbuff.h **** 	unsigned char *tmp = skb->tail;
GAS LISTING  			page 29


 759:include/linux/skbuff.h **** 	SKB_LINEAR_ASSERT(skb);
 760:include/linux/skbuff.h **** 	skb->tail += len;
 761:include/linux/skbuff.h **** 	skb->len  += len;
 762:include/linux/skbuff.h **** 	if (unlikely(skb->tail>skb->end))
 763:include/linux/skbuff.h **** 		skb_over_panic(skb, len, current_text_addr());
 764:include/linux/skbuff.h **** 	return tmp;
 765:include/linux/skbuff.h **** }
 766:include/linux/skbuff.h **** 
 767:include/linux/skbuff.h **** static inline unsigned char *__skb_push(struct sk_buff *skb, unsigned int len)
 768:include/linux/skbuff.h **** {
 769:include/linux/skbuff.h **** 	skb->data -= len;
 770:include/linux/skbuff.h **** 	skb->len  += len;
 771:include/linux/skbuff.h **** 	return skb->data;
 772:include/linux/skbuff.h **** }
 773:include/linux/skbuff.h **** 
 774:include/linux/skbuff.h **** /**
 775:include/linux/skbuff.h ****  *	skb_push - add data to the start of a buffer
 776:include/linux/skbuff.h ****  *	@skb: buffer to use
 777:include/linux/skbuff.h ****  *	@len: amount of data to add
 778:include/linux/skbuff.h ****  *
 779:include/linux/skbuff.h ****  *	This function extends the used data area of the buffer at the buffer
 780:include/linux/skbuff.h ****  *	start. If this would exceed the total buffer headroom the kernel will
 781:include/linux/skbuff.h ****  *	panic. A pointer to the first byte of the extra data is returned.
 782:include/linux/skbuff.h ****  */
 783:include/linux/skbuff.h **** static inline unsigned char *skb_push(struct sk_buff *skb, unsigned int len)
 784:include/linux/skbuff.h **** {
 785:include/linux/skbuff.h **** 	skb->data -= len;
 786:include/linux/skbuff.h **** 	skb->len  += len;
 787:include/linux/skbuff.h **** 	if (unlikely(skb->data<skb->head))
 788:include/linux/skbuff.h **** 		skb_under_panic(skb, len, current_text_addr());
 789:include/linux/skbuff.h **** 	return skb->data;
 790:include/linux/skbuff.h **** }
 791:include/linux/skbuff.h **** 
 792:include/linux/skbuff.h **** static inline unsigned char *__skb_pull(struct sk_buff *skb, unsigned int len)
 793:include/linux/skbuff.h **** {
 794:include/linux/skbuff.h **** 	skb->len -= len;
 795:include/linux/skbuff.h **** 	BUG_ON(skb->len < skb->data_len);
 796:include/linux/skbuff.h **** 	return skb->data += len;
 797:include/linux/skbuff.h **** }
 798:include/linux/skbuff.h **** 
 799:include/linux/skbuff.h **** /**
 800:include/linux/skbuff.h ****  *	skb_pull - remove data from the start of a buffer
 801:include/linux/skbuff.h ****  *	@skb: buffer to use
 802:include/linux/skbuff.h ****  *	@len: amount of data to remove
 803:include/linux/skbuff.h ****  *
 804:include/linux/skbuff.h ****  *	This function removes data from the start of a buffer, returning
 805:include/linux/skbuff.h ****  *	the memory to the headroom. A pointer to the next data in the buffer
 806:include/linux/skbuff.h ****  *	is returned. Once the data has been pulled future pushes will overwrite
 807:include/linux/skbuff.h ****  *	the old data.
 808:include/linux/skbuff.h ****  */
 809:include/linux/skbuff.h **** static inline unsigned char *skb_pull(struct sk_buff *skb, unsigned int len)
 810:include/linux/skbuff.h **** {
 811:include/linux/skbuff.h **** 	return unlikely(len > skb->len) ? NULL : __skb_pull(skb, len);
 812:include/linux/skbuff.h **** }
 813:include/linux/skbuff.h **** 
 814:include/linux/skbuff.h **** extern unsigned char *__pskb_pull_tail(struct sk_buff *skb, int delta);
 815:include/linux/skbuff.h **** 
GAS LISTING  			page 30


 816:include/linux/skbuff.h **** static inline unsigned char *__pskb_pull(struct sk_buff *skb, unsigned int len)
 817:include/linux/skbuff.h **** {
 818:include/linux/skbuff.h **** 	if (len > skb_headlen(skb) &&
 819:include/linux/skbuff.h **** 	    !__pskb_pull_tail(skb, len-skb_headlen(skb)))
 820:include/linux/skbuff.h **** 		return NULL;
 821:include/linux/skbuff.h **** 	skb->len -= len;
 822:include/linux/skbuff.h **** 	return skb->data += len;
 823:include/linux/skbuff.h **** }
 824:include/linux/skbuff.h **** 
 825:include/linux/skbuff.h **** static inline unsigned char *pskb_pull(struct sk_buff *skb, unsigned int len)
 826:include/linux/skbuff.h **** {
 827:include/linux/skbuff.h **** 	return unlikely(len > skb->len) ? NULL : __pskb_pull(skb, len);
 828:include/linux/skbuff.h **** }
 829:include/linux/skbuff.h **** 
 830:include/linux/skbuff.h **** static inline int pskb_may_pull(struct sk_buff *skb, unsigned int len)
 831:include/linux/skbuff.h **** {
 832:include/linux/skbuff.h **** 	if (likely(len <= skb_headlen(skb)))
 833:include/linux/skbuff.h **** 		return 1;
 834:include/linux/skbuff.h **** 	if (unlikely(len > skb->len))
 835:include/linux/skbuff.h **** 		return 0;
 836:include/linux/skbuff.h **** 	return __pskb_pull_tail(skb, len-skb_headlen(skb)) != NULL;
 837:include/linux/skbuff.h **** }
 838:include/linux/skbuff.h **** 
 839:include/linux/skbuff.h **** /**
 840:include/linux/skbuff.h ****  *	skb_headroom - bytes at buffer head
 841:include/linux/skbuff.h ****  *	@skb: buffer to check
 842:include/linux/skbuff.h ****  *
 843:include/linux/skbuff.h ****  *	Return the number of bytes of free space at the head of an &sk_buff.
 844:include/linux/skbuff.h ****  */
 845:include/linux/skbuff.h **** static inline int skb_headroom(const struct sk_buff *skb)
 846:include/linux/skbuff.h **** {
 847:include/linux/skbuff.h **** 	return skb->data - skb->head;
 208              	.loc 4 847 0
 209 00a1 8B93A800 	movl 168(%ebx),%edx
 209      0000
 210 00a7 8B8BA400 	movl 164(%ebx),%ecx
 210      0000
 211 00ad 89D0     	movl %edx,%eax
 212 00af 29C8     	subl %ecx,%eax
 213              	.LBE12:
 214              	.LBE11:
 215              	.loc 4 846 0
 216 00b1 83F803   	cmpl $3,%eax
 217              	.loc 1 81 0
 218 00b4 8B7C2414 	movl 20(%esp),%edi
 219 00b8 8B742420 	movl 32(%esp),%esi
 220              	.loc 4 846 0
 221 00bc 7E07     	jle .L56
 222 00be 8B4360   	movl 96(%ebx),%eax
 223 00c1 39F8     	cmpl %edi,%eax
 224 00c3 7308     	jae .L55
 225              	.L56:
  82:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	struct prism2_wep_data *wep = priv;
  83:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	u32 klen, len;
  84:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	u8 *pos;
  85:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 
  86:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	if (skb_headroom(skb) < 4 || skb->len < hdr_len)
GAS LISTING  			page 31


  87:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 		return -1;
 226              	.loc 1 87 0
 227 00c5 83C8FF   	orl $-1,%eax
 228 00c8 E98C0000 	jmp .L54
 228      00
 229              	.L55:
 230              	.LBB13:
 231              	.LBB14:
 232              	.loc 4 785 0
 233 00cd 83EA04   	subl $4,%edx
 234              	.loc 4 786 0
 235 00d0 83C004   	addl $4,%eax
 236              	.loc 4 787 0
 237 00d3 39CA     	cmpl %ecx,%edx
 238              	.loc 4 785 0
 239 00d5 8993A800 	movl %edx,168(%ebx)
 239      0000
 240              	.loc 4 786 0
 241 00db 894360   	movl %eax,96(%ebx)
 242              	.loc 4 787 0
 243 00de 7311     	jae .L58
 244              	.LBB15:
 245              	.loc 4 788 0
 246              	
 247 00e0 B8E50000 	movl $1f,%eax
 247      00
 248              	1:
 249              	
 250              	.LBE15:
 251 00e5 50       	pushl %eax
 252              	.LCFI34:
 253 00e6 6A04     	pushl $4
 254              	.LCFI35:
 255 00e8 53       	pushl %ebx
 256              	.LCFI36:
 257 00e9 E8FCFFFF 	call skb_under_panic
 257      FF
 258 00ee 83C40C   	addl $12,%esp
 259              	.LCFI37:
 260              	.L58:
 261 00f1 8B9BA800 	movl 168(%ebx),%ebx
 261      0000
 262              	.LBE14:
 263              	.LBE13:
  88:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 
  89:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	len = skb->len - hdr_len;
  90:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	pos = skb_push(skb, 4);
  91:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	memmove(pos, pos + 4, hdr_len);
 264              	.loc 1 91 0
 265 00f7 8D4304   	leal 4(%ebx),%eax
 266 00fa 57       	pushl %edi
 267              	.LCFI38:
 268 00fb 50       	pushl %eax
 269              	.LCFI39:
 270 00fc 53       	pushl %ebx
 271              	.LCFI40:
 272 00fd E8FCFFFF 	call memmove
GAS LISTING  			page 32


 272      FF
  92:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	pos += hdr_len;
  93:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 
  94:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	klen = 3 + wep->key_len;
  95:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 
  96:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	wep->iv++;
 273              	.loc 1 96 0
 274 0102 8B0E     	movl (%esi),%ecx
 275              	.loc 1 94 0
 276 0104 0FB64612 	movzbl 18(%esi),%eax
 277              	.loc 1 96 0
 278 0108 8D5101   	leal 1(%ecx),%edx
 279              	.loc 1 92 0
 280 010b 01FB     	addl %edi,%ebx
 281              	.loc 1 94 0
 282 010d 8D7803   	leal 3(%eax),%edi
  97:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 
  98:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	/* Fluhrer, Mantin, and Shamir have reported weaknesses in the key
  99:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	 * scheduling algorithm of RC4. At least IVs (KeyByte + 3, 0xff, N)
 100:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	 * can be used to speedup attacks, so avoid using them. */
 101:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	if ((wep->iv & 0xff00) == 0xff00) {
 283              	.loc 1 101 0
 284 0110 89D0     	movl %edx,%eax
 285 0112 2500FF00 	andl $65280,%eax
 285      00
 286 0117 83C40C   	addl $12,%esp
 287              	.LCFI41:
 288 011a 3D00FF00 	cmpl $65280,%eax
 288      00
 289              	.loc 1 96 0
 290 011f 8916     	movl %edx,(%esi)
 291              	.loc 1 101 0
 292 0121 7518     	jne .L60
 293              	.LBB16:
 102:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 		u8 B = (wep->iv >> 16) & 0xff;
 294              	.loc 1 102 0
 295 0123 89D0     	movl %edx,%eax
 296 0125 C1E810   	shrl $16,%eax
 103:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 		if (B >= 3 && B < klen)
 297              	.loc 1 103 0
 298 0128 3C02     	cmpb $2,%al
 299 012a 760F     	jbe .L60
 300 012c 0FB6C0   	movzbl %al,%eax
 301 012f 39F8     	cmpl %edi,%eax
 302 0131 7308     	jae .L60
 104:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 			wep->iv += 0x0100;
 303              	.loc 1 104 0
 304 0133 8D810101 	leal 257(%ecx),%eax
 304      0000
 305 0139 8906     	movl %eax,(%esi)
 306              	.L60:
 307              	.LBE16:
 105:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	}
 106:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 
 107:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	/* Prepend 24-bit IV to RC4 key and TX frame */
 108:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	*pos++ = (wep->iv >> 16) & 0xff;
 308              	.loc 1 108 0
GAS LISTING  			page 33


 309 013b 0FB74602 	movzwl 2(%esi),%eax
 310 013f 8803     	movb %al,(%ebx)
 109:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	*pos++ = (wep->iv >> 8) & 0xff;
 311              	.loc 1 109 0
 312 0141 8B06     	movl (%esi),%eax
 313              	.loc 1 108 0
 314 0143 43       	incl %ebx
 315              	.loc 1 109 0
 316 0144 C1E808   	shrl $8,%eax
 317 0147 8803     	movb %al,(%ebx)
 110:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	*pos++ = wep->iv & 0xff;
 318              	.loc 1 110 0
 319 0149 8B06     	movl (%esi),%eax
 320              	.loc 1 109 0
 321 014b 43       	incl %ebx
 322              	.loc 1 110 0
 323 014c 8803     	movb %al,(%ebx)
 111:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	*pos++ = wep->key_idx << 6;
 324              	.loc 1 111 0
 325 014e 8A4613   	movb 19(%esi),%al
 326 0151 C1E006   	sall $6,%eax
 327 0154 884301   	movb %al,1(%ebx)
 112:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 
 113:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	return 0;
 328              	.loc 1 113 0
 329 0157 31C0     	xorl %eax,%eax
 330              	.L54:
 114:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** }
 331              	.loc 1 114 0
 332 0159 5B       	popl %ebx
 333 015a 5E       	popl %esi
 334 015b 5F       	popl %edi
 335 015c C3       	ret
 336              	.LFE689:
 339              	prism2_wep_encrypt:
 340              	.LFB690:
 115:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 
 116:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** /* Perform WEP encryption on given skb that has at least 4 bytes of headroom
 117:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c ****  * for IV and 4 bytes of tailroom for ICV. Both IV and ICV will be transmitted,
 118:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c ****  * so the payload length increases with 8 bytes.
 119:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c ****  *
 120:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c ****  * WEP frame payload: IV + TX key idx, RC4(data), ICV = RC4(CRC32(data))
 121:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c ****  */
 122:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** static int prism2_wep_encrypt(struct sk_buff *skb, int hdr_len, void *priv)
 123:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** {
 341              	.loc 1 123 0
 342 015d 55       	pushl %ebp
 343              	.LCFI42:
 344 015e 57       	pushl %edi
 345              	.LCFI43:
 346 015f 56       	pushl %esi
 347              	.LCFI44:
 348 0160 53       	pushl %ebx
 349              	.LCFI45:
 350 0161 83EC2C   	subl $44,%esp
 351              	.LCFI46:
 352              	.loc 1 123 0
GAS LISTING  			page 34


 353 0164 8B5C2440 	movl 64(%esp),%ebx
 354              	.LBB17:
 355              	.LBB18:
 356              	.loc 4 702 0
 357 0168 837B6400 	cmpl $0,100(%ebx)
 358              	.LBE18:
 359              	.LBE17:
 360              	.loc 1 123 0
 361 016c 8B6C2444 	movl 68(%esp),%ebp
 362              	.LBB19:
 363              	.LBB20:
 364              	.loc 4 702 0
 365 0170 7511     	jne .L129
 366 0172 8B83B000 	movl 176(%ebx),%eax
 366      0000
 367 0178 2B83AC00 	subl 172(%ebx),%eax
 367      0000
 368              	.LBE20:
 369              	.LBE19:
 848:include/linux/skbuff.h **** }
 849:include/linux/skbuff.h **** 
 850:include/linux/skbuff.h **** /**
 851:include/linux/skbuff.h ****  *	skb_tailroom - bytes at buffer end
 852:include/linux/skbuff.h ****  *	@skb: buffer to check
 853:include/linux/skbuff.h ****  *
 854:include/linux/skbuff.h ****  *	Return the number of bytes of free space at the tail of an sk_buff
 855:include/linux/skbuff.h ****  */
 856:include/linux/skbuff.h **** static inline int skb_tailroom(const struct sk_buff *skb)
 857:include/linux/skbuff.h **** {
 370              	.loc 4 857 0
 371 017e 83F803   	cmpl $3,%eax
 372 0181 7F08     	jg .L63
 373              	.L129:
 124:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	struct prism2_wep_data *wep = priv;
 125:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	u32 crc, klen, len;
 126:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	u8 *pos, *icv;
 127:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	struct scatterlist sg;
 128:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	u8 key[WEP_KEY_LEN + 3];
 129:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 
 130:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	/* other checks are in prism2_wep_build_iv */
 131:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	if (skb_tailroom(skb) < 4)
 132:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 		return -1;
 374              	.loc 1 132 0
 375 0183 83CAFF   	orl $-1,%edx
 376 0186 E94D0100 	jmp .L62
 376      00
 377              	.L63:
 133:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 
 134:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	/* add the IV to the frame */
 135:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	if (prism2_wep_build_iv(skb, hdr_len, NULL, 0, priv))
 378              	.loc 1 135 0
 379 018b FF742448 	pushl 72(%esp)
 380              	.LCFI47:
 381 018f 6A00     	pushl $0
 382              	.LCFI48:
 383 0191 6A00     	pushl $0
 384              	.LCFI49:
GAS LISTING  			page 35


 385 0193 55       	pushl %ebp
 386              	.LCFI50:
 387 0194 53       	pushl %ebx
 388              	.LCFI51:
 389 0195 E800FFFF 	call prism2_wep_build_iv
 389      FF
 390 019a 83C414   	addl $20,%esp
 391              	.LCFI52:
 136:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 		return -1;
 392              	.loc 1 136 0
 393 019d 83CAFF   	orl $-1,%edx
 394              	.loc 1 135 0
 395 01a0 85C0     	testl %eax,%eax
 396 01a2 0F853001 	jne .L62
 396      0000
 397              	.LBB21:
 398              	.loc 3 227 0
 399 01a8 8B93A800 	movl 168(%ebx),%edx
 399      0000
 400 01ae 01EA     	addl %ebp,%edx
 401              	.LBB22:
 402              	.loc 3 236 0
 403 01b0 668B02   	movw (%edx),%ax
 404 01b3 66894424 	movw %ax,12(%esp)
 404      0C
 405              	.loc 3 237 0
 406 01b8 8A4202   	movb 2(%edx),%al
 407 01bb 8844240E 	movb %al,14(%esp)
 408              	.LBE22:
 409              	.LBE21:
 137:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 
 138:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	/* Copy the IV into the first 3 bytes of the key */
 139:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	memcpy(key, skb->data + hdr_len, 3);
 140:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 
 141:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	/* Copy rest of the WEP key (the secret part) */
 142:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	memcpy(key + 3, wep->key, wep->key_len);
 410              	.loc 1 142 0
 411 01bf 8B542448 	movl 72(%esp),%edx
 412 01c3 0FB64212 	movzbl 18(%edx),%eax
 413              	.LBB23:
 414              	.LBB24:
 415              	.loc 3 207 0
 416 01c7 89C1     	movl %eax,%ecx
 417 01c9 8D7C240F 	leal 15(%esp),%edi
 418 01cd 8D7204   	leal 4(%edx),%esi
 419 01d0 C1E902   	shrl $2,%ecx
 420              	
 421 01d3 F3A5     	rep
 422 01d5 89C1     	movl %eax,%ecx
 423 01d7 83E103   	andl $3,%ecx
 424 01da 7402     	jz 1f
 425 01dc F3A4     	rep
 426              	1:
 427              	
 428              	.LBE24:
 429              	.LBE23:
 143:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 
GAS LISTING  			page 36


 144:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	len = skb->len - hdr_len - 4;
 430              	.loc 1 144 0
 431 01de 8B4B60   	movl 96(%ebx),%ecx
 432 01e1 29E9     	subl %ebp,%ecx
 433 01e3 894C2404 	movl %ecx,4(%esp)
 145:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	pos = skb->data + hdr_len + 4;
 434              	.loc 1 145 0
 435 01e7 03ABA800 	addl 168(%ebx),%ebp
 435      0000
 436 01ed 892C24   	movl %ebp,(%esp)
 437              	.loc 1 144 0
 438 01f0 89CA     	movl %ecx,%edx
 146:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	klen = 3 + wep->key_len;
 439              	.loc 1 146 0
 440 01f2 8B4C2448 	movl 72(%esp),%ecx
 441 01f6 0FB64112 	movzbl 18(%ecx),%eax
 442              	.loc 1 144 0
 443 01fa 83EA04   	subl $4,%edx
 444              	.loc 1 146 0
 445 01fd 83C003   	addl $3,%eax
 446 0200 89442408 	movl %eax,8(%esp)
 447              	.loc 1 145 0
 448 0204 83C504   	addl $4,%ebp
 147:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 
 148:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	/* Append little-endian CRC32 over only the data and encrypt it to produce ICV */
 149:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	crc = ~crc32_le(~0, pos, len);
 449              	.loc 1 149 0
 450 0207 52       	pushl %edx
 451              	.LCFI53:
 452 0208 55       	pushl %ebp
 453              	.LCFI54:
 454 0209 6AFF     	pushl $-1
 455              	.LCFI55:
 456 020b E8FCFFFF 	call crc32_le
 456      FF
 457 0210 89C6     	movl %eax,%esi
 458              	.loc 4 757 0
 459 0212 83C40C   	addl $12,%esp
 460              	.LCFI56:
 461              	.LBB25:
 462              	.LBB26:
 463              	.loc 4 702 0
 464 0215 837B6400 	cmpl $0,100(%ebx)
 465              	.LBE26:
 466              	.LBE25:
 467              	.loc 1 149 0
 468 0219 F7D6     	notl %esi
 469              	.LBB27:
 470              	.LBB28:
 471              	.loc 4 758 0
 472 021b 8BBBAC00 	movl 172(%ebx),%edi
 472      0000
 473              	.loc 4 702 0
 474 0221 7402     	je .L116
 475              	.loc 4 759 0
 476              	
 477 0223 0F0B     	ud2
GAS LISTING  			page 37


 478              	
 479              	
 480              	.L116:
 481              	.loc 4 760 0
 482 0225 8D4704   	leal 4(%edi),%eax
 483              	.loc 4 761 0
 484 0228 83436004 	addl $4,96(%ebx)
 485              	.loc 4 762 0
 486 022c 3B83B000 	cmpl 176(%ebx),%eax
 486      0000
 487              	.loc 4 760 0
 488 0232 8983AC00 	movl %eax,172(%ebx)
 488      0000
 489              	.loc 4 762 0
 490 0238 7611     	jbe .L119
 491              	.LBB29:
 492              	.loc 4 763 0
 493              	
 494 023a B83F0200 	movl $1f,%eax
 494      00
 495              	1:
 496              	
 497              	.LBE29:
 498 023f 50       	pushl %eax
 499              	.LCFI57:
 500 0240 6A04     	pushl $4
 501              	.LCFI58:
 502 0242 53       	pushl %ebx
 503              	.LCFI59:
 504 0243 E8FCFFFF 	call skb_over_panic
 504      FF
 505 0248 83C40C   	addl $12,%esp
 506              	.LCFI60:
 507              	.L119:
 508              	.LBE28:
 509              	.LBE27:
 150:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	icv = skb_put(skb, 4);
 151:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	icv[0] = crc;
 510              	.loc 1 151 0
 511 024b 89F0     	movl %esi,%eax
 152:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	icv[1] = crc >> 8;
 512              	.loc 1 152 0
 513 024d C1EE08   	shrl $8,%esi
 514 0250 89F2     	movl %esi,%edx
 153:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	icv[2] = crc >> 16;
 515              	.loc 1 153 0
 516 0252 C1EE08   	shrl $8,%esi
 517 0255 89F1     	movl %esi,%ecx
 154:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	icv[3] = crc >> 24;
 518              	.loc 1 154 0
 519 0257 C1EE08   	shrl $8,%esi
 520              	.loc 1 151 0
 521 025a 8807     	movb %al,(%edi)
 522              	.loc 1 154 0
 523 025c 89F0     	movl %esi,%eax
 524              	.loc 1 152 0
 525 025e 885701   	movb %dl,1(%edi)
GAS LISTING  			page 38


 526              	.loc 1 153 0
 527 0261 884F02   	movb %cl,2(%edi)
 528              	.loc 1 154 0
 529 0264 884703   	movb %al,3(%edi)
 530              	.LBB30:
 531              	.file 5 "include/linux/crypto.h"
   1:include/linux/crypto.h **** /*
   2:include/linux/crypto.h ****  * Scatterlist Cryptographic API.
   3:include/linux/crypto.h ****  *
   4:include/linux/crypto.h ****  * Copyright (c) 2002 James Morris <jmorris@intercode.com.au>
   5:include/linux/crypto.h ****  * Copyright (c) 2002 David S. Miller (davem@redhat.com)
   6:include/linux/crypto.h ****  *
   7:include/linux/crypto.h ****  * Portions derived from Cryptoapi, by Alexander Kjeldaas <astor@fast.no>
   8:include/linux/crypto.h ****  * and Nettle, by Niels Mller.
   9:include/linux/crypto.h ****  * 
  10:include/linux/crypto.h ****  * This program is free software; you can redistribute it and/or modify it
  11:include/linux/crypto.h ****  * under the terms of the GNU General Public License as published by the Free
  12:include/linux/crypto.h ****  * Software Foundation; either version 2 of the License, or (at your option) 
  13:include/linux/crypto.h ****  * any later version.
  14:include/linux/crypto.h ****  *
  15:include/linux/crypto.h ****  */
  16:include/linux/crypto.h **** #ifndef _LINUX_CRYPTO_H
  17:include/linux/crypto.h **** #define _LINUX_CRYPTO_H
  18:include/linux/crypto.h **** 
  19:include/linux/crypto.h **** #include <linux/config.h>
  20:include/linux/crypto.h **** #include <linux/module.h>
  21:include/linux/crypto.h **** #include <linux/kernel.h>
  22:include/linux/crypto.h **** #include <linux/types.h>
  23:include/linux/crypto.h **** #include <linux/list.h>
  24:include/linux/crypto.h **** #include <linux/string.h>
  25:include/linux/crypto.h **** #include <asm/page.h>
  26:include/linux/crypto.h **** 
  27:include/linux/crypto.h **** /*
  28:include/linux/crypto.h ****  * Algorithm masks and types.
  29:include/linux/crypto.h ****  */
  30:include/linux/crypto.h **** #define CRYPTO_ALG_TYPE_MASK		0x000000ff
  31:include/linux/crypto.h **** #define CRYPTO_ALG_TYPE_CIPHER		0x00000001
  32:include/linux/crypto.h **** #define CRYPTO_ALG_TYPE_DIGEST		0x00000002
  33:include/linux/crypto.h **** #define CRYPTO_ALG_TYPE_COMPRESS	0x00000004
  34:include/linux/crypto.h **** 
  35:include/linux/crypto.h **** /*
  36:include/linux/crypto.h ****  * Transform masks and values (for crt_flags).
  37:include/linux/crypto.h ****  */
  38:include/linux/crypto.h **** #define CRYPTO_TFM_MODE_MASK		0x000000ff
  39:include/linux/crypto.h **** #define CRYPTO_TFM_REQ_MASK		0x000fff00
  40:include/linux/crypto.h **** #define CRYPTO_TFM_RES_MASK		0xfff00000
  41:include/linux/crypto.h **** 
  42:include/linux/crypto.h **** #define CRYPTO_TFM_MODE_ECB		0x00000001
  43:include/linux/crypto.h **** #define CRYPTO_TFM_MODE_CBC		0x00000002
  44:include/linux/crypto.h **** #define CRYPTO_TFM_MODE_CFB		0x00000004
  45:include/linux/crypto.h **** #define CRYPTO_TFM_MODE_CTR		0x00000008
  46:include/linux/crypto.h **** 
  47:include/linux/crypto.h **** #define CRYPTO_TFM_REQ_WEAK_KEY		0x00000100
  48:include/linux/crypto.h **** #define CRYPTO_TFM_RES_WEAK_KEY		0x00100000
  49:include/linux/crypto.h **** #define CRYPTO_TFM_RES_BAD_KEY_LEN   	0x00200000
  50:include/linux/crypto.h **** #define CRYPTO_TFM_RES_BAD_KEY_SCHED 	0x00400000
  51:include/linux/crypto.h **** #define CRYPTO_TFM_RES_BAD_BLOCK_LEN 	0x00800000
GAS LISTING  			page 39


  52:include/linux/crypto.h **** #define CRYPTO_TFM_RES_BAD_FLAGS 	0x01000000
  53:include/linux/crypto.h **** 
  54:include/linux/crypto.h **** /*
  55:include/linux/crypto.h ****  * Miscellaneous stuff.
  56:include/linux/crypto.h ****  */
  57:include/linux/crypto.h **** #define CRYPTO_UNSPEC			0
  58:include/linux/crypto.h **** #define CRYPTO_MAX_ALG_NAME		64
  59:include/linux/crypto.h **** 
  60:include/linux/crypto.h **** #define CRYPTO_DIR_ENCRYPT		1
  61:include/linux/crypto.h **** #define CRYPTO_DIR_DECRYPT		0
  62:include/linux/crypto.h **** 
  63:include/linux/crypto.h **** struct scatterlist;
  64:include/linux/crypto.h **** 
  65:include/linux/crypto.h **** /*
  66:include/linux/crypto.h ****  * Algorithms: modular crypto algorithm implementations, managed
  67:include/linux/crypto.h ****  * via crypto_register_alg() and crypto_unregister_alg().
  68:include/linux/crypto.h ****  */
  69:include/linux/crypto.h **** struct cipher_alg {
  70:include/linux/crypto.h **** 	unsigned int cia_min_keysize;
  71:include/linux/crypto.h **** 	unsigned int cia_max_keysize;
  72:include/linux/crypto.h **** 	int (*cia_setkey)(void *ctx, const u8 *key,
  73:include/linux/crypto.h **** 	                  unsigned int keylen, u32 *flags);
  74:include/linux/crypto.h **** 	void (*cia_encrypt)(void *ctx, u8 *dst, const u8 *src);
  75:include/linux/crypto.h **** 	void (*cia_decrypt)(void *ctx, u8 *dst, const u8 *src);
  76:include/linux/crypto.h **** };
  77:include/linux/crypto.h **** 
  78:include/linux/crypto.h **** struct digest_alg {
  79:include/linux/crypto.h **** 	unsigned int dia_digestsize;
  80:include/linux/crypto.h **** 	void (*dia_init)(void *ctx);
  81:include/linux/crypto.h **** 	void (*dia_update)(void *ctx, const u8 *data, unsigned int len);
  82:include/linux/crypto.h **** 	void (*dia_final)(void *ctx, u8 *out);
  83:include/linux/crypto.h **** 	int (*dia_setkey)(void *ctx, const u8 *key,
  84:include/linux/crypto.h **** 	                  unsigned int keylen, u32 *flags);
  85:include/linux/crypto.h **** };
  86:include/linux/crypto.h **** 
  87:include/linux/crypto.h **** struct compress_alg {
  88:include/linux/crypto.h **** 	int (*coa_init)(void *ctx);
  89:include/linux/crypto.h **** 	void (*coa_exit)(void *ctx);
  90:include/linux/crypto.h **** 	int (*coa_compress)(void *ctx, const u8 *src, unsigned int slen,
  91:include/linux/crypto.h **** 	                    u8 *dst, unsigned int *dlen);
  92:include/linux/crypto.h **** 	int (*coa_decompress)(void *ctx, const u8 *src, unsigned int slen,
  93:include/linux/crypto.h **** 	                      u8 *dst, unsigned int *dlen);
  94:include/linux/crypto.h **** };
  95:include/linux/crypto.h **** 
  96:include/linux/crypto.h **** #define cra_cipher	cra_u.cipher
  97:include/linux/crypto.h **** #define cra_digest	cra_u.digest
  98:include/linux/crypto.h **** #define cra_compress	cra_u.compress
  99:include/linux/crypto.h **** 
 100:include/linux/crypto.h **** struct crypto_alg {
 101:include/linux/crypto.h **** 	struct list_head cra_list;
 102:include/linux/crypto.h **** 	u32 cra_flags;
 103:include/linux/crypto.h **** 	unsigned int cra_blocksize;
 104:include/linux/crypto.h **** 	unsigned int cra_ctxsize;
 105:include/linux/crypto.h **** 	const char cra_name[CRYPTO_MAX_ALG_NAME];
 106:include/linux/crypto.h **** 
 107:include/linux/crypto.h **** 	union {
 108:include/linux/crypto.h **** 		struct cipher_alg cipher;
GAS LISTING  			page 40


 109:include/linux/crypto.h **** 		struct digest_alg digest;
 110:include/linux/crypto.h **** 		struct compress_alg compress;
 111:include/linux/crypto.h **** 	} cra_u;
 112:include/linux/crypto.h **** 	
 113:include/linux/crypto.h **** 	struct module *cra_module;
 114:include/linux/crypto.h **** };
 115:include/linux/crypto.h **** 
 116:include/linux/crypto.h **** /*
 117:include/linux/crypto.h ****  * Algorithm registration interface.
 118:include/linux/crypto.h ****  */
 119:include/linux/crypto.h **** int crypto_register_alg(struct crypto_alg *alg);
 120:include/linux/crypto.h **** int crypto_unregister_alg(struct crypto_alg *alg);
 121:include/linux/crypto.h **** 
 122:include/linux/crypto.h **** /*
 123:include/linux/crypto.h ****  * Algorithm query interface.
 124:include/linux/crypto.h ****  */
 125:include/linux/crypto.h **** #ifdef CONFIG_CRYPTO
 126:include/linux/crypto.h **** int crypto_alg_available(const char *name, u32 flags);
 127:include/linux/crypto.h **** #else
 128:include/linux/crypto.h **** static inline int crypto_alg_available(const char *name, u32 flags)
 129:include/linux/crypto.h **** {
 130:include/linux/crypto.h **** 	return 0;
 131:include/linux/crypto.h **** }
 132:include/linux/crypto.h **** #endif
 133:include/linux/crypto.h **** 
 134:include/linux/crypto.h **** /*
 135:include/linux/crypto.h ****  * Transforms: user-instantiated objects which encapsulate algorithms
 136:include/linux/crypto.h ****  * and core processing logic.  Managed via crypto_alloc_tfm() and
 137:include/linux/crypto.h ****  * crypto_free_tfm(), as well as the various helpers below.
 138:include/linux/crypto.h ****  */
 139:include/linux/crypto.h **** struct crypto_tfm;
 140:include/linux/crypto.h **** 
 141:include/linux/crypto.h **** struct cipher_tfm {
 142:include/linux/crypto.h **** 	void *cit_iv;
 143:include/linux/crypto.h **** 	unsigned int cit_ivsize;
 144:include/linux/crypto.h **** 	u32 cit_mode;
 145:include/linux/crypto.h **** 	int (*cit_setkey)(struct crypto_tfm *tfm,
 146:include/linux/crypto.h **** 	                  const u8 *key, unsigned int keylen);
 147:include/linux/crypto.h **** 	int (*cit_encrypt)(struct crypto_tfm *tfm,
 148:include/linux/crypto.h **** 			   struct scatterlist *dst,
 149:include/linux/crypto.h **** 			   struct scatterlist *src,
 150:include/linux/crypto.h **** 			   unsigned int nbytes);
 151:include/linux/crypto.h **** 	int (*cit_encrypt_iv)(struct crypto_tfm *tfm,
 152:include/linux/crypto.h **** 	                      struct scatterlist *dst,
 153:include/linux/crypto.h **** 	                      struct scatterlist *src,
 154:include/linux/crypto.h **** 	                      unsigned int nbytes, u8 *iv);
 155:include/linux/crypto.h **** 	int (*cit_decrypt)(struct crypto_tfm *tfm,
 156:include/linux/crypto.h **** 			   struct scatterlist *dst,
 157:include/linux/crypto.h **** 			   struct scatterlist *src,
 158:include/linux/crypto.h **** 			   unsigned int nbytes);
 159:include/linux/crypto.h **** 	int (*cit_decrypt_iv)(struct crypto_tfm *tfm,
 160:include/linux/crypto.h **** 			   struct scatterlist *dst,
 161:include/linux/crypto.h **** 			   struct scatterlist *src,
 162:include/linux/crypto.h **** 			   unsigned int nbytes, u8 *iv);
 163:include/linux/crypto.h **** 	void (*cit_xor_block)(u8 *dst, const u8 *src);
 164:include/linux/crypto.h **** };
 165:include/linux/crypto.h **** 
GAS LISTING  			page 41


 166:include/linux/crypto.h **** struct digest_tfm {
 167:include/linux/crypto.h **** 	void (*dit_init)(struct crypto_tfm *tfm);
 168:include/linux/crypto.h **** 	void (*dit_update)(struct crypto_tfm *tfm,
 169:include/linux/crypto.h **** 	                   struct scatterlist *sg, unsigned int nsg);
 170:include/linux/crypto.h **** 	void (*dit_final)(struct crypto_tfm *tfm, u8 *out);
 171:include/linux/crypto.h **** 	void (*dit_digest)(struct crypto_tfm *tfm, struct scatterlist *sg,
 172:include/linux/crypto.h **** 	                   unsigned int nsg, u8 *out);
 173:include/linux/crypto.h **** 	int (*dit_setkey)(struct crypto_tfm *tfm,
 174:include/linux/crypto.h **** 	                  const u8 *key, unsigned int keylen);
 175:include/linux/crypto.h **** #ifdef CONFIG_CRYPTO_HMAC
 176:include/linux/crypto.h **** 	void *dit_hmac_block;
 177:include/linux/crypto.h **** #endif
 178:include/linux/crypto.h **** };
 179:include/linux/crypto.h **** 
 180:include/linux/crypto.h **** struct compress_tfm {
 181:include/linux/crypto.h **** 	int (*cot_compress)(struct crypto_tfm *tfm,
 182:include/linux/crypto.h **** 	                    const u8 *src, unsigned int slen,
 183:include/linux/crypto.h **** 	                    u8 *dst, unsigned int *dlen);
 184:include/linux/crypto.h **** 	int (*cot_decompress)(struct crypto_tfm *tfm,
 185:include/linux/crypto.h **** 	                      const u8 *src, unsigned int slen,
 186:include/linux/crypto.h **** 	                      u8 *dst, unsigned int *dlen);
 187:include/linux/crypto.h **** };
 188:include/linux/crypto.h **** 
 189:include/linux/crypto.h **** #define crt_cipher	crt_u.cipher
 190:include/linux/crypto.h **** #define crt_digest	crt_u.digest
 191:include/linux/crypto.h **** #define crt_compress	crt_u.compress
 192:include/linux/crypto.h **** 
 193:include/linux/crypto.h **** struct crypto_tfm {
 194:include/linux/crypto.h **** 
 195:include/linux/crypto.h **** 	u32 crt_flags;
 196:include/linux/crypto.h **** 	
 197:include/linux/crypto.h **** 	union {
 198:include/linux/crypto.h **** 		struct cipher_tfm cipher;
 199:include/linux/crypto.h **** 		struct digest_tfm digest;
 200:include/linux/crypto.h **** 		struct compress_tfm compress;
 201:include/linux/crypto.h **** 	} crt_u;
 202:include/linux/crypto.h **** 	
 203:include/linux/crypto.h **** 	struct crypto_alg *__crt_alg;
 204:include/linux/crypto.h **** };
 205:include/linux/crypto.h **** 
 206:include/linux/crypto.h **** /* 
 207:include/linux/crypto.h ****  * Transform user interface.
 208:include/linux/crypto.h ****  */
 209:include/linux/crypto.h ****  
 210:include/linux/crypto.h **** /*
 211:include/linux/crypto.h ****  * crypto_alloc_tfm() will first attempt to locate an already loaded algorithm.
 212:include/linux/crypto.h ****  * If that fails and the kernel supports dynamically loadable modules, it
 213:include/linux/crypto.h ****  * will then attempt to load a module of the same name or alias.  A refcount
 214:include/linux/crypto.h ****  * is grabbed on the algorithm which is then associated with the new transform.
 215:include/linux/crypto.h ****  *
 216:include/linux/crypto.h ****  * crypto_free_tfm() frees up the transform and any associated resources,
 217:include/linux/crypto.h ****  * then drops the refcount on the associated algorithm.
 218:include/linux/crypto.h ****  */
 219:include/linux/crypto.h **** struct crypto_tfm *crypto_alloc_tfm(const char *alg_name, u32 tfm_flags);
 220:include/linux/crypto.h **** void crypto_free_tfm(struct crypto_tfm *tfm);
 221:include/linux/crypto.h **** 
 222:include/linux/crypto.h **** /*
GAS LISTING  			page 42


 223:include/linux/crypto.h ****  * Transform helpers which query the underlying algorithm.
 224:include/linux/crypto.h ****  */
 225:include/linux/crypto.h **** static inline const char *crypto_tfm_alg_name(struct crypto_tfm *tfm)
 226:include/linux/crypto.h **** {
 227:include/linux/crypto.h **** 	return tfm->__crt_alg->cra_name;
 228:include/linux/crypto.h **** }
 229:include/linux/crypto.h **** 
 230:include/linux/crypto.h **** static inline const char *crypto_tfm_alg_modname(struct crypto_tfm *tfm)
 231:include/linux/crypto.h **** {
 232:include/linux/crypto.h **** 	return module_name(tfm->__crt_alg->cra_module);
 233:include/linux/crypto.h **** }
 234:include/linux/crypto.h **** 
 235:include/linux/crypto.h **** static inline u32 crypto_tfm_alg_type(struct crypto_tfm *tfm)
 236:include/linux/crypto.h **** {
 237:include/linux/crypto.h **** 	return tfm->__crt_alg->cra_flags & CRYPTO_ALG_TYPE_MASK;
 238:include/linux/crypto.h **** }
 239:include/linux/crypto.h **** 
 240:include/linux/crypto.h **** static inline unsigned int crypto_tfm_alg_min_keysize(struct crypto_tfm *tfm)
 241:include/linux/crypto.h **** {
 242:include/linux/crypto.h **** 	BUG_ON(crypto_tfm_alg_type(tfm) != CRYPTO_ALG_TYPE_CIPHER);
 243:include/linux/crypto.h **** 	return tfm->__crt_alg->cra_cipher.cia_min_keysize;
 244:include/linux/crypto.h **** }
 245:include/linux/crypto.h **** 
 246:include/linux/crypto.h **** static inline unsigned int crypto_tfm_alg_max_keysize(struct crypto_tfm *tfm)
 247:include/linux/crypto.h **** {
 248:include/linux/crypto.h **** 	BUG_ON(crypto_tfm_alg_type(tfm) != CRYPTO_ALG_TYPE_CIPHER);
 249:include/linux/crypto.h **** 	return tfm->__crt_alg->cra_cipher.cia_max_keysize;
 250:include/linux/crypto.h **** }
 251:include/linux/crypto.h **** 
 252:include/linux/crypto.h **** static inline unsigned int crypto_tfm_alg_ivsize(struct crypto_tfm *tfm)
 253:include/linux/crypto.h **** {
 254:include/linux/crypto.h **** 	BUG_ON(crypto_tfm_alg_type(tfm) != CRYPTO_ALG_TYPE_CIPHER);
 255:include/linux/crypto.h **** 	return tfm->crt_cipher.cit_ivsize;
 256:include/linux/crypto.h **** }
 257:include/linux/crypto.h **** 
 258:include/linux/crypto.h **** static inline unsigned int crypto_tfm_alg_blocksize(struct crypto_tfm *tfm)
 259:include/linux/crypto.h **** {
 260:include/linux/crypto.h **** 	return tfm->__crt_alg->cra_blocksize;
 261:include/linux/crypto.h **** }
 262:include/linux/crypto.h **** 
 263:include/linux/crypto.h **** static inline unsigned int crypto_tfm_alg_digestsize(struct crypto_tfm *tfm)
 264:include/linux/crypto.h **** {
 265:include/linux/crypto.h **** 	BUG_ON(crypto_tfm_alg_type(tfm) != CRYPTO_ALG_TYPE_DIGEST);
 266:include/linux/crypto.h **** 	return tfm->__crt_alg->cra_digest.dia_digestsize;
 267:include/linux/crypto.h **** }
 268:include/linux/crypto.h **** 
 269:include/linux/crypto.h **** /*
 270:include/linux/crypto.h ****  * API wrappers.
 271:include/linux/crypto.h ****  */
 272:include/linux/crypto.h **** static inline void crypto_digest_init(struct crypto_tfm *tfm)
 273:include/linux/crypto.h **** {
 274:include/linux/crypto.h **** 	BUG_ON(crypto_tfm_alg_type(tfm) != CRYPTO_ALG_TYPE_DIGEST);
 275:include/linux/crypto.h **** 	tfm->crt_digest.dit_init(tfm);
 276:include/linux/crypto.h **** }
 277:include/linux/crypto.h **** 
 278:include/linux/crypto.h **** static inline void crypto_digest_update(struct crypto_tfm *tfm,
 279:include/linux/crypto.h ****                                         struct scatterlist *sg,
GAS LISTING  			page 43


 280:include/linux/crypto.h ****                                         unsigned int nsg)
 281:include/linux/crypto.h **** {
 282:include/linux/crypto.h **** 	BUG_ON(crypto_tfm_alg_type(tfm) != CRYPTO_ALG_TYPE_DIGEST);
 283:include/linux/crypto.h **** 	tfm->crt_digest.dit_update(tfm, sg, nsg);
 284:include/linux/crypto.h **** }
 285:include/linux/crypto.h **** 
 286:include/linux/crypto.h **** static inline void crypto_digest_final(struct crypto_tfm *tfm, u8 *out)
 287:include/linux/crypto.h **** {
 288:include/linux/crypto.h **** 	BUG_ON(crypto_tfm_alg_type(tfm) != CRYPTO_ALG_TYPE_DIGEST);
 289:include/linux/crypto.h **** 	tfm->crt_digest.dit_final(tfm, out);
 290:include/linux/crypto.h **** }
 291:include/linux/crypto.h **** 
 292:include/linux/crypto.h **** static inline void crypto_digest_digest(struct crypto_tfm *tfm,
 293:include/linux/crypto.h ****                                         struct scatterlist *sg,
 294:include/linux/crypto.h ****                                         unsigned int nsg, u8 *out)
 295:include/linux/crypto.h **** {
 296:include/linux/crypto.h **** 	BUG_ON(crypto_tfm_alg_type(tfm) != CRYPTO_ALG_TYPE_DIGEST);
 297:include/linux/crypto.h **** 	tfm->crt_digest.dit_digest(tfm, sg, nsg, out);
 298:include/linux/crypto.h **** }
 299:include/linux/crypto.h **** 
 300:include/linux/crypto.h **** static inline int crypto_digest_setkey(struct crypto_tfm *tfm,
 301:include/linux/crypto.h ****                                        const u8 *key, unsigned int keylen)
 302:include/linux/crypto.h **** {
 303:include/linux/crypto.h **** 	BUG_ON(crypto_tfm_alg_type(tfm) != CRYPTO_ALG_TYPE_DIGEST);
 304:include/linux/crypto.h **** 	if (tfm->crt_digest.dit_setkey == NULL)
 305:include/linux/crypto.h **** 		return -ENOSYS;
 306:include/linux/crypto.h **** 	return tfm->crt_digest.dit_setkey(tfm, key, keylen);
 307:include/linux/crypto.h **** }
 308:include/linux/crypto.h **** 
 309:include/linux/crypto.h **** static inline int crypto_cipher_setkey(struct crypto_tfm *tfm,
 310:include/linux/crypto.h ****                                        const u8 *key, unsigned int keylen)
 311:include/linux/crypto.h **** {
 532              	.loc 5 311 0
 533 0267 8B4C2448 	movl 72(%esp),%ecx
 534 026b 8B5114   	movl 20(%ecx),%edx
 535              	.LBB31:
 536              	.LBB32:
 537              	.LBB33:
 538              	.loc 5 237 0
 539 026e 8B4228   	movl 40(%edx),%eax
 540              	.LBE33:
 541              	.LBE32:
 542              	.loc 5 236 0
 543 0271 80780801 	cmpb $1,8(%eax)
 544              	.LBE31:
 545              	.loc 5 311 0
 546 0275 8D4C240C 	leal 12(%esp),%ecx
 547              	.LBB34:
 548              	.loc 5 236 0
 549 0279 7402     	je .L121
 312:include/linux/crypto.h **** 	BUG_ON(crypto_tfm_alg_type(tfm) != CRYPTO_ALG_TYPE_CIPHER);
 550              	.loc 5 312 0
 551              	
 552 027b 0F0B     	ud2
 553              	
 554              	
 555              	.L121:
GAS LISTING  			page 44


 556 027d FF742408 	pushl 8(%esp)
 557              	.LCFI61:
 558 0281 51       	pushl %ecx
 559              	.LCFI62:
 560 0282 52       	pushl %edx
 561              	.LCFI63:
 562 0283 FF5210   	call *16(%edx)
 563 0286 83C40C   	addl $12,%esp
 564              	.LCFI64:
 565              	.LBE34:
 566              	.LBE30:
 155:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 
 156:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	crypto_cipher_setkey(wep->tfm, key, klen);
 157:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	sg.page = virt_to_page(pos);
 567              	.loc 1 157 0
 568 0289 8B0424   	movl (%esp),%eax
 569 028c 05040000 	addl $1073741828,%eax
 569      40
 570 0291 C1E80C   	shrl $12,%eax
 571 0294 C1E005   	sall $5,%eax
 572 0297 03050000 	addl mem_map,%eax
 572      0000
 573 029d 8944241C 	movl %eax,28(%esp)
 158:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	sg.offset = offset_in_page(pos);
 574              	.loc 1 158 0
 575 02a1 81E5FF0F 	andl $4095,%ebp
 575      0000
 159:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	sg.length = len + 4;
 576              	.loc 1 159 0
 577 02a7 8B442404 	movl 4(%esp),%eax
 578              	.loc 1 158 0
 579 02ab 896C2420 	movl %ebp,32(%esp)
 580              	.loc 1 159 0
 581 02af 89442428 	movl %eax,40(%esp)
 582              	.LBB35:
 313:include/linux/crypto.h **** 	return tfm->crt_cipher.cit_setkey(tfm, key, keylen);
 314:include/linux/crypto.h **** }
 315:include/linux/crypto.h **** 
 316:include/linux/crypto.h **** static inline int crypto_cipher_encrypt(struct crypto_tfm *tfm,
 317:include/linux/crypto.h ****                                         struct scatterlist *dst,
 318:include/linux/crypto.h ****                                         struct scatterlist *src,
 319:include/linux/crypto.h ****                                         unsigned int nbytes)
 320:include/linux/crypto.h **** {
 583              	.loc 5 320 0
 584 02b3 8B4C2448 	movl 72(%esp),%ecx
 585 02b7 8B5114   	movl 20(%ecx),%edx
 586              	.LBB36:
 587              	.LBB37:
 588              	.LBB38:
 589              	.loc 5 237 0
 590 02ba 8B4228   	movl 40(%edx),%eax
 591              	.LBE38:
 592              	.LBE37:
 593              	.loc 5 236 0
 594 02bd 80780801 	cmpb $1,8(%eax)
 595              	.LBE36:
 596              	.loc 5 320 0
GAS LISTING  			page 45


 597 02c1 8D4C241C 	leal 28(%esp),%ecx
 598              	.LBB39:
 599              	.loc 5 236 0
 600 02c5 7402     	je .L125
 321:include/linux/crypto.h **** 	BUG_ON(crypto_tfm_alg_type(tfm) != CRYPTO_ALG_TYPE_CIPHER);
 601              	.loc 5 321 0
 602              	
 603 02c7 0F0B     	ud2
 604              	
 605              	
 606              	.L125:
 607 02c9 FF742404 	pushl 4(%esp)
 608              	.LCFI65:
 609 02cd 51       	pushl %ecx
 610              	.LCFI66:
 611 02ce 51       	pushl %ecx
 612              	.LCFI67:
 613 02cf 52       	pushl %edx
 614              	.LCFI68:
 615 02d0 FF5214   	call *20(%edx)
 616 02d3 83C410   	addl $16,%esp
 617              	.LCFI69:
 618              	.LBE39:
 619              	.LBE35:
 160:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	crypto_cipher_encrypt(wep->tfm, &sg, &sg, len + 4);
 161:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 
 162:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	return 0;
 620              	.loc 1 162 0
 621 02d6 31D2     	xorl %edx,%edx
 622              	.L62:
 163:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** }
 623              	.loc 1 163 0
 624 02d8 83C42C   	addl $44,%esp
 625 02db 5B       	popl %ebx
 626 02dc 5E       	popl %esi
 627 02dd 5F       	popl %edi
 628 02de 89D0     	movl %edx,%eax
 629 02e0 5D       	popl %ebp
 630 02e1 C3       	ret
 631              	.LFE690:
 634              	prism2_wep_decrypt:
 635              	.LFB691:
 164:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 
 165:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** /* Perform WEP decryption on given buffer. Buffer includes whole WEP part of
 166:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c ****  * the frame: IV (4 bytes), encrypted payload (including SNAP header),
 167:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c ****  * ICV (4 bytes). len includes both IV and ICV.
 168:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c ****  *
 169:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c ****  * Returns 0 if frame was decrypted successfully and ICV was correct and -1 on
 170:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c ****  * failure. If frame is OK, IV and ICV will be removed.
 171:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c ****  */
 172:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** static int prism2_wep_decrypt(struct sk_buff *skb, int hdr_len, void *priv)
 173:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** {
 636              	.loc 1 173 0
 637 02e2 55       	pushl %ebp
 638              	.LCFI70:
 639 02e3 57       	pushl %edi
 640              	.LCFI71:
GAS LISTING  			page 46


 641 02e4 56       	pushl %esi
 642              	.LCFI72:
 643 02e5 53       	pushl %ebx
 644              	.LCFI73:
 645 02e6 83EC28   	subl $40,%esp
 646              	.LCFI74:
 174:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	struct prism2_wep_data *wep = priv;
 175:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	u32 crc, klen, plen;
 176:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	u8 key[WEP_KEY_LEN + 3];
 177:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	u8 keyidx, *pos, icv[4];
 178:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	struct scatterlist sg;
 179:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 
 180:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	if (skb->len < hdr_len + 8)
 647              	.loc 1 180 0
 648 02e9 8B442440 	movl 64(%esp),%eax
 649              	.loc 1 173 0
 650 02ed 8B6C243C 	movl 60(%esp),%ebp
 651              	.loc 1 180 0
 652 02f1 83C008   	addl $8,%eax
 181:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 		return -1;
 653              	.loc 1 181 0
 654 02f4 83CAFF   	orl $-1,%edx
 655              	.loc 1 180 0
 656 02f7 394560   	cmpl %eax,96(%ebp)
 657 02fa 0F826D01 	jb .L131
 657      0000
 182:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 
 183:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	pos = skb->data + hdr_len;
 658              	.loc 1 183 0
 659 0300 8B5C2440 	movl 64(%esp),%ebx
 660 0304 039DA800 	addl 168(%ebp),%ebx
 660      0000
 184:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	key[0] = *pos++;
 661              	.loc 1 184 0
 662 030a 8A03     	movb (%ebx),%al
 663 030c 88442418 	movb %al,24(%esp)
 664 0310 43       	incl %ebx
 185:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	key[1] = *pos++;
 665              	.loc 1 185 0
 666 0311 8A03     	movb (%ebx),%al
 667 0313 88442419 	movb %al,25(%esp)
 668 0317 43       	incl %ebx
 186:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	key[2] = *pos++;
 669              	.loc 1 186 0
 670 0318 8A03     	movb (%ebx),%al
 671 031a 8844241A 	movb %al,26(%esp)
 672 031e 43       	incl %ebx
 187:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	keyidx = *pos++ >> 6;
 673              	.loc 1 187 0
 674 031f 8A03     	movb (%ebx),%al
 675 0321 C0E806   	shrb $6,%al
 188:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	if (keyidx != wep->key_idx)
 676              	.loc 1 188 0
 677 0324 8B4C2444 	movl 68(%esp),%ecx
 678              	.loc 1 187 0
 679 0328 43       	incl %ebx
 680              	.loc 1 188 0
GAS LISTING  			page 47


 681 0329 3A4113   	cmpb 19(%ecx),%al
 682 032c 0F853B01 	jne .L131
 682      0000
 189:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 		return -1;
 190:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 
 191:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	klen = 3 + wep->key_len;
 683              	.loc 1 191 0
 684 0332 0FB64112 	movzbl 18(%ecx),%eax
 685 0336 8D5003   	leal 3(%eax),%edx
 686 0339 8D7104   	leal 4(%ecx),%esi
 687              	.LBB40:
 688              	.LBB41:
 689              	.loc 3 207 0
 690 033c 89C1     	movl %eax,%ecx
 691              	.LBE41:
 692              	.LBE40:
 693              	.loc 1 191 0
 694 033e 891424   	movl %edx,(%esp)
 695 0341 8D7C241B 	leal 27(%esp),%edi
 696              	.LBB42:
 697              	.LBB43:
 698              	.loc 3 207 0
 699 0345 C1E902   	shrl $2,%ecx
 700              	
 701 0348 F3A5     	rep
 702 034a 89C1     	movl %eax,%ecx
 703 034c 83E103   	andl $3,%ecx
 704 034f 7402     	jz 1f
 705 0351 F3A4     	rep
 706              	1:
 707              	
 708              	.LBE43:
 709              	.LBE42:
 710              	.LBB44:
 711              	.loc 5 311 0
 712 0353 8B4C2444 	movl 68(%esp),%ecx
 713 0357 8B5114   	movl 20(%ecx),%edx
 714              	.LBE44:
 192:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 
 193:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	/* Copy rest of the WEP key (the secret part) */
 194:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	memcpy(key + 3, wep->key, wep->key_len);
 195:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 
 196:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	/* Apply RC4 to data and compute CRC32 over decrypted data */
 197:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	plen = skb->len - hdr_len - 8;
 715              	.loc 1 197 0
 716 035a 8B7560   	movl 96(%ebp),%esi
 717              	.LBB45:
 718              	.LBB46:
 719              	.LBB47:
 720              	.LBB48:
 721              	.loc 5 237 0
 722 035d 8B4228   	movl 40(%edx),%eax
 723              	.LBE48:
 724              	.LBE47:
 725              	.LBE46:
 726              	.LBE45:
 727              	.loc 1 197 0
GAS LISTING  			page 48


 728 0360 2B742440 	subl 64(%esp),%esi
 729              	.LBB49:
 730              	.LBB50:
 731              	.loc 5 236 0
 732 0364 80780801 	cmpb $1,8(%eax)
 733              	.LBE50:
 734              	.LBE49:
 735              	.loc 1 197 0
 736 0368 8D7EF8   	leal -8(%esi),%edi
 737              	.LBB51:
 738              	.loc 5 311 0
 739 036b 8D4C2418 	leal 24(%esp),%ecx
 740              	.LBB52:
 741              	.loc 5 236 0
 742 036f 7402     	je .L159
 743              	.loc 5 312 0
 744              	
 745 0371 0F0B     	ud2
 746              	
 747              	
 748              	.L159:
 749 0373 FF3424   	pushl (%esp)
 750              	.LCFI75:
 751 0376 51       	pushl %ecx
 752              	.LCFI76:
 753 0377 52       	pushl %edx
 754              	.LCFI77:
 755 0378 FF5210   	call *16(%edx)
 756              	.LBE52:
 757              	.LBE51:
 198:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 
 199:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	crypto_cipher_setkey(wep->tfm, key, klen);
 200:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	sg.page = virt_to_page(pos);
 758              	.loc 1 200 0
 759 037b 8D830000 	leal 1073741824(%ebx),%eax
 759      0040
 760 0381 C1E80C   	shrl $12,%eax
 761 0384 C1E005   	sall $5,%eax
 762              	.LBB53:
 763              	.LBB54:
 764              	.loc 5 312 0
 765 0387 83C40C   	addl $12,%esp
 766              	.LCFI78:
 767              	.LBE54:
 768              	.LBE53:
 769              	.loc 1 200 0
 770 038a 03050000 	addl mem_map,%eax
 770      0000
 771 0390 89442408 	movl %eax,8(%esp)
 201:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	sg.offset = offset_in_page(pos);
 772              	.loc 1 201 0
 773 0394 89D8     	movl %ebx,%eax
 774 0396 25FF0F00 	andl $4095,%eax
 774      00
 202:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	sg.length = plen + 4;
 775              	.loc 1 202 0
 776 039b 8D4EFC   	leal -4(%esi),%ecx
GAS LISTING  			page 49


 777              	.loc 1 201 0
 778 039e 8944240C 	movl %eax,12(%esp)
 779              	.loc 1 202 0
 780 03a2 894C2414 	movl %ecx,20(%esp)
 781              	.LBB55:
 322:include/linux/crypto.h **** 	return tfm->crt_cipher.cit_encrypt(tfm, dst, src, nbytes);
 323:include/linux/crypto.h **** }                                        
 324:include/linux/crypto.h **** 
 325:include/linux/crypto.h **** static inline int crypto_cipher_encrypt_iv(struct crypto_tfm *tfm,
 326:include/linux/crypto.h ****                                            struct scatterlist *dst,
 327:include/linux/crypto.h ****                                            struct scatterlist *src,
 328:include/linux/crypto.h ****                                            unsigned int nbytes, u8 *iv)
 329:include/linux/crypto.h **** {
 330:include/linux/crypto.h **** 	BUG_ON(crypto_tfm_alg_type(tfm) != CRYPTO_ALG_TYPE_CIPHER);
 331:include/linux/crypto.h **** 	BUG_ON(tfm->crt_cipher.cit_mode == CRYPTO_TFM_MODE_ECB);
 332:include/linux/crypto.h **** 	return tfm->crt_cipher.cit_encrypt_iv(tfm, dst, src, nbytes, iv);
 333:include/linux/crypto.h **** }                                        
 334:include/linux/crypto.h **** 
 335:include/linux/crypto.h **** static inline int crypto_cipher_decrypt(struct crypto_tfm *tfm,
 336:include/linux/crypto.h ****                                         struct scatterlist *dst,
 337:include/linux/crypto.h ****                                         struct scatterlist *src,
 338:include/linux/crypto.h ****                                         unsigned int nbytes)
 339:include/linux/crypto.h **** {
 782              	.loc 5 339 0
 783 03a6 8B442444 	movl 68(%esp),%eax
 784 03aa 8B5014   	movl 20(%eax),%edx
 785              	.LBB56:
 786              	.LBB57:
 787              	.LBB58:
 788              	.loc 5 237 0
 789 03ad 8B4228   	movl 40(%edx),%eax
 790              	.LBE58:
 791              	.LBE57:
 792              	.loc 5 236 0
 793 03b0 80780801 	cmpb $1,8(%eax)
 794              	.LBE56:
 795              	.loc 5 339 0
 796 03b4 8D742408 	leal 8(%esp),%esi
 797              	.LBB59:
 798              	.loc 5 236 0
 799 03b8 7402     	je .L163
 340:include/linux/crypto.h **** 	BUG_ON(crypto_tfm_alg_type(tfm) != CRYPTO_ALG_TYPE_CIPHER);
 800              	.loc 5 340 0
 801              	
 802 03ba 0F0B     	ud2
 803              	
 804              	
 805              	.L163:
 806 03bc 51       	pushl %ecx
 807              	.LCFI79:
 808 03bd 56       	pushl %esi
 809              	.LCFI80:
 810 03be 56       	pushl %esi
 811              	.LCFI81:
 812 03bf 52       	pushl %edx
 813              	.LCFI82:
 814 03c0 FF521C   	call *28(%edx)
GAS LISTING  			page 50


 815 03c3 83C410   	addl $16,%esp
 816              	.LCFI83:
 817              	.LBE59:
 818              	.LBE55:
 203:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	crypto_cipher_decrypt(wep->tfm, &sg, &sg, plen + 4);
 204:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 
 205:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	crc = ~crc32_le(~0, pos, plen);
 819              	.loc 1 205 0
 820 03c6 57       	pushl %edi
 821              	.LCFI84:
 822 03c7 53       	pushl %ebx
 823              	.LCFI85:
 824 03c8 6AFF     	pushl $-1
 825              	.LCFI86:
 826 03ca E8FCFFFF 	call crc32_le
 826      FF
 827 03cf F7D0     	notl %eax
 206:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	icv[0] = crc;
 828              	.loc 1 206 0
 829 03d1 88442410 	movb %al,16(%esp)
 207:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	icv[1] = crc >> 8;
 830              	.loc 1 207 0
 831 03d5 C1E808   	shrl $8,%eax
 832 03d8 88442411 	movb %al,17(%esp)
 208:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	icv[2] = crc >> 16;
 833              	.loc 1 208 0
 834 03dc C1E808   	shrl $8,%eax
 835 03df 88442412 	movb %al,18(%esp)
 209:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	icv[3] = crc >> 24;
 836              	.loc 1 209 0
 837 03e3 C1E808   	shrl $8,%eax
 838 03e6 88442413 	movb %al,19(%esp)
 210:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	if (memcmp(icv, pos + plen, 4) != 0) {
 839              	.loc 1 210 0
 840 03ea 6A04     	pushl $4
 841              	.LCFI87:
 842 03ec 8D043B   	leal (%ebx,%edi),%eax
 843 03ef 50       	pushl %eax
 844              	.LCFI88:
 845 03f0 8D442418 	leal 24(%esp),%eax
 846 03f4 50       	pushl %eax
 847              	.LCFI89:
 848              	.LCFI90:
 849 03f5 E8FCFFFF 	call memcmp
 849      FF
 850 03fa 83C418   	addl $24,%esp
 851              	.LCFI91:
 852 03fd 85C0     	testl %eax,%eax
 211:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 		/* ICV mismatch - drop frame */
 212:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 		return -2;
 853              	.loc 1 212 0
 854 03ff BAFEFFFF 	movl $-2,%edx
 854      FF
 855              	.loc 1 210 0
 856 0404 7567     	jne .L131
 213:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	}
 214:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 
GAS LISTING  			page 51


 215:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	/* Remove IV and ICV */
 216:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	memmove(skb->data + 4, skb->data, hdr_len);
 857              	.loc 1 216 0
 858 0406 FF742440 	pushl 64(%esp)
 859              	.LCFI92:
 860 040a FFB5A800 	pushl 168(%ebp)
 860      0000
 861              	.LCFI93:
 862 0410 8B85A800 	movl 168(%ebp),%eax
 862      0000
 863 0416 83C004   	addl $4,%eax
 864 0419 50       	pushl %eax
 865              	.LCFI94:
 866 041a E8FCFFFF 	call memmove
 866      FF
 867              	.LBB60:
 868              	.LBB61:
 869              	.loc 4 811 0
 870 041f 8B4560   	movl 96(%ebp),%eax
 871              	.LBE61:
 872              	.LBE60:
 873              	.loc 4 810 0
 874 0422 83C40C   	addl $12,%esp
 875              	.LCFI95:
 876              	.LBB62:
 877              	.LBB63:
 878              	.loc 4 811 0
 879 0425 83F803   	cmpl $3,%eax
 880 0428 7614     	jbe .L173
 881              	.LBB64:
 882              	.LBB65:
 883              	.loc 4 794 0
 884 042a 83E804   	subl $4,%eax
 885              	.loc 4 795 0
 886 042d 3B4564   	cmpl 100(%ebp),%eax
 887              	.loc 4 794 0
 888 0430 894560   	movl %eax,96(%ebp)
 889              	.loc 4 795 0
 890 0433 7302     	jae .L170
 891              	
 892 0435 0F0B     	ud2
 893              	
 894              	
 895              	.L170:
 896 0437 8385A800 	addl $4,168(%ebp)
 896      000004
 897              	.L173:
 898              	.LBE65:
 899              	.LBE64:
 900              	.LBE63:
 901              	.LBE62:
 902              	.LBB66:
 858:include/linux/skbuff.h **** 	return skb_is_nonlinear(skb) ? 0 : skb->end - skb->tail;
 859:include/linux/skbuff.h **** }
 860:include/linux/skbuff.h **** 
 861:include/linux/skbuff.h **** /**
 862:include/linux/skbuff.h ****  *	skb_reserve - adjust headroom
GAS LISTING  			page 52


 863:include/linux/skbuff.h ****  *	@skb: buffer to alter
 864:include/linux/skbuff.h ****  *	@len: bytes to move
 865:include/linux/skbuff.h ****  *
 866:include/linux/skbuff.h ****  *	Increase the headroom of an empty &sk_buff by reducing the tail
 867:include/linux/skbuff.h ****  *	room. This is only allowed for an empty buffer.
 868:include/linux/skbuff.h ****  */
 869:include/linux/skbuff.h **** static inline void skb_reserve(struct sk_buff *skb, unsigned int len)
 870:include/linux/skbuff.h **** {
 871:include/linux/skbuff.h **** 	skb->data += len;
 872:include/linux/skbuff.h **** 	skb->tail += len;
 873:include/linux/skbuff.h **** }
 874:include/linux/skbuff.h **** 
 875:include/linux/skbuff.h **** /*
 876:include/linux/skbuff.h ****  * CPUs often take a performance hit when accessing unaligned memory
 877:include/linux/skbuff.h ****  * locations. The actual performance hit varies, it can be small if the
 878:include/linux/skbuff.h ****  * hardware handles it or large if we have to take an exception and fix it
 879:include/linux/skbuff.h ****  * in software.
 880:include/linux/skbuff.h ****  *
 881:include/linux/skbuff.h ****  * Since an ethernet header is 14 bytes network drivers often end up with
 882:include/linux/skbuff.h ****  * the IP header at an unaligned offset. The IP header can be aligned by
 883:include/linux/skbuff.h ****  * shifting the start of the packet by 2 bytes. Drivers should do this
 884:include/linux/skbuff.h ****  * with:
 885:include/linux/skbuff.h ****  *
 886:include/linux/skbuff.h ****  * skb_reserve(NET_IP_ALIGN);
 887:include/linux/skbuff.h ****  *
 888:include/linux/skbuff.h ****  * The downside to this alignment of the IP header is that the DMA is now
 889:include/linux/skbuff.h ****  * unaligned. On some architectures the cost of an unaligned DMA is high
 890:include/linux/skbuff.h ****  * and this cost outweighs the gains made by aligning the IP header.
 891:include/linux/skbuff.h ****  * 
 892:include/linux/skbuff.h ****  * Since this trade off varies between architectures, we allow NET_IP_ALIGN
 893:include/linux/skbuff.h ****  * to be overridden.
 894:include/linux/skbuff.h ****  */
 895:include/linux/skbuff.h **** #ifndef NET_IP_ALIGN
 896:include/linux/skbuff.h **** #define NET_IP_ALIGN	2
 897:include/linux/skbuff.h **** #endif
 898:include/linux/skbuff.h **** 
 899:include/linux/skbuff.h **** extern int ___pskb_trim(struct sk_buff *skb, unsigned int len, int realloc);
 900:include/linux/skbuff.h **** 
 901:include/linux/skbuff.h **** static inline void __skb_trim(struct sk_buff *skb, unsigned int len)
 902:include/linux/skbuff.h **** {
 903:include/linux/skbuff.h **** 	if (!skb->data_len) {
 904:include/linux/skbuff.h **** 		skb->len  = len;
 905:include/linux/skbuff.h **** 		skb->tail = skb->data + len;
 906:include/linux/skbuff.h **** 	} else
 907:include/linux/skbuff.h **** 		___pskb_trim(skb, len, 0);
 908:include/linux/skbuff.h **** }
 909:include/linux/skbuff.h **** 
 910:include/linux/skbuff.h **** /**
 911:include/linux/skbuff.h ****  *	skb_trim - remove end from a buffer
 912:include/linux/skbuff.h ****  *	@skb: buffer to alter
 913:include/linux/skbuff.h ****  *	@len: new length
 914:include/linux/skbuff.h ****  *
 915:include/linux/skbuff.h ****  *	Cut the length of a buffer down by removing data from the tail. If
 916:include/linux/skbuff.h ****  *	the buffer is already under the length specified it is not modified.
 917:include/linux/skbuff.h ****  */
 918:include/linux/skbuff.h **** static inline void skb_trim(struct sk_buff *skb, unsigned int len)
 919:include/linux/skbuff.h **** {
GAS LISTING  			page 53


 903              	.loc 4 919 0
 904 043e 8B4560   	movl 96(%ebp),%eax
 905 0441 8D50FC   	leal -4(%eax),%edx
 906              	.LBB67:
 920:include/linux/skbuff.h **** 	if (skb->len > len)
 907              	.loc 4 920 0
 908 0444 39D0     	cmpl %edx,%eax
 909 0446 7623     	jbe .L178
 910              	.LBB68:
 911              	.LBB69:
 912              	.loc 4 903 0
 913 0448 837D6400 	cmpl $0,100(%ebp)
 914 044c 7511     	jne .L175
 915              	.loc 4 904 0
 916 044e 895560   	movl %edx,96(%ebp)
 917              	.loc 4 905 0
 918 0451 0395A800 	addl 168(%ebp),%edx
 918      0000
 919 0457 8995AC00 	movl %edx,172(%ebp)
 919      0000
 920 045d EB0C     	jmp .L178
 921              	.L175:
 922              	.loc 4 907 0
 923 045f 6A00     	pushl $0
 924              	.LCFI96:
 925 0461 52       	pushl %edx
 926              	.LCFI97:
 927 0462 55       	pushl %ebp
 928              	.LCFI98:
 929 0463 E8FCFFFF 	call ___pskb_trim
 929      FF
 930 0468 83C40C   	addl $12,%esp
 931              	.LCFI99:
 932              	.L178:
 933              	.LBE69:
 934              	.LBE68:
 935              	.LBE67:
 936              	.LBE66:
 217:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	skb_pull(skb, 4);
 218:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	skb_trim(skb, skb->len - 4);
 219:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 
 220:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	return 0;
 937              	.loc 1 220 0
 938 046b 31D2     	xorl %edx,%edx
 939              	.L131:
 221:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** }
 940              	.loc 1 221 0
 941 046d 83C428   	addl $40,%esp
 942 0470 5B       	popl %ebx
 943 0471 5E       	popl %esi
 944 0472 5F       	popl %edi
 945 0473 89D0     	movl %edx,%eax
 946 0475 5D       	popl %ebp
 947 0476 C3       	ret
 948              	.LFE691:
 951              	prism2_wep_set_key:
 952              	.LFB692:
GAS LISTING  			page 54


 222:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 
 223:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** static int prism2_wep_set_key(void *key, int len, u8 * seq, void *priv)
 224:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** {
 953              	.loc 1 224 0
 954 0477 57       	pushl %edi
 955              	.LCFI100:
 956 0478 56       	pushl %esi
 957              	.LCFI101:
 958 0479 53       	pushl %ebx
 959              	.LCFI102:
 960              	.loc 1 224 0
 961 047a 8B542414 	movl 20(%esp),%edx
 225:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	struct prism2_wep_data *wep = priv;
 226:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 
 227:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	if (len < 0 || len > WEP_KEY_LEN)
 228:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 		return -1;
 962              	.loc 1 228 0
 963 047e 83C8FF   	orl $-1,%eax
 964              	.loc 1 227 0
 965 0481 83FA0D   	cmpl $13,%edx
 966              	.loc 1 224 0
 967 0484 8B742410 	movl 16(%esp),%esi
 968 0488 8B5C241C 	movl 28(%esp),%ebx
 969              	.loc 1 227 0
 970 048c 7718     	ja .L179
 971              	.LBB70:
 972              	.LBB71:
 973              	.loc 3 207 0
 974 048e 89D1     	movl %edx,%ecx
 975 0490 8D7B04   	leal 4(%ebx),%edi
 976 0493 C1E902   	shrl $2,%ecx
 977              	
 978 0496 F3A5     	rep
 979 0498 89D1     	movl %edx,%ecx
 980 049a 83E103   	andl $3,%ecx
 981 049d 7402     	jz 1f
 982 049f F3A4     	rep
 983              	1:
 984              	
 985              	.LBE71:
 986              	.LBE70:
 229:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 
 230:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	memcpy(wep->key, key, len);
 231:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	wep->key_len = len;
 232:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 
 233:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	return 0;
 987              	.loc 1 233 0
 988 04a1 31C0     	xorl %eax,%eax
 989              	.loc 1 231 0
 990 04a3 885312   	movb %dl,18(%ebx)
 991              	.L179:
 234:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** }
 992              	.loc 1 234 0
 993 04a6 5B       	popl %ebx
 994 04a7 5E       	popl %esi
 995 04a8 5F       	popl %edi
 996 04a9 C3       	ret
GAS LISTING  			page 55


 997              	.LFE692:
 1000              	prism2_wep_get_key:
 1001              	.LFB693:
 235:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 
 236:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** static int prism2_wep_get_key(void *key, int len, u8 * seq, void *priv)
 237:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** {
 1002              	.loc 1 237 0
 1003 04aa 57       	pushl %edi
 1004              	.LCFI103:
 1005 04ab 56       	pushl %esi
 1006              	.LCFI104:
 1007              	.loc 1 237 0
 1008 04ac 8B442418 	movl 24(%esp),%eax
 238:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	struct prism2_wep_data *wep = priv;
 239:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 
 240:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	if (len < wep->key_len)
 1009              	.loc 1 240 0
 1010 04b0 0FB65012 	movzbl 18(%eax),%edx
 241:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 		return -1;
 1011              	.loc 1 241 0
 1012 04b4 83C9FF   	orl $-1,%ecx
 1013              	.loc 1 240 0
 1014 04b7 39542410 	cmpl %edx,16(%esp)
 1015              	.loc 1 237 0
 1016 04bb 8B7C240C 	movl 12(%esp),%edi
 1017              	.loc 1 240 0
 1018 04bf 7C17     	jl .L206
 1019              	.LBB72:
 1020              	.LBB73:
 1021              	.loc 3 207 0
 1022 04c1 89D1     	movl %edx,%ecx
 1023 04c3 8D7004   	leal 4(%eax),%esi
 1024 04c6 C1E902   	shrl $2,%ecx
 1025              	
 1026 04c9 F3A5     	rep
 1027 04cb 89D1     	movl %edx,%ecx
 1028 04cd 83E103   	andl $3,%ecx
 1029 04d0 7402     	jz 1f
 1030 04d2 F3A4     	rep
 1031              	1:
 1032              	
 1033              	.LBE73:
 1034              	.LBE72:
 242:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 
 243:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	memcpy(key, wep->key, wep->key_len);
 244:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 
 245:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	return wep->key_len;
 1035              	.loc 1 245 0
 1036 04d4 0FB64812 	movzbl 18(%eax),%ecx
 1037              	.L206:
 246:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** }
 1038              	.loc 1 246 0
 1039 04d8 5E       	popl %esi
 1040 04d9 89C8     	movl %ecx,%eax
 1041 04db 5F       	popl %edi
 1042 04dc C3       	ret
 1043              	.LFE693:
GAS LISTING  			page 56


 1045              	.section .rodata.str1.1
 1046              	.LC2:
 1047 0041 6B65795B 	.string "key[%d] alg=WEP len=%d\n"
 1047      25645D20 
 1047      616C673D 
 1047      57455020 
 1047      6C656E3D 
 1048              	.text
 1050              	prism2_wep_print_stats:
 1051              	.LFB694:
 247:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 
 248:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** static char *prism2_wep_print_stats(char *p, void *priv)
 249:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** {
 1052              	.loc 1 249 0
 1053 04dd 53       	pushl %ebx
 1054              	.LCFI105:
 1055              	.loc 1 249 0
 1056 04de 8B54240C 	movl 12(%esp),%edx
 250:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	struct prism2_wep_data *wep = priv;
 251:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	p += sprintf(p, "key[%d] alg=WEP len=%d\n", wep->key_idx, wep->key_len);
 1057              	.loc 1 251 0
 1058 04e2 0FB64212 	movzbl 18(%edx),%eax
 1059              	.loc 1 249 0
 1060 04e6 8B5C2408 	movl 8(%esp),%ebx
 1061              	.loc 1 251 0
 1062 04ea 50       	pushl %eax
 1063              	.LCFI106:
 1064 04eb 0FB64213 	movzbl 19(%edx),%eax
 1065 04ef 50       	pushl %eax
 1066              	.LCFI107:
 1067 04f0 68410000 	pushl $.LC2
 1067      00
 1068              	.LCFI108:
 1069 04f5 53       	pushl %ebx
 1070              	.LCFI109:
 1071 04f6 E8FCFFFF 	call sprintf
 1071      FF
 1072 04fb 01C3     	addl %eax,%ebx
 252:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	return p;
 1073              	.loc 1 252 0
 1074 04fd 83C410   	addl $16,%esp
 1075              	.LCFI110:
 253:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** }
 1076              	.loc 1 253 0
 1077 0500 89D8     	movl %ebx,%eax
 1078 0502 5B       	popl %ebx
 1079 0503 C3       	ret
 1080              	.LFE694:
 1082              	.section .rodata.str1.1
 1083              	.LC3:
 1084 0059 57455000 	.string "WEP"
 1085              	.data
 1086              	.align 32
 1089              	ieee80211_crypt_wep:
 1090 0000 59000000 	.long .LC3
 1091 0004 00000000 	.zero 8
 1091      00000000 
GAS LISTING  			page 57


 1092 000c 00000000 	.long prism2_wep_init
 1093 0010 79000000 	.long prism2_wep_deinit
 1094 0014 9A000000 	.long prism2_wep_build_iv
 1095 0018 5D010000 	.long prism2_wep_encrypt
 1096 001c E2020000 	.long prism2_wep_decrypt
 1097 0020 00000000 	.long 0
 1098 0024 00000000 	.long 0
 1099 0028 77040000 	.long prism2_wep_set_key
 1100 002c AA040000 	.long prism2_wep_get_key
 1101 0030 DD040000 	.long prism2_wep_print_stats
 1102 0034 00000000 	.zero 8
 1102      00000000 
 1103 003c 04000000 	.long 4
 1104 0040 04000000 	.long 4
 1105 0044 00000000 	.zero 8
 1105      00000000 
 1106 004c 00000000 	.long __this_module
 1107              	.section .init.text,"ax",@progbits
 1109              	ieee80211_crypto_wep_init:
 1110              	.LFB695:
 254:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 
 255:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** static struct ieee80211_crypto_ops ieee80211_crypt_wep = {
 256:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	.name = "WEP",
 257:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	.init = prism2_wep_init,
 258:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	.deinit = prism2_wep_deinit,
 259:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	.build_iv = prism2_wep_build_iv,
 260:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	.encrypt_mpdu = prism2_wep_encrypt,
 261:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	.decrypt_mpdu = prism2_wep_decrypt,
 262:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	.encrypt_msdu = NULL,
 263:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	.decrypt_msdu = NULL,
 264:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	.set_key = prism2_wep_set_key,
 265:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	.get_key = prism2_wep_get_key,
 266:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	.print_stats = prism2_wep_print_stats,
 267:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	.extra_mpdu_prefix_len = 4,	/* IV */
 268:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	.extra_mpdu_postfix_len = 4,	/* ICV */
 269:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	.owner = THIS_MODULE,
 270:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** };
 271:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 
 272:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** static int __init ieee80211_crypto_wep_init(void)
 273:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** {
 1111              	.loc 1 273 0
 274:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	return ieee80211_register_crypto_ops(&ieee80211_crypt_wep);
 1112              	.loc 1 274 0
 1113 0000 68000000 	pushl $ieee80211_crypt_wep
 1113      00
 1114              	.LCFI111:
 1115 0005 E8FCFFFF 	call ieee80211_register_crypto_ops
 1115      FF
 1116 000a 5A       	popl %edx
 1117              	.LCFI112:
 275:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** }
 1118              	.loc 1 275 0
 1119 000b C3       	ret
 1120              	.LFE695:
 1122              	.section .exit.text,"ax",@progbits
 1124              	ieee80211_crypto_wep_exit:
 1125              	.LFB696:
GAS LISTING  			page 58


 276:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 
 277:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** static void __exit ieee80211_crypto_wep_exit(void)
 278:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** {
 1126              	.loc 1 278 0
 279:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_crypt_wep.c **** 	ieee80211_unregister_crypto_ops(&ieee80211_crypt_wep);
 1127              	.loc 1 279 0
 1128 0000 68000000 	pushl $ieee80211_crypt_wep
 1128      00
 1129              	.LCFI113:
 1130 0005 E8FCFFFF 	call ieee80211_unregister_crypto_ops
 1130      FF
 1131 000a 59       	popl %ecx
 1132              	.LCFI114:
 1133 000b C3       	ret
 1134              	.LFE696:
 1136              	.globl init_module
 1137              	.set init_module,ieee80211_crypto_wep_init
 1138              	.globl cleanup_module
 1139              	.set cleanup_module,ieee80211_crypto_wep_exit
 1985              	.Letext0:
 26566              	.ident "GCC: (GNU) 3.4.5 20050809 (prerelease) (Ubuntu 3.4.4-6ubuntu8.1)"
GAS LISTING  			page 59


DEFINED SYMBOLS
                            *ABS*:0000000000000000 ieee80211_crypt_wep.c
 {entrada estndar}:13     .modinfo:0000000000000000 __mod_author26
 {entrada estndar}:17     .modinfo:0000000000000015 __mod_description27
 {entrada estndar}:21     .modinfo:0000000000000034 __mod_license28
 {entrada estndar}:30     .text:0000000000000000 prism2_wep_init
 {entrada estndar}:166    .text:0000000000000079 prism2_wep_deinit
 {entrada estndar}:194    .text:000000000000009a prism2_wep_build_iv
 {entrada estndar}:339    .text:000000000000015d prism2_wep_encrypt
 {entrada estndar}:634    .text:00000000000002e2 prism2_wep_decrypt
 {entrada estndar}:951    .text:0000000000000477 prism2_wep_set_key
 {entrada estndar}:1000   .text:00000000000004aa prism2_wep_get_key
 {entrada estndar}:1050   .text:00000000000004dd prism2_wep_print_stats
 {entrada estndar}:1089   .data:0000000000000000 ieee80211_crypt_wep
 {entrada estndar}:1109   .init.text:0000000000000000 ieee80211_crypto_wep_init
 {entrada estndar}:1124   .exit.text:0000000000000000 ieee80211_crypto_wep_exit
 {entrada estndar}:1109   .init.text:0000000000000000 init_module
 {entrada estndar}:1124   .exit.text:0000000000000000 cleanup_module

UNDEFINED SYMBOLS
malloc_sizes
kmem_cache_alloc
crypto_alloc_tfm
get_random_bytes
printk
crypto_free_tfm
kfree
skb_under_panic
memmove
crc32_le
skb_over_panic
mem_map
memcmp
___pskb_trim
sprintf
__this_module
ieee80211_register_crypto_ops
ieee80211_unregister_crypto_ops
