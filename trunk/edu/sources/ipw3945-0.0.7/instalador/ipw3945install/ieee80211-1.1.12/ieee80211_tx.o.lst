GAS LISTING  			page 1


   1              	.file "ieee80211_tx.c"
   9              	.Ltext0:
  10              	.data
  13              	P802_1H_OUI:
  14 0000 00       	.byte 0
  15 0001 00       	.byte 0
  16 0002 F8       	.byte -8
  17              	.local RFC1042_OUI
  18              	.comm RFC1042_OUI,3,1
  19              	.text
  21              	ieee80211_copy_snap:
  22              	.LFB922:
  23              	.file 1 "/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c"
   1:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** /******************************************************************************
   2:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 
   3:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c ****   Copyright(c) 2003 - 2005 Intel Corporation. All rights reserved.
   4:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 
   5:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c ****   This program is free software; you can redistribute it and/or modify it
   6:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c ****   under the terms of version 2 of the GNU General Public License as
   7:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c ****   published by the Free Software Foundation.
   8:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 
   9:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c ****   This program is distributed in the hope that it will be useful, but WITHOUT
  10:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c ****   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c ****   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  12:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c ****   more details.
  13:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 
  14:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c ****   You should have received a copy of the GNU General Public License along with
  15:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c ****   this program; if not, write to the Free Software Foundation, Inc., 59
  16:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c ****   Temple Place - Suite 330, Boston, MA  02111-1307, USA.
  17:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 
  18:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c ****   The full GNU General Public License is included in this distribution in the
  19:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c ****   file called LICENSE.
  20:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 
  21:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c ****   Contact Information:
  22:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c ****   James P. Ketrenos <ipw2100-admin@linux.intel.com>
  23:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c ****   Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497
  24:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 
  25:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** ******************************************************************************/
  26:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** #include <linux/compiler.h>
  27:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** #include <linux/config.h>
  28:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** #include <linux/errno.h>
  29:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** #include <linux/if_arp.h>
  30:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** #include <linux/in6.h>
  31:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** #include <linux/in.h>
  32:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** #include <linux/ip.h>
  33:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** #include <linux/kernel.h>
  34:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** #include <linux/module.h>
  35:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** #include <linux/netdevice.h>
  36:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** #include <linux/proc_fs.h>
  37:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** #include <linux/skbuff.h>
  38:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** #include <linux/slab.h>
  39:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** #include <linux/tcp.h>
  40:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** #include <linux/types.h>
  41:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** #include <linux/wireless.h>
  42:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** #include <linux/etherdevice.h>
  43:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** #include <asm/uaccess.h>
  44:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 
GAS LISTING  			page 2


  45:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** #include <net/ieee80211.h>
  46:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 
  47:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** /* Fix for older kernels, since we use NETDEV_TX_BUSY */
  48:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** #ifndef NETDEV_TX_BUSY
  49:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** #define NETDEV_TX_BUSY 1
  50:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** #endif
  51:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 
  52:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 
  53:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** /*
  54:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 
  55:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 802.11 Data Frame
  56:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 
  57:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c ****       ,-------------------------------------------------------------------.
  58:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** Bytes |  2   |  2   |    6    |    6    |    6    |  2   | 0..2312 |   4  |
  59:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c ****       |------|------|---------|---------|---------|------|---------|------|
  60:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** Desc. | ctrl | dura |  DA/RA  |   TA    |    SA   | Sequ |  Frame  |  fcs |
  61:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c ****       |      | tion | (BSSID) |         |         | ence |  data   |      |
  62:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c ****       `--------------------------------------------------|         |------'
  63:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** Total: 28 non-data bytes                                 `----.----'
  64:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c ****                                                               |
  65:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c ****        .- 'Frame data' expands, if WEP enabled, to <----------'
  66:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c ****        |
  67:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c ****        V
  68:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c ****       ,-----------------------.
  69:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** Bytes |  4  |   0-2296  |  4  |
  70:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c ****       |-----|-----------|-----|
  71:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** Desc. | IV  | Encrypted | ICV |
  72:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c ****       |     | Packet    |     |
  73:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c ****       `-----|           |-----'
  74:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c ****             `-----.-----'
  75:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c ****                   |
  76:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c ****        .- 'Encrypted Packet' expands to
  77:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c ****        |
  78:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c ****        V
  79:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c ****       ,---------------------------------------------------.
  80:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** Bytes |  1   |  1   |    1    |    3     |  2   |  0-2304 |
  81:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c ****       |------|------|---------|----------|------|---------|
  82:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** Desc. | SNAP | SNAP | Control |Eth Tunnel| Type | IP      |
  83:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c ****       | DSAP | SSAP |         |          |      | Packet  |
  84:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c ****       | 0xAA | 0xAA |0x03 (UI)|0x00-00-F8|      |         |
  85:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c ****       `----------------------------------------------------
  86:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** Total: 8 non-data bytes
  87:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 
  88:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 802.3 Ethernet Data Frame
  89:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 
  90:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c ****       ,-----------------------------------------.
  91:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** Bytes |   6   |   6   |  2   |  Variable |   4  |
  92:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c ****       |-------|-------|------|-----------|------|
  93:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** Desc. | Dest. | Source| Type | IP Packet |  fcs |
  94:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c ****       |  MAC  |  MAC  |      |           |      |
  95:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c ****       `-----------------------------------------'
  96:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** Total: 18 non-data bytes
  97:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 
  98:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** In the event that fragmentation is required, the incoming payload is split into
  99:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** N parts of size ieee->fts.  The first fragment contains the SNAP header and the
 100:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** remaining packets are just data.
 101:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 
GAS LISTING  			page 3


 102:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** If encryption is enabled, each fragment payload size is reduced by enough space
 103:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** to add the prefix and postfix (IV and ICV totalling 8 bytes in the case of WEP)
 104:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** So if you have 1500 bytes of payload with ieee->fts set to 500 without
 105:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** encryption it will take 3 frames.  With WEP it will take 4 frames as the
 106:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** payload of each frame is reduced to 492 bytes.
 107:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 
 108:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** * SKB visualization
 109:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** *
 110:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** *  ,- skb->data
 111:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** * |
 112:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** * |    ETHERNET HEADER        ,-<-- PAYLOAD
 113:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** * |                           |     14 bytes from skb->data
 114:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** * |  2 bytes for Type --> ,T. |     (sizeof ethhdr)
 115:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** * |                       | | |
 116:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** * |,-Dest.--. ,--Src.---. | | |
 117:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** * |  6 bytes| | 6 bytes | | | |
 118:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** * v         | |         | | | |
 119:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** * 0         | v       1 | v | v           2
 120:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** * 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5
 121:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** *     ^     | ^         | ^ |
 122:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** *     |     | |         | | |
 123:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** *     |     | |         | `T' <---- 2 bytes for Type
 124:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** *     |     | |         |
 125:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** *     |     | '---SNAP--' <-------- 6 bytes for SNAP
 126:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** *     |     |
 127:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** *     `-IV--' <-------------------- 4 bytes for IV (WEP)
 128:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** *
 129:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** *      SNAP HEADER
 130:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** *
 131:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** */
 132:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 
 133:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** static u8 P802_1H_OUI[P80211_OUI_LEN] = { 0x00, 0x00, 0xf8 };
 134:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** static u8 RFC1042_OUI[P80211_OUI_LEN] = { 0x00, 0x00, 0x00 };
 135:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 
 136:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** static int ieee80211_copy_snap(u8 * data, u16 h_proto)
 137:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** {
  24              	.loc 1 137 0
  25 0000 53       	pushl %ebx
  26              	.LCFI0:
  27              	.loc 1 137 0
  28 0001 8B5C240C 	movl 12(%esp),%ebx
  29 0005 8B4C2408 	movl 8(%esp),%ecx
 138:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	struct ieee80211_snap_hdr *snap;
 139:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	u8 *oui;
 140:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 
 141:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	snap = (struct ieee80211_snap_hdr *)data;
 142:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	snap->dsap = 0xaa;
 143:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	snap->ssap = 0xaa;
 144:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	snap->ctrl = 0x03;
 145:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 
 146:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	if (h_proto == 0x8137 || h_proto == 0x80f3)
  30              	.loc 1 146 0
  31 0009 6681FB37 	cmpw $-32457,%bx
  31      81
  32              	.loc 1 142 0
  33 000e C601AA   	movb $-86,(%ecx)
  34              	.loc 1 143 0
GAS LISTING  			page 4


  35 0011 C64101AA 	movb $-86,1(%ecx)
  36              	.loc 1 144 0
  37 0015 C6410203 	movb $3,2(%ecx)
  38              	.loc 1 146 0
  39 0019 740C     	je .L3
  40 001b 6681FBF3 	cmpw $-32525,%bx
  40      80
 147:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		oui = P802_1H_OUI;
 148:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	else
 149:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		oui = RFC1042_OUI;
  41              	.loc 1 149 0
  42 0020 BA000000 	movl $RFC1042_OUI,%edx
  42      00
  43              	.loc 1 146 0
  44 0025 7505     	jne .L4
  45              	.L3:
  46              	.loc 1 147 0
  47 0027 BA000000 	movl $P802_1H_OUI,%edx
  47      00
  48              	.L4:
 150:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	snap->oui[0] = oui[0];
  49              	.loc 1 150 0
  50 002c 8A02     	movb (%edx),%al
  51 002e 884103   	movb %al,3(%ecx)
 151:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	snap->oui[1] = oui[1];
  52              	.loc 1 151 0
  53 0031 8A4201   	movb 1(%edx),%al
  54 0034 884104   	movb %al,4(%ecx)
 152:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	snap->oui[2] = oui[2];
  55              	.loc 1 152 0
  56 0037 8A4202   	movb 2(%edx),%al
  57 003a 884105   	movb %al,5(%ecx)
 153:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 
 154:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	*(u16 *) (data + SNAP_SIZE) = htons(h_proto);
  58              	.loc 1 154 0
  59 003d 0FB7C3   	movzwl %bx,%eax
  60              	.LBB2:
  61              	.LBB3:
  62              	.LBB4:
  63              	.LBB5:
  64              	.file 2 "include/linux/byteorder/swab.h"
   1:include/linux/byteorder/swab.h **** #ifndef _LINUX_BYTEORDER_SWAB_H
   2:include/linux/byteorder/swab.h **** #define _LINUX_BYTEORDER_SWAB_H
   3:include/linux/byteorder/swab.h **** 
   4:include/linux/byteorder/swab.h **** /*
   5:include/linux/byteorder/swab.h ****  * linux/byteorder/swab.h
   6:include/linux/byteorder/swab.h ****  * Byte-swapping, independently from CPU endianness
   7:include/linux/byteorder/swab.h ****  *	swabXX[ps]?(foo)
   8:include/linux/byteorder/swab.h ****  *
   9:include/linux/byteorder/swab.h ****  * Francois-Rene Rideau <fare@tunes.org> 19971205
  10:include/linux/byteorder/swab.h ****  *    separated swab functions from cpu_to_XX,
  11:include/linux/byteorder/swab.h ****  *    to clean up support for bizarre-endian architectures.
  12:include/linux/byteorder/swab.h ****  *
  13:include/linux/byteorder/swab.h ****  * See asm-i386/byteorder.h and suches for examples of how to provide
  14:include/linux/byteorder/swab.h ****  * architecture-dependent optimized versions
  15:include/linux/byteorder/swab.h ****  *
  16:include/linux/byteorder/swab.h ****  */
GAS LISTING  			page 5


  17:include/linux/byteorder/swab.h **** 
  18:include/linux/byteorder/swab.h **** #include <linux/compiler.h>
  19:include/linux/byteorder/swab.h **** 
  20:include/linux/byteorder/swab.h **** /* casts are necessary for constants, because we never know how for sure
  21:include/linux/byteorder/swab.h ****  * how U/UL/ULL map to __u16, __u32, __u64. At least not in a portable way.
  22:include/linux/byteorder/swab.h ****  */
  23:include/linux/byteorder/swab.h **** #define ___swab16(x) \
  24:include/linux/byteorder/swab.h **** ({ \
  25:include/linux/byteorder/swab.h **** 	__u16 __x = (x); \
  26:include/linux/byteorder/swab.h **** 	((__u16)( \
  27:include/linux/byteorder/swab.h **** 		(((__u16)(__x) & (__u16)0x00ffU) << 8) | \
  28:include/linux/byteorder/swab.h **** 		(((__u16)(__x) & (__u16)0xff00U) >> 8) )); \
  29:include/linux/byteorder/swab.h **** })
  30:include/linux/byteorder/swab.h **** 
  31:include/linux/byteorder/swab.h **** #define ___swab32(x) \
  32:include/linux/byteorder/swab.h **** ({ \
  33:include/linux/byteorder/swab.h **** 	__u32 __x = (x); \
  34:include/linux/byteorder/swab.h **** 	((__u32)( \
  35:include/linux/byteorder/swab.h **** 		(((__u32)(__x) & (__u32)0x000000ffUL) << 24) | \
  36:include/linux/byteorder/swab.h **** 		(((__u32)(__x) & (__u32)0x0000ff00UL) <<  8) | \
  37:include/linux/byteorder/swab.h **** 		(((__u32)(__x) & (__u32)0x00ff0000UL) >>  8) | \
  38:include/linux/byteorder/swab.h **** 		(((__u32)(__x) & (__u32)0xff000000UL) >> 24) )); \
  39:include/linux/byteorder/swab.h **** })
  40:include/linux/byteorder/swab.h **** 
  41:include/linux/byteorder/swab.h **** #define ___swab64(x) \
  42:include/linux/byteorder/swab.h **** ({ \
  43:include/linux/byteorder/swab.h **** 	__u64 __x = (x); \
  44:include/linux/byteorder/swab.h **** 	((__u64)( \
  45:include/linux/byteorder/swab.h **** 		(__u64)(((__u64)(__x) & (__u64)0x00000000000000ffULL) << 56) | \
  46:include/linux/byteorder/swab.h **** 		(__u64)(((__u64)(__x) & (__u64)0x000000000000ff00ULL) << 40) | \
  47:include/linux/byteorder/swab.h **** 		(__u64)(((__u64)(__x) & (__u64)0x0000000000ff0000ULL) << 24) | \
  48:include/linux/byteorder/swab.h **** 		(__u64)(((__u64)(__x) & (__u64)0x00000000ff000000ULL) <<  8) | \
  49:include/linux/byteorder/swab.h **** 	        (__u64)(((__u64)(__x) & (__u64)0x000000ff00000000ULL) >>  8) | \
  50:include/linux/byteorder/swab.h **** 		(__u64)(((__u64)(__x) & (__u64)0x0000ff0000000000ULL) >> 24) | \
  51:include/linux/byteorder/swab.h **** 		(__u64)(((__u64)(__x) & (__u64)0x00ff000000000000ULL) >> 40) | \
  52:include/linux/byteorder/swab.h **** 		(__u64)(((__u64)(__x) & (__u64)0xff00000000000000ULL) >> 56) )); \
  53:include/linux/byteorder/swab.h **** })
  54:include/linux/byteorder/swab.h **** 
  55:include/linux/byteorder/swab.h **** #define ___constant_swab16(x) \
  56:include/linux/byteorder/swab.h **** 	((__u16)( \
  57:include/linux/byteorder/swab.h **** 		(((__u16)(x) & (__u16)0x00ffU) << 8) | \
  58:include/linux/byteorder/swab.h **** 		(((__u16)(x) & (__u16)0xff00U) >> 8) ))
  59:include/linux/byteorder/swab.h **** #define ___constant_swab32(x) \
  60:include/linux/byteorder/swab.h **** 	((__u32)( \
  61:include/linux/byteorder/swab.h **** 		(((__u32)(x) & (__u32)0x000000ffUL) << 24) | \
  62:include/linux/byteorder/swab.h **** 		(((__u32)(x) & (__u32)0x0000ff00UL) <<  8) | \
  63:include/linux/byteorder/swab.h **** 		(((__u32)(x) & (__u32)0x00ff0000UL) >>  8) | \
  64:include/linux/byteorder/swab.h **** 		(((__u32)(x) & (__u32)0xff000000UL) >> 24) ))
  65:include/linux/byteorder/swab.h **** #define ___constant_swab64(x) \
  66:include/linux/byteorder/swab.h **** 	((__u64)( \
  67:include/linux/byteorder/swab.h **** 		(__u64)(((__u64)(x) & (__u64)0x00000000000000ffULL) << 56) | \
  68:include/linux/byteorder/swab.h **** 		(__u64)(((__u64)(x) & (__u64)0x000000000000ff00ULL) << 40) | \
  69:include/linux/byteorder/swab.h **** 		(__u64)(((__u64)(x) & (__u64)0x0000000000ff0000ULL) << 24) | \
  70:include/linux/byteorder/swab.h **** 		(__u64)(((__u64)(x) & (__u64)0x00000000ff000000ULL) <<  8) | \
  71:include/linux/byteorder/swab.h **** 	        (__u64)(((__u64)(x) & (__u64)0x000000ff00000000ULL) >>  8) | \
  72:include/linux/byteorder/swab.h **** 		(__u64)(((__u64)(x) & (__u64)0x0000ff0000000000ULL) >> 24) | \
  73:include/linux/byteorder/swab.h **** 		(__u64)(((__u64)(x) & (__u64)0x00ff000000000000ULL) >> 40) | \
GAS LISTING  			page 6


  74:include/linux/byteorder/swab.h **** 		(__u64)(((__u64)(x) & (__u64)0xff00000000000000ULL) >> 56) ))
  75:include/linux/byteorder/swab.h **** 
  76:include/linux/byteorder/swab.h **** /*
  77:include/linux/byteorder/swab.h ****  * provide defaults when no architecture-specific optimization is detected
  78:include/linux/byteorder/swab.h ****  */
  79:include/linux/byteorder/swab.h **** #ifndef __arch__swab16
  80:include/linux/byteorder/swab.h **** #  define __arch__swab16(x) ({ __u16 __tmp = (x) ; ___swab16(__tmp); })
  81:include/linux/byteorder/swab.h **** #endif
  82:include/linux/byteorder/swab.h **** #ifndef __arch__swab32
  83:include/linux/byteorder/swab.h **** #  define __arch__swab32(x) ({ __u32 __tmp = (x) ; ___swab32(__tmp); })
  84:include/linux/byteorder/swab.h **** #endif
  85:include/linux/byteorder/swab.h **** #ifndef __arch__swab64
  86:include/linux/byteorder/swab.h **** #  define __arch__swab64(x) ({ __u64 __tmp = (x) ; ___swab64(__tmp); })
  87:include/linux/byteorder/swab.h **** #endif
  88:include/linux/byteorder/swab.h **** 
  89:include/linux/byteorder/swab.h **** #ifndef __arch__swab16p
  90:include/linux/byteorder/swab.h **** #  define __arch__swab16p(x) __arch__swab16(*(x))
  91:include/linux/byteorder/swab.h **** #endif
  92:include/linux/byteorder/swab.h **** #ifndef __arch__swab32p
  93:include/linux/byteorder/swab.h **** #  define __arch__swab32p(x) __arch__swab32(*(x))
  94:include/linux/byteorder/swab.h **** #endif
  95:include/linux/byteorder/swab.h **** #ifndef __arch__swab64p
  96:include/linux/byteorder/swab.h **** #  define __arch__swab64p(x) __arch__swab64(*(x))
  97:include/linux/byteorder/swab.h **** #endif
  98:include/linux/byteorder/swab.h **** 
  99:include/linux/byteorder/swab.h **** #ifndef __arch__swab16s
 100:include/linux/byteorder/swab.h **** #  define __arch__swab16s(x) do { *(x) = __arch__swab16p((x)); } while (0)
 101:include/linux/byteorder/swab.h **** #endif
 102:include/linux/byteorder/swab.h **** #ifndef __arch__swab32s
 103:include/linux/byteorder/swab.h **** #  define __arch__swab32s(x) do { *(x) = __arch__swab32p((x)); } while (0)
 104:include/linux/byteorder/swab.h **** #endif
 105:include/linux/byteorder/swab.h **** #ifndef __arch__swab64s
 106:include/linux/byteorder/swab.h **** #  define __arch__swab64s(x) do { *(x) = __arch__swab64p((x)); } while (0)
 107:include/linux/byteorder/swab.h **** #endif
 108:include/linux/byteorder/swab.h **** 
 109:include/linux/byteorder/swab.h **** 
 110:include/linux/byteorder/swab.h **** /*
 111:include/linux/byteorder/swab.h ****  * Allow constant folding
 112:include/linux/byteorder/swab.h ****  */
 113:include/linux/byteorder/swab.h **** #if defined(__GNUC__) && (__GNUC__ >= 2) && defined(__OPTIMIZE__)
 114:include/linux/byteorder/swab.h **** #  define __swab16(x) \
 115:include/linux/byteorder/swab.h **** (__builtin_constant_p((__u16)(x)) ? \
 116:include/linux/byteorder/swab.h ****  ___swab16((x)) : \
 117:include/linux/byteorder/swab.h ****  __fswab16((x)))
 118:include/linux/byteorder/swab.h **** #  define __swab32(x) \
 119:include/linux/byteorder/swab.h **** (__builtin_constant_p((__u32)(x)) ? \
 120:include/linux/byteorder/swab.h ****  ___swab32((x)) : \
 121:include/linux/byteorder/swab.h ****  __fswab32((x)))
 122:include/linux/byteorder/swab.h **** #  define __swab64(x) \
 123:include/linux/byteorder/swab.h **** (__builtin_constant_p((__u64)(x)) ? \
 124:include/linux/byteorder/swab.h ****  ___swab64((x)) : \
 125:include/linux/byteorder/swab.h ****  __fswab64((x)))
 126:include/linux/byteorder/swab.h **** #else
 127:include/linux/byteorder/swab.h **** #  define __swab16(x) __fswab16(x)
 128:include/linux/byteorder/swab.h **** #  define __swab32(x) __fswab32(x)
 129:include/linux/byteorder/swab.h **** #  define __swab64(x) __fswab64(x)
 130:include/linux/byteorder/swab.h **** #endif /* OPTIMIZE */
GAS LISTING  			page 7


 131:include/linux/byteorder/swab.h **** 
 132:include/linux/byteorder/swab.h **** 
 133:include/linux/byteorder/swab.h **** static __inline__ __attribute_const__ __u16 __fswab16(__u16 x)
 134:include/linux/byteorder/swab.h **** {
 135:include/linux/byteorder/swab.h **** 	return __arch__swab16(x);
  65              	.loc 2 135 0
  66 0040 89C2     	movl %eax,%edx
  67 0042 C1E208   	sall $8,%edx
  68 0045 C1E808   	shrl $8,%eax
  69 0048 09C2     	orl %eax,%edx
  70              	.LBE5:
  71              	.LBE4:
  72              	.LBE3:
  73              	.LBE2:
  74              	.loc 2 134 0
  75 004a 66895106 	movw %dx,6(%ecx)
 155:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 
 156:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	return SNAP_SIZE + sizeof(u16);
 157:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** }
  76              	.loc 1 157 0
  77 004e B8080000 	movl $8,%eax
  77      00
  78 0053 5B       	popl %ebx
  79 0054 C3       	ret
  80              	.LFE922:
  82              	.section .rodata.str1.1,"aMS",@progbits,1
  83              	.LC0:
  84 0000 3C363E25 	.string "<6>%s: Encryption failed: len=%d.\n"
  84      733A2045 
  84      6E637279 
  84      7074696F 
  84      6E206661 
  85              	.text
  87              	ieee80211_encrypt_fragment:
  88              	.LFB923:
 158:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 
 159:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** static int ieee80211_encrypt_fragment(struct ieee80211_device *ieee,
 160:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 					     struct sk_buff *frag, int hdr_len)
 161:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** {
  89              	.loc 1 161 0
  90 0055 57       	pushl %edi
  91              	.LCFI1:
  92 0056 56       	pushl %esi
  93              	.LCFI2:
  94 0057 53       	pushl %ebx
  95              	.LCFI3:
  96              	.loc 1 161 0
  97 0058 8B742410 	movl 16(%esp),%esi
 162:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	struct ieee80211_crypt_data *crypt = ieee->crypt[ieee->tx_keyidx];
  98              	.loc 1 162 0
  99 005c 8B86B006 	movl 1712(%esi),%eax
  99      0000
 100 0062 8B9C86A0 	movl 1696(%esi,%eax,4),%ebx
 100      060000
 163:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	int res;
 164:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 
 165:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	if (crypt == NULL)
GAS LISTING  			page 8


 166:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		return -1;
 101              	.loc 1 166 0
 102 0069 83C8FF   	orl $-1,%eax
 103              	.loc 1 165 0
 104 006c 85DB     	testl %ebx,%ebx
 105              	.loc 1 161 0
 106 006e 8B7C2414 	movl 20(%esp),%edi
 107              	.loc 1 165 0
 108 0072 7446     	je .L8
 109              	.LBB6:
 110              	.LBB7:
 111              	.file 3 "include/asm/atomic.h"
   1:include/asm/atomic.h **** #ifndef __ARCH_I386_ATOMIC__
   2:include/asm/atomic.h **** #define __ARCH_I386_ATOMIC__
   3:include/asm/atomic.h **** 
   4:include/asm/atomic.h **** #include <linux/config.h>
   5:include/asm/atomic.h **** #include <linux/compiler.h>
   6:include/asm/atomic.h **** #include <asm/processor.h>
   7:include/asm/atomic.h **** 
   8:include/asm/atomic.h **** /*
   9:include/asm/atomic.h ****  * Atomic operations that C can't guarantee us.  Useful for
  10:include/asm/atomic.h ****  * resource counting etc..
  11:include/asm/atomic.h ****  */
  12:include/asm/atomic.h **** 
  13:include/asm/atomic.h **** #ifdef CONFIG_SMP
  14:include/asm/atomic.h **** #define LOCK "lock ; "
  15:include/asm/atomic.h **** #else
  16:include/asm/atomic.h **** #define LOCK ""
  17:include/asm/atomic.h **** #endif
  18:include/asm/atomic.h **** 
  19:include/asm/atomic.h **** /*
  20:include/asm/atomic.h ****  * Make sure gcc doesn't try to be clever and move things around
  21:include/asm/atomic.h ****  * on us. We need to use _exactly_ the address the user gave us,
  22:include/asm/atomic.h ****  * not some alias that contains the same information.
  23:include/asm/atomic.h ****  */
  24:include/asm/atomic.h **** typedef struct { volatile int counter; } atomic_t;
  25:include/asm/atomic.h **** 
  26:include/asm/atomic.h **** #define ATOMIC_INIT(i)	{ (i) }
  27:include/asm/atomic.h **** 
  28:include/asm/atomic.h **** /**
  29:include/asm/atomic.h ****  * atomic_read - read atomic variable
  30:include/asm/atomic.h ****  * @v: pointer of type atomic_t
  31:include/asm/atomic.h ****  * 
  32:include/asm/atomic.h ****  * Atomically reads the value of @v.
  33:include/asm/atomic.h ****  */ 
  34:include/asm/atomic.h **** #define atomic_read(v)		((v)->counter)
  35:include/asm/atomic.h **** 
  36:include/asm/atomic.h **** /**
  37:include/asm/atomic.h ****  * atomic_set - set atomic variable
  38:include/asm/atomic.h ****  * @v: pointer of type atomic_t
  39:include/asm/atomic.h ****  * @i: required value
  40:include/asm/atomic.h ****  * 
  41:include/asm/atomic.h ****  * Atomically sets the value of @v to @i.
  42:include/asm/atomic.h ****  */ 
  43:include/asm/atomic.h **** #define atomic_set(v,i)		(((v)->counter) = (i))
  44:include/asm/atomic.h **** 
  45:include/asm/atomic.h **** /**
GAS LISTING  			page 9


  46:include/asm/atomic.h ****  * atomic_add - add integer to atomic variable
  47:include/asm/atomic.h ****  * @i: integer value to add
  48:include/asm/atomic.h ****  * @v: pointer of type atomic_t
  49:include/asm/atomic.h ****  * 
  50:include/asm/atomic.h ****  * Atomically adds @i to @v.
  51:include/asm/atomic.h ****  */
  52:include/asm/atomic.h **** static __inline__ void atomic_add(int i, atomic_t *v)
  53:include/asm/atomic.h **** {
  54:include/asm/atomic.h **** 	__asm__ __volatile__(
  55:include/asm/atomic.h **** 		LOCK "addl %1,%0"
  56:include/asm/atomic.h **** 		:"=m" (v->counter)
  57:include/asm/atomic.h **** 		:"ir" (i), "m" (v->counter));
  58:include/asm/atomic.h **** }
  59:include/asm/atomic.h **** 
  60:include/asm/atomic.h **** /**
  61:include/asm/atomic.h ****  * atomic_sub - subtract the atomic variable
  62:include/asm/atomic.h ****  * @i: integer value to subtract
  63:include/asm/atomic.h ****  * @v: pointer of type atomic_t
  64:include/asm/atomic.h ****  * 
  65:include/asm/atomic.h ****  * Atomically subtracts @i from @v.
  66:include/asm/atomic.h ****  */
  67:include/asm/atomic.h **** static __inline__ void atomic_sub(int i, atomic_t *v)
  68:include/asm/atomic.h **** {
  69:include/asm/atomic.h **** 	__asm__ __volatile__(
  70:include/asm/atomic.h **** 		LOCK "subl %1,%0"
  71:include/asm/atomic.h **** 		:"=m" (v->counter)
  72:include/asm/atomic.h **** 		:"ir" (i), "m" (v->counter));
  73:include/asm/atomic.h **** }
  74:include/asm/atomic.h **** 
  75:include/asm/atomic.h **** /**
  76:include/asm/atomic.h ****  * atomic_sub_and_test - subtract value from variable and test result
  77:include/asm/atomic.h ****  * @i: integer value to subtract
  78:include/asm/atomic.h ****  * @v: pointer of type atomic_t
  79:include/asm/atomic.h ****  * 
  80:include/asm/atomic.h ****  * Atomically subtracts @i from @v and returns
  81:include/asm/atomic.h ****  * true if the result is zero, or false for all
  82:include/asm/atomic.h ****  * other cases.
  83:include/asm/atomic.h ****  */
  84:include/asm/atomic.h **** static __inline__ int atomic_sub_and_test(int i, atomic_t *v)
  85:include/asm/atomic.h **** {
  86:include/asm/atomic.h **** 	unsigned char c;
  87:include/asm/atomic.h **** 
  88:include/asm/atomic.h **** 	__asm__ __volatile__(
  89:include/asm/atomic.h **** 		LOCK "subl %2,%0; sete %1"
  90:include/asm/atomic.h **** 		:"=m" (v->counter), "=qm" (c)
  91:include/asm/atomic.h **** 		:"ir" (i), "m" (v->counter) : "memory");
  92:include/asm/atomic.h **** 	return c;
  93:include/asm/atomic.h **** }
  94:include/asm/atomic.h **** 
  95:include/asm/atomic.h **** /**
  96:include/asm/atomic.h ****  * atomic_inc - increment atomic variable
  97:include/asm/atomic.h ****  * @v: pointer of type atomic_t
  98:include/asm/atomic.h ****  * 
  99:include/asm/atomic.h ****  * Atomically increments @v by 1.
 100:include/asm/atomic.h ****  */ 
 101:include/asm/atomic.h **** static __inline__ void atomic_inc(atomic_t *v)
 102:include/asm/atomic.h **** {
GAS LISTING  			page 10


 103:include/asm/atomic.h **** 	__asm__ __volatile__(
 112              	.loc 3 103 0
 113              	
 114 0074 FF4310   	incl 16(%ebx)
 115              	
 116              	.LBE7:
 117              	.LBE6:
 167:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 
 168:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	/* To encrypt, frame format is:
 169:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	 * IV (4 bytes), clear payload (including SNAP), ICV (4 bytes) */
 170:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	atomic_inc(&crypt->refcnt);
 171:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	res = 0;
 172:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	if (crypt->ops && crypt->ops->encrypt_mpdu)
 118              	.loc 1 172 0
 119 0077 8B5308   	movl 8(%ebx),%edx
 120              	.loc 1 171 0
 121 007a 31C9     	xorl %ecx,%ecx
 122              	.loc 1 172 0
 123 007c 85D2     	testl %edx,%edx
 124 007e 7416     	je .L11
 125 0080 837A1800 	cmpl $0,24(%edx)
 126 0084 7410     	je .L11
 173:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		res = crypt->ops->encrypt_mpdu(frag, hdr_len, crypt->priv);
 127              	.loc 1 173 0
 128 0086 FF730C   	pushl 12(%ebx)
 129              	.LCFI4:
 130 0089 FF74241C 	pushl 28(%esp)
 131              	.LCFI5:
 132 008d 57       	pushl %edi
 133              	.LCFI6:
 134 008e FF5218   	call *24(%edx)
 135 0091 89C1     	movl %eax,%ecx
 136 0093 83C40C   	addl $12,%esp
 137              	.LCFI7:
 138              	.L11:
 139              	.LBB8:
 140              	.LBB9:
 104:include/asm/atomic.h **** 		LOCK "incl %0"
 105:include/asm/atomic.h **** 		:"=m" (v->counter)
 106:include/asm/atomic.h **** 		:"m" (v->counter));
 107:include/asm/atomic.h **** }
 108:include/asm/atomic.h **** 
 109:include/asm/atomic.h **** /**
 110:include/asm/atomic.h ****  * atomic_dec - decrement atomic variable
 111:include/asm/atomic.h ****  * @v: pointer of type atomic_t
 112:include/asm/atomic.h ****  * 
 113:include/asm/atomic.h ****  * Atomically decrements @v by 1.
 114:include/asm/atomic.h ****  */ 
 115:include/asm/atomic.h **** static __inline__ void atomic_dec(atomic_t *v)
 116:include/asm/atomic.h **** {
 117:include/asm/atomic.h **** 	__asm__ __volatile__(
 141              	.loc 3 117 0
 142              	
 143 0096 FF4B10   	decl 16(%ebx)
 144              	
 145              	.LBE9:
 146              	.LBE8:
GAS LISTING  			page 11


 174:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 
 175:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	atomic_dec(&crypt->refcnt);
 176:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	if (res < 0) {
 177:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		printk(KERN_INFO "%s: Encryption failed: len=%d.\n",
 178:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		       ieee->dev->name, frag->len);
 179:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		ieee->ieee_stats.tx_discards++;
 180:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		return -1;
 181:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	}
 182:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 
 183:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	return 0;
 147              	.loc 1 183 0
 148 0099 31C0     	xorl %eax,%eax
 149              	.loc 1 176 0
 150 009b 85C9     	testl %ecx,%ecx
 151 009d 791B     	jns .L8
 152              	.loc 1 177 0
 153 009f FF7760   	pushl 96(%edi)
 154              	.LCFI8:
 155 00a2 FF36     	pushl (%esi)
 156              	.LCFI9:
 157 00a4 68000000 	pushl $.LC0
 157      00
 158              	.LCFI10:
 159 00a9 E8FCFFFF 	call printk
 159      FF
 160              	.loc 1 180 0
 161 00ae 83C40C   	addl $12,%esp
 162              	.LCFI11:
 163              	.loc 1 179 0
 164 00b1 FF861401 	incl 276(%esi)
 164      0000
 165              	.loc 1 180 0
 166 00b7 83C8FF   	orl $-1,%eax
 167              	.L8:
 184:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** }
 168              	.loc 1 184 0
 169 00ba 5B       	popl %ebx
 170 00bb 5E       	popl %esi
 171 00bc 5F       	popl %edi
 172 00bd C3       	ret
 173              	.LFE923:
 175              	.globl ieee80211_txb_free
 177              	ieee80211_txb_free:
 178              	.LFB924:
 185:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 
 186:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** void ieee80211_txb_free(struct ieee80211_txb *txb)
 187:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** {
 179              	.loc 1 187 0
 180 00be 57       	pushl %edi
 181              	.LCFI12:
 182 00bf 56       	pushl %esi
 183              	.LCFI13:
 184 00c0 53       	pushl %ebx
 185              	.LCFI14:
 186              	.loc 1 187 0
 187 00c1 8B742410 	movl 16(%esp),%esi
 188:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	int i;
GAS LISTING  			page 12


 189:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	if (unlikely(!txb))
 188              	.loc 1 189 0
 189 00c5 85F6     	testl %esi,%esi
 190 00c7 0F848400 	je .L14
 190      0000
 190:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		return;
 191:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	for (i = 0; i < txb->nr_frags; i++)
 191              	.loc 1 191 0
 192 00cd 31FF     	xorl %edi,%edi
 193 00cf 803E00   	cmpb $0,(%esi)
 194 00d2 7471     	je .L37
 195              	.L35:
 192:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		if (txb->fragments[i])
 196              	.loc 1 192 0
 197 00d4 8B54BE08 	movl 8(%esi,%edi,4),%edx
 198 00d8 85D2     	testl %edx,%edx
 199 00da 7461     	je .L18
 200              	.LBB10:
 201              	.LBB11:
 202              	.LBB12:
 203              	.LBB13:
 204              	.file 4 "include/asm/thread_info.h"
   1:include/asm/thread_info.h **** /* thread_info.h: i386 low-level thread information
   2:include/asm/thread_info.h ****  *
   3:include/asm/thread_info.h ****  * Copyright (C) 2002  David Howells (dhowells@redhat.com)
   4:include/asm/thread_info.h ****  * - Incorporating suggestions made by Linus Torvalds and Dave Miller
   5:include/asm/thread_info.h ****  */
   6:include/asm/thread_info.h **** 
   7:include/asm/thread_info.h **** #ifndef _ASM_THREAD_INFO_H
   8:include/asm/thread_info.h **** #define _ASM_THREAD_INFO_H
   9:include/asm/thread_info.h **** 
  10:include/asm/thread_info.h **** #ifdef __KERNEL__
  11:include/asm/thread_info.h **** 
  12:include/asm/thread_info.h **** #include <linux/config.h>
  13:include/asm/thread_info.h **** #include <linux/compiler.h>
  14:include/asm/thread_info.h **** #include <asm/page.h>
  15:include/asm/thread_info.h **** 
  16:include/asm/thread_info.h **** #ifndef __ASSEMBLY__
  17:include/asm/thread_info.h **** #include <asm/processor.h>
  18:include/asm/thread_info.h **** #endif
  19:include/asm/thread_info.h **** 
  20:include/asm/thread_info.h **** /*
  21:include/asm/thread_info.h ****  * low level task data that entry.S needs immediate access to
  22:include/asm/thread_info.h ****  * - this struct should fit entirely inside of one cache line
  23:include/asm/thread_info.h ****  * - this struct shares the supervisor stack pages
  24:include/asm/thread_info.h ****  * - if the contents of this structure are changed, the assembly constants must also be changed
  25:include/asm/thread_info.h ****  */
  26:include/asm/thread_info.h **** #ifndef __ASSEMBLY__
  27:include/asm/thread_info.h **** 
  28:include/asm/thread_info.h **** struct thread_info {
  29:include/asm/thread_info.h **** 	struct task_struct	*task;		/* main task structure */
  30:include/asm/thread_info.h **** 	struct exec_domain	*exec_domain;	/* execution domain */
  31:include/asm/thread_info.h **** 	unsigned long		flags;		/* low level flags */
  32:include/asm/thread_info.h **** 	unsigned long		status;		/* thread-synchronous flags */
  33:include/asm/thread_info.h **** 	__u32			cpu;		/* current CPU */
  34:include/asm/thread_info.h **** 	__s32			preempt_count; /* 0 => preemptable, <0 => BUG */
  35:include/asm/thread_info.h **** 
GAS LISTING  			page 13


  36:include/asm/thread_info.h **** 
  37:include/asm/thread_info.h **** 	mm_segment_t		addr_limit;	/* thread address space:
  38:include/asm/thread_info.h **** 					 	   0-0xBFFFFFFF for user-thead
  39:include/asm/thread_info.h **** 						   0-0xFFFFFFFF for kernel-thread
  40:include/asm/thread_info.h **** 						*/
  41:include/asm/thread_info.h **** 	struct restart_block    restart_block;
  42:include/asm/thread_info.h **** 
  43:include/asm/thread_info.h **** 	unsigned long           previous_esp;   /* ESP of the previous stack in case
  44:include/asm/thread_info.h **** 						   of nested (IRQ) stacks
  45:include/asm/thread_info.h **** 						*/
  46:include/asm/thread_info.h **** 	__u8			supervisor_stack[0];
  47:include/asm/thread_info.h **** };
  48:include/asm/thread_info.h **** 
  49:include/asm/thread_info.h **** #else /* !__ASSEMBLY__ */
  50:include/asm/thread_info.h **** 
  51:include/asm/thread_info.h **** #include <asm/asm_offsets.h>
  52:include/asm/thread_info.h **** 
  53:include/asm/thread_info.h **** #endif
  54:include/asm/thread_info.h **** 
  55:include/asm/thread_info.h **** #define PREEMPT_ACTIVE		0x10000000
  56:include/asm/thread_info.h **** #ifdef CONFIG_4KSTACKS
  57:include/asm/thread_info.h **** #define THREAD_SIZE            (4096)
  58:include/asm/thread_info.h **** #else
  59:include/asm/thread_info.h **** #define THREAD_SIZE		(8192)
  60:include/asm/thread_info.h **** #endif
  61:include/asm/thread_info.h **** 
  62:include/asm/thread_info.h **** #define STACK_WARN             (THREAD_SIZE/8)
  63:include/asm/thread_info.h **** /*
  64:include/asm/thread_info.h ****  * macros/functions for gaining access to the thread information structure
  65:include/asm/thread_info.h ****  *
  66:include/asm/thread_info.h ****  * preempt_count needs to be 1 initially, until the scheduler is functional.
  67:include/asm/thread_info.h ****  */
  68:include/asm/thread_info.h **** #ifndef __ASSEMBLY__
  69:include/asm/thread_info.h **** 
  70:include/asm/thread_info.h **** #define INIT_THREAD_INFO(tsk)			\
  71:include/asm/thread_info.h **** {						\
  72:include/asm/thread_info.h **** 	.task		= &tsk,			\
  73:include/asm/thread_info.h **** 	.exec_domain	= &default_exec_domain,	\
  74:include/asm/thread_info.h **** 	.flags		= 0,			\
  75:include/asm/thread_info.h **** 	.cpu		= 0,			\
  76:include/asm/thread_info.h **** 	.preempt_count	= 1,			\
  77:include/asm/thread_info.h **** 	.addr_limit	= KERNEL_DS,		\
  78:include/asm/thread_info.h **** 	.restart_block = {			\
  79:include/asm/thread_info.h **** 		.fn = do_no_restart_syscall,	\
  80:include/asm/thread_info.h **** 	},					\
  81:include/asm/thread_info.h **** }
  82:include/asm/thread_info.h **** 
  83:include/asm/thread_info.h **** #define init_thread_info	(init_thread_union.thread_info)
  84:include/asm/thread_info.h **** #define init_stack		(init_thread_union.stack)
  85:include/asm/thread_info.h **** 
  86:include/asm/thread_info.h **** 
  87:include/asm/thread_info.h **** /* how to get the thread information struct from C */
  88:include/asm/thread_info.h **** static inline struct thread_info *current_thread_info(void)
  89:include/asm/thread_info.h **** {
  90:include/asm/thread_info.h **** 	struct thread_info *ti;
  91:include/asm/thread_info.h **** 	__asm__("andl %%esp,%0; ":"=r" (ti) : "0" (~(THREAD_SIZE - 1)));
 205              	.loc 4 91 0
GAS LISTING  			page 14


 206 00dc B800E0FF 	movl $-8192,%eax
 206      FF
 207              	
 208 00e1 21E0     	andl %esp,%eax
 209              	
 210              	.LBE13:
 211              	.LBE12:
 212              	.loc 4 89 0
 213 00e3 F7401400 	testl $268369920,20(%eax)
 213      00FF0F
 214 00ea 7507     	jne .L21
 215              	.LBB14:
 216              	.file 5 "include/linux/netdevice.h"
   1:include/linux/netdevice.h **** /*
   2:include/linux/netdevice.h ****  * INET		An implementation of the TCP/IP protocol suite for the LINUX
   3:include/linux/netdevice.h ****  *		operating system.  INET is implemented using the  BSD Socket
   4:include/linux/netdevice.h ****  *		interface as the means of communication with the user level.
   5:include/linux/netdevice.h ****  *
   6:include/linux/netdevice.h ****  *		Definitions for the Interfaces handler.
   7:include/linux/netdevice.h ****  *
   8:include/linux/netdevice.h ****  * Version:	@(#)dev.h	1.0.10	08/12/93
   9:include/linux/netdevice.h ****  *
  10:include/linux/netdevice.h ****  * Authors:	Ross Biro
  11:include/linux/netdevice.h ****  *		Fred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>
  12:include/linux/netdevice.h ****  *		Corey Minyard <wf-rch!minyard@relay.EU.net>
  13:include/linux/netdevice.h ****  *		Donald J. Becker, <becker@cesdis.gsfc.nasa.gov>
  14:include/linux/netdevice.h ****  *		Alan Cox, <Alan.Cox@linux.org>
  15:include/linux/netdevice.h ****  *		Bjorn Ekwall. <bj0rn@blox.se>
  16:include/linux/netdevice.h ****  *              Pekka Riikonen <priikone@poseidon.pspt.fi>
  17:include/linux/netdevice.h ****  *
  18:include/linux/netdevice.h ****  *		This program is free software; you can redistribute it and/or
  19:include/linux/netdevice.h ****  *		modify it under the terms of the GNU General Public License
  20:include/linux/netdevice.h ****  *		as published by the Free Software Foundation; either version
  21:include/linux/netdevice.h ****  *		2 of the License, or (at your option) any later version.
  22:include/linux/netdevice.h ****  *
  23:include/linux/netdevice.h ****  *		Moved to /usr/include/linux for NET3
  24:include/linux/netdevice.h ****  */
  25:include/linux/netdevice.h **** #ifndef _LINUX_NETDEVICE_H
  26:include/linux/netdevice.h **** #define _LINUX_NETDEVICE_H
  27:include/linux/netdevice.h **** 
  28:include/linux/netdevice.h **** #include <linux/if.h>
  29:include/linux/netdevice.h **** #include <linux/if_ether.h>
  30:include/linux/netdevice.h **** #include <linux/if_packet.h>
  31:include/linux/netdevice.h **** 
  32:include/linux/netdevice.h **** #ifdef __KERNEL__
  33:include/linux/netdevice.h **** #include <asm/atomic.h>
  34:include/linux/netdevice.h **** #include <asm/cache.h>
  35:include/linux/netdevice.h **** #include <asm/byteorder.h>
  36:include/linux/netdevice.h **** 
  37:include/linux/netdevice.h **** #include <linux/config.h>
  38:include/linux/netdevice.h **** #include <linux/device.h>
  39:include/linux/netdevice.h **** #include <linux/percpu.h>
  40:include/linux/netdevice.h **** 
  41:include/linux/netdevice.h **** struct divert_blk;
  42:include/linux/netdevice.h **** struct vlan_group;
  43:include/linux/netdevice.h **** struct ethtool_ops;
  44:include/linux/netdevice.h **** struct netpoll;
GAS LISTING  			page 15


  45:include/linux/netdevice.h **** 					/* source back-compat hooks */
  46:include/linux/netdevice.h **** #define SET_ETHTOOL_OPS(netdev,ops) \
  47:include/linux/netdevice.h **** 	( (netdev)->ethtool_ops = (ops) )
  48:include/linux/netdevice.h **** 
  49:include/linux/netdevice.h **** #define HAVE_ALLOC_NETDEV		/* feature macro: alloc_xxxdev
  50:include/linux/netdevice.h **** 					   functions are available. */
  51:include/linux/netdevice.h **** #define HAVE_FREE_NETDEV		/* free_netdev() */
  52:include/linux/netdevice.h **** #define HAVE_NETDEV_PRIV		/* netdev_priv() */
  53:include/linux/netdevice.h **** 
  54:include/linux/netdevice.h **** #define NET_XMIT_SUCCESS	0
  55:include/linux/netdevice.h **** #define NET_XMIT_DROP		1	/* skb dropped			*/
  56:include/linux/netdevice.h **** #define NET_XMIT_CN		2	/* congestion notification	*/
  57:include/linux/netdevice.h **** #define NET_XMIT_POLICED	3	/* skb is shot by police	*/
  58:include/linux/netdevice.h **** #define NET_XMIT_BYPASS		4	/* packet does not leave via dequeue;
  59:include/linux/netdevice.h **** 					   (TC use only - dev_queue_xmit
  60:include/linux/netdevice.h **** 					   returns this as NET_XMIT_SUCCESS) */
  61:include/linux/netdevice.h **** 
  62:include/linux/netdevice.h **** /* Backlog congestion levels */
  63:include/linux/netdevice.h **** #define NET_RX_SUCCESS		0   /* keep 'em coming, baby */
  64:include/linux/netdevice.h **** #define NET_RX_DROP		1  /* packet dropped */
  65:include/linux/netdevice.h **** #define NET_RX_CN_LOW		2   /* storm alert, just in case */
  66:include/linux/netdevice.h **** #define NET_RX_CN_MOD		3   /* Storm on its way! */
  67:include/linux/netdevice.h **** #define NET_RX_CN_HIGH		4   /* The storm is here */
  68:include/linux/netdevice.h **** #define NET_RX_BAD		5  /* packet dropped due to kernel error */
  69:include/linux/netdevice.h **** 
  70:include/linux/netdevice.h **** #define net_xmit_errno(e)	((e) != NET_XMIT_CN ? -ENOBUFS : 0)
  71:include/linux/netdevice.h **** 
  72:include/linux/netdevice.h **** #endif
  73:include/linux/netdevice.h **** 
  74:include/linux/netdevice.h **** #define MAX_ADDR_LEN	32		/* Largest hardware address length */
  75:include/linux/netdevice.h **** 
  76:include/linux/netdevice.h **** /* Driver transmit return codes */
  77:include/linux/netdevice.h **** #define NETDEV_TX_OK 0		/* driver took care of packet */
  78:include/linux/netdevice.h **** #define NETDEV_TX_BUSY 1	/* driver tx path was busy*/
  79:include/linux/netdevice.h **** #define NETDEV_TX_LOCKED -1	/* driver tx lock was already taken */
  80:include/linux/netdevice.h **** 
  81:include/linux/netdevice.h **** /*
  82:include/linux/netdevice.h ****  *	Compute the worst case header length according to the protocols
  83:include/linux/netdevice.h ****  *	used.
  84:include/linux/netdevice.h ****  */
  85:include/linux/netdevice.h ****  
  86:include/linux/netdevice.h **** #if !defined(CONFIG_AX25) && !defined(CONFIG_AX25_MODULE) && !defined(CONFIG_TR)
  87:include/linux/netdevice.h **** #define LL_MAX_HEADER	32
  88:include/linux/netdevice.h **** #else
  89:include/linux/netdevice.h **** #if defined(CONFIG_AX25) || defined(CONFIG_AX25_MODULE)
  90:include/linux/netdevice.h **** #define LL_MAX_HEADER	96
  91:include/linux/netdevice.h **** #else
  92:include/linux/netdevice.h **** #define LL_MAX_HEADER	48
  93:include/linux/netdevice.h **** #endif
  94:include/linux/netdevice.h **** #endif
  95:include/linux/netdevice.h **** 
  96:include/linux/netdevice.h **** #if !defined(CONFIG_NET_IPIP) && \
  97:include/linux/netdevice.h ****     !defined(CONFIG_IPV6) && !defined(CONFIG_IPV6_MODULE)
  98:include/linux/netdevice.h **** #define MAX_HEADER LL_MAX_HEADER
  99:include/linux/netdevice.h **** #else
 100:include/linux/netdevice.h **** #define MAX_HEADER (LL_MAX_HEADER + 48)
 101:include/linux/netdevice.h **** #endif
GAS LISTING  			page 16


 102:include/linux/netdevice.h **** 
 103:include/linux/netdevice.h **** /*
 104:include/linux/netdevice.h ****  *	Network device statistics. Akin to the 2.0 ether stats but
 105:include/linux/netdevice.h ****  *	with byte counters.
 106:include/linux/netdevice.h ****  */
 107:include/linux/netdevice.h ****  
 108:include/linux/netdevice.h **** struct net_device_stats
 109:include/linux/netdevice.h **** {
 110:include/linux/netdevice.h **** 	unsigned long	rx_packets;		/* total packets received	*/
 111:include/linux/netdevice.h **** 	unsigned long	tx_packets;		/* total packets transmitted	*/
 112:include/linux/netdevice.h **** 	unsigned long	rx_bytes;		/* total bytes received 	*/
 113:include/linux/netdevice.h **** 	unsigned long	tx_bytes;		/* total bytes transmitted	*/
 114:include/linux/netdevice.h **** 	unsigned long	rx_errors;		/* bad packets received		*/
 115:include/linux/netdevice.h **** 	unsigned long	tx_errors;		/* packet transmit problems	*/
 116:include/linux/netdevice.h **** 	unsigned long	rx_dropped;		/* no space in linux buffers	*/
 117:include/linux/netdevice.h **** 	unsigned long	tx_dropped;		/* no space available in linux	*/
 118:include/linux/netdevice.h **** 	unsigned long	multicast;		/* multicast packets received	*/
 119:include/linux/netdevice.h **** 	unsigned long	collisions;
 120:include/linux/netdevice.h **** 
 121:include/linux/netdevice.h **** 	/* detailed rx_errors: */
 122:include/linux/netdevice.h **** 	unsigned long	rx_length_errors;
 123:include/linux/netdevice.h **** 	unsigned long	rx_over_errors;		/* receiver ring buff overflow	*/
 124:include/linux/netdevice.h **** 	unsigned long	rx_crc_errors;		/* recved pkt with crc error	*/
 125:include/linux/netdevice.h **** 	unsigned long	rx_frame_errors;	/* recv'd frame alignment error */
 126:include/linux/netdevice.h **** 	unsigned long	rx_fifo_errors;		/* recv'r fifo overrun		*/
 127:include/linux/netdevice.h **** 	unsigned long	rx_missed_errors;	/* receiver missed packet	*/
 128:include/linux/netdevice.h **** 
 129:include/linux/netdevice.h **** 	/* detailed tx_errors */
 130:include/linux/netdevice.h **** 	unsigned long	tx_aborted_errors;
 131:include/linux/netdevice.h **** 	unsigned long	tx_carrier_errors;
 132:include/linux/netdevice.h **** 	unsigned long	tx_fifo_errors;
 133:include/linux/netdevice.h **** 	unsigned long	tx_heartbeat_errors;
 134:include/linux/netdevice.h **** 	unsigned long	tx_window_errors;
 135:include/linux/netdevice.h **** 	
 136:include/linux/netdevice.h **** 	/* for cslip etc */
 137:include/linux/netdevice.h **** 	unsigned long	rx_compressed;
 138:include/linux/netdevice.h **** 	unsigned long	tx_compressed;
 139:include/linux/netdevice.h **** };
 140:include/linux/netdevice.h **** 
 141:include/linux/netdevice.h **** 
 142:include/linux/netdevice.h **** /* Media selection options. */
 143:include/linux/netdevice.h **** enum {
 144:include/linux/netdevice.h ****         IF_PORT_UNKNOWN = 0,
 145:include/linux/netdevice.h ****         IF_PORT_10BASE2,
 146:include/linux/netdevice.h ****         IF_PORT_10BASET,
 147:include/linux/netdevice.h ****         IF_PORT_AUI,
 148:include/linux/netdevice.h ****         IF_PORT_100BASET,
 149:include/linux/netdevice.h ****         IF_PORT_100BASETX,
 150:include/linux/netdevice.h ****         IF_PORT_100BASEFX
 151:include/linux/netdevice.h **** };
 152:include/linux/netdevice.h **** 
 153:include/linux/netdevice.h **** #ifdef __KERNEL__
 154:include/linux/netdevice.h **** 
 155:include/linux/netdevice.h **** #include <linux/cache.h>
 156:include/linux/netdevice.h **** #include <linux/skbuff.h>
 157:include/linux/netdevice.h **** 
 158:include/linux/netdevice.h **** struct neighbour;
GAS LISTING  			page 17


 159:include/linux/netdevice.h **** struct neigh_parms;
 160:include/linux/netdevice.h **** struct sk_buff;
 161:include/linux/netdevice.h **** 
 162:include/linux/netdevice.h **** struct netif_rx_stats
 163:include/linux/netdevice.h **** {
 164:include/linux/netdevice.h **** 	unsigned total;
 165:include/linux/netdevice.h **** 	unsigned dropped;
 166:include/linux/netdevice.h **** 	unsigned time_squeeze;
 167:include/linux/netdevice.h **** 	unsigned throttled;
 168:include/linux/netdevice.h **** 	unsigned fastroute_hit;
 169:include/linux/netdevice.h **** 	unsigned fastroute_success;
 170:include/linux/netdevice.h **** 	unsigned fastroute_defer;
 171:include/linux/netdevice.h **** 	unsigned fastroute_deferred_out;
 172:include/linux/netdevice.h **** 	unsigned fastroute_latency_reduction;
 173:include/linux/netdevice.h **** 	unsigned cpu_collision;
 174:include/linux/netdevice.h **** };
 175:include/linux/netdevice.h **** 
 176:include/linux/netdevice.h **** DECLARE_PER_CPU(struct netif_rx_stats, netdev_rx_stat);
 177:include/linux/netdevice.h **** 
 178:include/linux/netdevice.h **** 
 179:include/linux/netdevice.h **** /*
 180:include/linux/netdevice.h ****  *	We tag multicasts with these structures.
 181:include/linux/netdevice.h ****  */
 182:include/linux/netdevice.h ****  
 183:include/linux/netdevice.h **** struct dev_mc_list
 184:include/linux/netdevice.h **** {	
 185:include/linux/netdevice.h **** 	struct dev_mc_list	*next;
 186:include/linux/netdevice.h **** 	__u8			dmi_addr[MAX_ADDR_LEN];
 187:include/linux/netdevice.h **** 	unsigned char		dmi_addrlen;
 188:include/linux/netdevice.h **** 	int			dmi_users;
 189:include/linux/netdevice.h **** 	int			dmi_gusers;
 190:include/linux/netdevice.h **** };
 191:include/linux/netdevice.h **** 
 192:include/linux/netdevice.h **** struct hh_cache
 193:include/linux/netdevice.h **** {
 194:include/linux/netdevice.h **** 	struct hh_cache *hh_next;	/* Next entry			     */
 195:include/linux/netdevice.h **** 	atomic_t	hh_refcnt;	/* number of users                   */
 196:include/linux/netdevice.h **** 	unsigned short  hh_type;	/* protocol identifier, f.e ETH_P_IP
 197:include/linux/netdevice.h ****                                          *  NOTE:  For VLANs, this will be the
 198:include/linux/netdevice.h ****                                          *  encapuslated type. --BLG
 199:include/linux/netdevice.h ****                                          */
 200:include/linux/netdevice.h **** 	int		hh_len;		/* length of header */
 201:include/linux/netdevice.h **** 	int		(*hh_output)(struct sk_buff *skb);
 202:include/linux/netdevice.h **** 	rwlock_t	hh_lock;
 203:include/linux/netdevice.h **** 
 204:include/linux/netdevice.h **** 	/* cached hardware header; allow for machine alignment needs.        */
 205:include/linux/netdevice.h **** #define HH_DATA_MOD	16
 206:include/linux/netdevice.h **** #define HH_DATA_OFF(__len) \
 207:include/linux/netdevice.h **** 	(HH_DATA_MOD - (((__len - 1) & (HH_DATA_MOD - 1)) + 1))
 208:include/linux/netdevice.h **** #define HH_DATA_ALIGN(__len) \
 209:include/linux/netdevice.h **** 	(((__len)+(HH_DATA_MOD-1))&~(HH_DATA_MOD - 1))
 210:include/linux/netdevice.h **** 	unsigned long	hh_data[HH_DATA_ALIGN(LL_MAX_HEADER) / sizeof(long)];
 211:include/linux/netdevice.h **** };
 212:include/linux/netdevice.h **** 
 213:include/linux/netdevice.h **** /* Reserve HH_DATA_MOD byte aligned hard_header_len, but at least that much.
 214:include/linux/netdevice.h ****  * Alternative is:
 215:include/linux/netdevice.h ****  *   dev->hard_header_len ? (dev->hard_header_len +
GAS LISTING  			page 18


 216:include/linux/netdevice.h ****  *                           (HH_DATA_MOD - 1)) & ~(HH_DATA_MOD - 1) : 0
 217:include/linux/netdevice.h ****  *
 218:include/linux/netdevice.h ****  * We could use other alignment values, but we must maintain the
 219:include/linux/netdevice.h ****  * relationship HH alignment <= LL alignment.
 220:include/linux/netdevice.h ****  */
 221:include/linux/netdevice.h **** #define LL_RESERVED_SPACE(dev) \
 222:include/linux/netdevice.h **** 	(((dev)->hard_header_len&~(HH_DATA_MOD - 1)) + HH_DATA_MOD)
 223:include/linux/netdevice.h **** #define LL_RESERVED_SPACE_EXTRA(dev,extra) \
 224:include/linux/netdevice.h **** 	((((dev)->hard_header_len+extra)&~(HH_DATA_MOD - 1)) + HH_DATA_MOD)
 225:include/linux/netdevice.h **** 
 226:include/linux/netdevice.h **** /* These flag bits are private to the generic network queueing
 227:include/linux/netdevice.h ****  * layer, they may not be explicitly referenced by any other
 228:include/linux/netdevice.h ****  * code.
 229:include/linux/netdevice.h ****  */
 230:include/linux/netdevice.h **** 
 231:include/linux/netdevice.h **** enum netdev_state_t
 232:include/linux/netdevice.h **** {
 233:include/linux/netdevice.h **** 	__LINK_STATE_XOFF=0,
 234:include/linux/netdevice.h **** 	__LINK_STATE_START,
 235:include/linux/netdevice.h **** 	__LINK_STATE_PRESENT,
 236:include/linux/netdevice.h **** 	__LINK_STATE_SCHED,
 237:include/linux/netdevice.h **** 	__LINK_STATE_NOCARRIER,
 238:include/linux/netdevice.h **** 	__LINK_STATE_RX_SCHED,
 239:include/linux/netdevice.h **** 	__LINK_STATE_LINKWATCH_PENDING
 240:include/linux/netdevice.h **** };
 241:include/linux/netdevice.h **** 
 242:include/linux/netdevice.h **** 
 243:include/linux/netdevice.h **** /*
 244:include/linux/netdevice.h ****  * This structure holds at boot time configured netdevice settings. They
 245:include/linux/netdevice.h ****  * are then used in the device probing. 
 246:include/linux/netdevice.h ****  */
 247:include/linux/netdevice.h **** struct netdev_boot_setup {
 248:include/linux/netdevice.h **** 	char name[IFNAMSIZ];
 249:include/linux/netdevice.h **** 	struct ifmap map;
 250:include/linux/netdevice.h **** };
 251:include/linux/netdevice.h **** #define NETDEV_BOOT_SETUP_MAX 8
 252:include/linux/netdevice.h **** 
 253:include/linux/netdevice.h **** 
 254:include/linux/netdevice.h **** /*
 255:include/linux/netdevice.h ****  *	The DEVICE structure.
 256:include/linux/netdevice.h ****  *	Actually, this whole structure is a big mistake.  It mixes I/O
 257:include/linux/netdevice.h ****  *	data with strictly "high-level" data, and it has to know about
 258:include/linux/netdevice.h ****  *	almost every data structure used in the INET module.
 259:include/linux/netdevice.h ****  *
 260:include/linux/netdevice.h ****  *	FIXME: cleanup struct net_device such that network protocol info
 261:include/linux/netdevice.h ****  *	moves out.
 262:include/linux/netdevice.h ****  */
 263:include/linux/netdevice.h **** 
 264:include/linux/netdevice.h **** struct net_device
 265:include/linux/netdevice.h **** {
 266:include/linux/netdevice.h **** 
 267:include/linux/netdevice.h **** 	/*
 268:include/linux/netdevice.h **** 	 * This is the first field of the "visible" part of this structure
 269:include/linux/netdevice.h **** 	 * (i.e. as seen by users in the "Space.c" file).  It is the name
 270:include/linux/netdevice.h **** 	 * the interface.
 271:include/linux/netdevice.h **** 	 */
 272:include/linux/netdevice.h **** 	char			name[IFNAMSIZ];
GAS LISTING  			page 19


 273:include/linux/netdevice.h **** 
 274:include/linux/netdevice.h **** 	/*
 275:include/linux/netdevice.h **** 	 *	I/O specific fields
 276:include/linux/netdevice.h **** 	 *	FIXME: Merge these and struct ifmap into one
 277:include/linux/netdevice.h **** 	 */
 278:include/linux/netdevice.h **** 	unsigned long		mem_end;	/* shared mem end	*/
 279:include/linux/netdevice.h **** 	unsigned long		mem_start;	/* shared mem start	*/
 280:include/linux/netdevice.h **** 	unsigned long		base_addr;	/* device I/O address	*/
 281:include/linux/netdevice.h **** 	unsigned int		irq;		/* device IRQ number	*/
 282:include/linux/netdevice.h **** 
 283:include/linux/netdevice.h **** 	/*
 284:include/linux/netdevice.h **** 	 *	Some hardware also needs these fields, but they are not
 285:include/linux/netdevice.h **** 	 *	part of the usual set specified in Space.c.
 286:include/linux/netdevice.h **** 	 */
 287:include/linux/netdevice.h **** 
 288:include/linux/netdevice.h **** 	unsigned char		if_port;	/* Selectable AUI, TP,..*/
 289:include/linux/netdevice.h **** 	unsigned char		dma;		/* DMA channel		*/
 290:include/linux/netdevice.h **** 
 291:include/linux/netdevice.h **** 	unsigned long		state;
 292:include/linux/netdevice.h **** 
 293:include/linux/netdevice.h **** 	struct net_device	*next;
 294:include/linux/netdevice.h **** 	
 295:include/linux/netdevice.h **** 	/* The device initialization function. Called only once. */
 296:include/linux/netdevice.h **** 	int			(*init)(struct net_device *dev);
 297:include/linux/netdevice.h **** 
 298:include/linux/netdevice.h **** 	/* ------- Fields preinitialized in Space.c finish here ------- */
 299:include/linux/netdevice.h **** 
 300:include/linux/netdevice.h **** 	struct net_device	*next_sched;
 301:include/linux/netdevice.h **** 
 302:include/linux/netdevice.h **** 	/* Interface index. Unique device identifier	*/
 303:include/linux/netdevice.h **** 	int			ifindex;
 304:include/linux/netdevice.h **** 	int			iflink;
 305:include/linux/netdevice.h **** 
 306:include/linux/netdevice.h **** 
 307:include/linux/netdevice.h **** 	struct net_device_stats* (*get_stats)(struct net_device *dev);
 308:include/linux/netdevice.h **** 	struct iw_statistics*	(*get_wireless_stats)(struct net_device *dev);
 309:include/linux/netdevice.h **** 
 310:include/linux/netdevice.h **** 	/* List of functions to handle Wireless Extensions (instead of ioctl).
 311:include/linux/netdevice.h **** 	 * See <net/iw_handler.h> for details. Jean II */
 312:include/linux/netdevice.h **** 	const struct iw_handler_def *	wireless_handlers;
 313:include/linux/netdevice.h **** 	/* Instance data managed by the core of Wireless Extensions. */
 314:include/linux/netdevice.h **** 	struct iw_public_data *	wireless_data;
 315:include/linux/netdevice.h **** 
 316:include/linux/netdevice.h **** 	struct ethtool_ops *ethtool_ops;
 317:include/linux/netdevice.h **** 
 318:include/linux/netdevice.h **** 	/*
 319:include/linux/netdevice.h **** 	 * This marks the end of the "visible" part of the structure. All
 320:include/linux/netdevice.h **** 	 * fields hereafter are internal to the system, and may change at
 321:include/linux/netdevice.h **** 	 * will (read: may be cleaned up at will).
 322:include/linux/netdevice.h **** 	 */
 323:include/linux/netdevice.h **** 
 324:include/linux/netdevice.h **** 	/* These may be needed for future network-power-down code. */
 325:include/linux/netdevice.h **** 	unsigned long		trans_start;	/* Time (in jiffies) of last Tx	*/
 326:include/linux/netdevice.h **** 	unsigned long		last_rx;	/* Time of last Rx	*/
 327:include/linux/netdevice.h **** 
 328:include/linux/netdevice.h **** 	unsigned short		flags;	/* interface flags (a la BSD)	*/
 329:include/linux/netdevice.h **** 	unsigned short		gflags;
GAS LISTING  			page 20


 330:include/linux/netdevice.h ****         unsigned short          priv_flags; /* Like 'flags' but invisible to userspace. */
 331:include/linux/netdevice.h **** 	unsigned short		padded;	/* How much padding added by alloc_netdev() */
 332:include/linux/netdevice.h **** 
 333:include/linux/netdevice.h **** 	unsigned		mtu;	/* interface MTU value		*/
 334:include/linux/netdevice.h **** 	unsigned short		type;	/* interface hardware type	*/
 335:include/linux/netdevice.h **** 	unsigned short		hard_header_len;	/* hardware hdr length	*/
 336:include/linux/netdevice.h **** 	void			*priv;	/* pointer to private data	*/
 337:include/linux/netdevice.h **** 
 338:include/linux/netdevice.h **** 	struct net_device	*master; /* Pointer to master device of a group,
 339:include/linux/netdevice.h **** 					  * which this device is member of.
 340:include/linux/netdevice.h **** 					  */
 341:include/linux/netdevice.h **** 
 342:include/linux/netdevice.h **** 	/* Interface address info. */
 343:include/linux/netdevice.h **** 	unsigned char		broadcast[MAX_ADDR_LEN];	/* hw bcast add	*/
 344:include/linux/netdevice.h **** 	unsigned char		dev_addr[MAX_ADDR_LEN];	/* hw address	*/
 345:include/linux/netdevice.h **** 	unsigned char		addr_len;	/* hardware address length	*/
 346:include/linux/netdevice.h **** 	unsigned short          dev_id;		/* for shared network cards */
 347:include/linux/netdevice.h **** 
 348:include/linux/netdevice.h **** 	struct dev_mc_list	*mc_list;	/* Multicast mac addresses	*/
 349:include/linux/netdevice.h **** 	int			mc_count;	/* Number of installed mcasts	*/
 350:include/linux/netdevice.h **** 	int			promiscuity;
 351:include/linux/netdevice.h **** 	int			allmulti;
 352:include/linux/netdevice.h **** 
 353:include/linux/netdevice.h **** 	int			watchdog_timeo;
 354:include/linux/netdevice.h **** 	struct timer_list	watchdog_timer;
 355:include/linux/netdevice.h **** 
 356:include/linux/netdevice.h **** 	/* Protocol specific pointers */
 357:include/linux/netdevice.h **** 	
 358:include/linux/netdevice.h **** 	void 			*atalk_ptr;	/* AppleTalk link 	*/
 359:include/linux/netdevice.h **** 	void			*ip_ptr;	/* IPv4 specific data	*/  
 360:include/linux/netdevice.h **** 	void                    *dn_ptr;        /* DECnet specific data */
 361:include/linux/netdevice.h **** 	void                    *ip6_ptr;       /* IPv6 specific data */
 362:include/linux/netdevice.h **** 	void			*ec_ptr;	/* Econet specific data	*/
 363:include/linux/netdevice.h **** 	void			*ax25_ptr;	/* AX.25 specific data */
 364:include/linux/netdevice.h **** 
 365:include/linux/netdevice.h **** 	struct list_head	poll_list;	/* Link to poll list	*/
 366:include/linux/netdevice.h **** 	int			quota;
 367:include/linux/netdevice.h **** 	int			weight;
 368:include/linux/netdevice.h **** 
 369:include/linux/netdevice.h **** 	struct Qdisc		*qdisc;
 370:include/linux/netdevice.h **** 	struct Qdisc		*qdisc_sleeping;
 371:include/linux/netdevice.h **** 	struct Qdisc		*qdisc_ingress;
 372:include/linux/netdevice.h **** 	struct list_head	qdisc_list;
 373:include/linux/netdevice.h **** 	unsigned long		tx_queue_len;	/* Max frames per queue allowed */
 374:include/linux/netdevice.h **** 
 375:include/linux/netdevice.h **** 	/* ingress path synchronizer */
 376:include/linux/netdevice.h **** 	spinlock_t		ingress_lock;
 377:include/linux/netdevice.h **** 	/* hard_start_xmit synchronizer */
 378:include/linux/netdevice.h **** 	spinlock_t		xmit_lock;
 379:include/linux/netdevice.h **** 	/* cpu id of processor entered to hard_start_xmit or -1,
 380:include/linux/netdevice.h **** 	   if nobody entered there.
 381:include/linux/netdevice.h **** 	 */
 382:include/linux/netdevice.h **** 	int			xmit_lock_owner;
 383:include/linux/netdevice.h **** 	/* device queue lock */
 384:include/linux/netdevice.h **** 	spinlock_t		queue_lock;
 385:include/linux/netdevice.h **** 	/* Number of references to this device */
 386:include/linux/netdevice.h **** 	atomic_t		refcnt;
GAS LISTING  			page 21


 387:include/linux/netdevice.h **** 	/* delayed register/unregister */
 388:include/linux/netdevice.h **** 	struct list_head	todo_list;
 389:include/linux/netdevice.h **** 	/* device name hash chain */
 390:include/linux/netdevice.h **** 	struct hlist_node	name_hlist;
 391:include/linux/netdevice.h **** 	/* device index hash chain */
 392:include/linux/netdevice.h **** 	struct hlist_node	index_hlist;
 393:include/linux/netdevice.h **** 
 394:include/linux/netdevice.h **** 	/* register/unregister state machine */
 395:include/linux/netdevice.h **** 	enum { NETREG_UNINITIALIZED=0,
 396:include/linux/netdevice.h **** 	       NETREG_REGISTERING,	/* called register_netdevice */
 397:include/linux/netdevice.h **** 	       NETREG_REGISTERED,	/* completed register todo */
 398:include/linux/netdevice.h **** 	       NETREG_UNREGISTERING,	/* called unregister_netdevice */
 399:include/linux/netdevice.h **** 	       NETREG_UNREGISTERED,	/* completed unregister todo */
 400:include/linux/netdevice.h **** 	       NETREG_RELEASED,		/* called free_netdev */
 401:include/linux/netdevice.h **** 	} reg_state;
 402:include/linux/netdevice.h **** 
 403:include/linux/netdevice.h **** 	/* Net device features */
 404:include/linux/netdevice.h **** 	unsigned long		features;
 405:include/linux/netdevice.h **** #define NETIF_F_SG		1	/* Scatter/gather IO. */
 406:include/linux/netdevice.h **** #define NETIF_F_IP_CSUM		2	/* Can checksum only TCP/UDP over IPv4. */
 407:include/linux/netdevice.h **** #define NETIF_F_NO_CSUM		4	/* Does not require checksum. F.e. loopack. */
 408:include/linux/netdevice.h **** #define NETIF_F_HW_CSUM		8	/* Can checksum all the packets. */
 409:include/linux/netdevice.h **** #define NETIF_F_HIGHDMA		32	/* Can DMA to high memory. */
 410:include/linux/netdevice.h **** #define NETIF_F_FRAGLIST	64	/* Scatter/gather IO. */
 411:include/linux/netdevice.h **** #define NETIF_F_HW_VLAN_TX	128	/* Transmit VLAN hw acceleration */
 412:include/linux/netdevice.h **** #define NETIF_F_HW_VLAN_RX	256	/* Receive VLAN hw acceleration */
 413:include/linux/netdevice.h **** #define NETIF_F_HW_VLAN_FILTER	512	/* Receive filtering on VLAN */
 414:include/linux/netdevice.h **** #define NETIF_F_VLAN_CHALLENGED	1024	/* Device cannot handle VLAN packets */
 415:include/linux/netdevice.h **** #define NETIF_F_TSO		2048	/* Can offload TCP/IP segmentation */
 416:include/linux/netdevice.h **** #define NETIF_F_LLTX		4096	/* LockLess TX */
 417:include/linux/netdevice.h **** 
 418:include/linux/netdevice.h **** 	/* Called after device is detached from network. */
 419:include/linux/netdevice.h **** 	void			(*uninit)(struct net_device *dev);
 420:include/linux/netdevice.h **** 	/* Called after last user reference disappears. */
 421:include/linux/netdevice.h **** 	void			(*destructor)(struct net_device *dev);
 422:include/linux/netdevice.h **** 
 423:include/linux/netdevice.h **** 	/* Pointers to interface service routines.	*/
 424:include/linux/netdevice.h **** 	int			(*open)(struct net_device *dev);
 425:include/linux/netdevice.h **** 	int			(*stop)(struct net_device *dev);
 426:include/linux/netdevice.h **** 	int			(*hard_start_xmit) (struct sk_buff *skb,
 427:include/linux/netdevice.h **** 						    struct net_device *dev);
 428:include/linux/netdevice.h **** #define HAVE_NETDEV_POLL
 429:include/linux/netdevice.h **** 	int			(*poll) (struct net_device *dev, int *quota);
 430:include/linux/netdevice.h **** 	int			(*hard_header) (struct sk_buff *skb,
 431:include/linux/netdevice.h **** 						struct net_device *dev,
 432:include/linux/netdevice.h **** 						unsigned short type,
 433:include/linux/netdevice.h **** 						void *daddr,
 434:include/linux/netdevice.h **** 						void *saddr,
 435:include/linux/netdevice.h **** 						unsigned len);
 436:include/linux/netdevice.h **** 	int			(*rebuild_header)(struct sk_buff *skb);
 437:include/linux/netdevice.h **** #define HAVE_MULTICAST			 
 438:include/linux/netdevice.h **** 	void			(*set_multicast_list)(struct net_device *dev);
 439:include/linux/netdevice.h **** #define HAVE_SET_MAC_ADDR  		 
 440:include/linux/netdevice.h **** 	int			(*set_mac_address)(struct net_device *dev,
 441:include/linux/netdevice.h **** 						   void *addr);
 442:include/linux/netdevice.h **** #define HAVE_PRIVATE_IOCTL
 443:include/linux/netdevice.h **** 	int			(*do_ioctl)(struct net_device *dev,
GAS LISTING  			page 22


 444:include/linux/netdevice.h **** 					    struct ifreq *ifr, int cmd);
 445:include/linux/netdevice.h **** #define HAVE_SET_CONFIG
 446:include/linux/netdevice.h **** 	int			(*set_config)(struct net_device *dev,
 447:include/linux/netdevice.h **** 					      struct ifmap *map);
 448:include/linux/netdevice.h **** #define HAVE_HEADER_CACHE
 449:include/linux/netdevice.h **** 	int			(*hard_header_cache)(struct neighbour *neigh,
 450:include/linux/netdevice.h **** 						     struct hh_cache *hh);
 451:include/linux/netdevice.h **** 	void			(*header_cache_update)(struct hh_cache *hh,
 452:include/linux/netdevice.h **** 						       struct net_device *dev,
 453:include/linux/netdevice.h **** 						       unsigned char *  haddr);
 454:include/linux/netdevice.h **** #define HAVE_CHANGE_MTU
 455:include/linux/netdevice.h **** 	int			(*change_mtu)(struct net_device *dev, int new_mtu);
 456:include/linux/netdevice.h **** 
 457:include/linux/netdevice.h **** #define HAVE_TX_TIMEOUT
 458:include/linux/netdevice.h **** 	void			(*tx_timeout) (struct net_device *dev);
 459:include/linux/netdevice.h **** 
 460:include/linux/netdevice.h **** 	void			(*vlan_rx_register)(struct net_device *dev,
 461:include/linux/netdevice.h **** 						    struct vlan_group *grp);
 462:include/linux/netdevice.h **** 	void			(*vlan_rx_add_vid)(struct net_device *dev,
 463:include/linux/netdevice.h **** 						   unsigned short vid);
 464:include/linux/netdevice.h **** 	void			(*vlan_rx_kill_vid)(struct net_device *dev,
 465:include/linux/netdevice.h **** 						    unsigned short vid);
 466:include/linux/netdevice.h **** 
 467:include/linux/netdevice.h **** 	int			(*hard_header_parse)(struct sk_buff *skb,
 468:include/linux/netdevice.h **** 						     unsigned char *haddr);
 469:include/linux/netdevice.h **** 	int			(*neigh_setup)(struct net_device *dev, struct neigh_parms *);
 470:include/linux/netdevice.h **** #ifdef CONFIG_NETPOLL
 471:include/linux/netdevice.h **** 	struct netpoll		*np;
 472:include/linux/netdevice.h **** #endif
 473:include/linux/netdevice.h **** #ifdef CONFIG_NET_POLL_CONTROLLER
 474:include/linux/netdevice.h **** 	void                    (*poll_controller)(struct net_device *dev);
 475:include/linux/netdevice.h **** #endif
 476:include/linux/netdevice.h **** 
 477:include/linux/netdevice.h **** 	/* bridge stuff */
 478:include/linux/netdevice.h **** 	struct net_bridge_port	*br_port;
 479:include/linux/netdevice.h **** 
 480:include/linux/netdevice.h **** #ifdef CONFIG_NET_DIVERT
 481:include/linux/netdevice.h **** 	/* this will get initialized at each interface type init routine */
 482:include/linux/netdevice.h **** 	struct divert_blk	*divert;
 483:include/linux/netdevice.h **** #endif /* CONFIG_NET_DIVERT */
 484:include/linux/netdevice.h **** 
 485:include/linux/netdevice.h **** 	/* class/net/name entry */
 486:include/linux/netdevice.h **** 	struct class_device	class_dev;
 487:include/linux/netdevice.h **** };
 488:include/linux/netdevice.h **** 
 489:include/linux/netdevice.h **** #define	NETDEV_ALIGN		32
 490:include/linux/netdevice.h **** #define	NETDEV_ALIGN_CONST	(NETDEV_ALIGN - 1)
 491:include/linux/netdevice.h **** 
 492:include/linux/netdevice.h **** static inline void *netdev_priv(struct net_device *dev)
 493:include/linux/netdevice.h **** {
 494:include/linux/netdevice.h **** 	return (char *)dev + ((sizeof(struct net_device)
 495:include/linux/netdevice.h **** 					+ NETDEV_ALIGN_CONST)
 496:include/linux/netdevice.h **** 				& ~NETDEV_ALIGN_CONST);
 497:include/linux/netdevice.h **** }
 498:include/linux/netdevice.h **** 
 499:include/linux/netdevice.h **** #define SET_MODULE_OWNER(dev) do { } while (0)
 500:include/linux/netdevice.h **** /* Set the sysfs physical device reference for the network logical device
GAS LISTING  			page 23


 501:include/linux/netdevice.h ****  * if set prior to registration will cause a symlink during initialization.
 502:include/linux/netdevice.h ****  */
 503:include/linux/netdevice.h **** #define SET_NETDEV_DEV(net, pdev)	((net)->class_dev.dev = (pdev))
 504:include/linux/netdevice.h **** 
 505:include/linux/netdevice.h **** struct packet_type {
 506:include/linux/netdevice.h **** 	__be16			type;	/* This is really htons(ether_type).	*/
 507:include/linux/netdevice.h **** 	struct net_device		*dev;	/* NULL is wildcarded here		*/
 508:include/linux/netdevice.h **** 	int			(*func) (struct sk_buff *, struct net_device *,
 509:include/linux/netdevice.h **** 					 struct packet_type *);
 510:include/linux/netdevice.h **** 	void			*af_packet_priv;
 511:include/linux/netdevice.h **** 	struct list_head	list;
 512:include/linux/netdevice.h **** };
 513:include/linux/netdevice.h **** 
 514:include/linux/netdevice.h **** #include <linux/interrupt.h>
 515:include/linux/netdevice.h **** #include <linux/notifier.h>
 516:include/linux/netdevice.h **** 
 517:include/linux/netdevice.h **** extern struct net_device		loopback_dev;		/* The loopback */
 518:include/linux/netdevice.h **** extern struct net_device		*dev_base;		/* All devices */
 519:include/linux/netdevice.h **** extern rwlock_t				dev_base_lock;		/* Device list lock */
 520:include/linux/netdevice.h **** 
 521:include/linux/netdevice.h **** extern int 			netdev_boot_setup_check(struct net_device *dev);
 522:include/linux/netdevice.h **** extern unsigned long		netdev_boot_base(const char *prefix, int unit);
 523:include/linux/netdevice.h **** extern struct net_device    *dev_getbyhwaddr(unsigned short type, char *hwaddr);
 524:include/linux/netdevice.h **** extern struct net_device *dev_getfirstbyhwtype(unsigned short type);
 525:include/linux/netdevice.h **** extern void		dev_add_pack(struct packet_type *pt);
 526:include/linux/netdevice.h **** extern void		dev_remove_pack(struct packet_type *pt);
 527:include/linux/netdevice.h **** extern void		__dev_remove_pack(struct packet_type *pt);
 528:include/linux/netdevice.h **** 
 529:include/linux/netdevice.h **** extern struct net_device	*dev_get_by_flags(unsigned short flags,
 530:include/linux/netdevice.h **** 						  unsigned short mask);
 531:include/linux/netdevice.h **** extern struct net_device	*dev_get_by_name(const char *name);
 532:include/linux/netdevice.h **** extern struct net_device	*__dev_get_by_name(const char *name);
 533:include/linux/netdevice.h **** extern int		dev_alloc_name(struct net_device *dev, const char *name);
 534:include/linux/netdevice.h **** extern int		dev_open(struct net_device *dev);
 535:include/linux/netdevice.h **** extern int		dev_close(struct net_device *dev);
 536:include/linux/netdevice.h **** extern int		dev_queue_xmit(struct sk_buff *skb);
 537:include/linux/netdevice.h **** extern int		register_netdevice(struct net_device *dev);
 538:include/linux/netdevice.h **** extern int		unregister_netdevice(struct net_device *dev);
 539:include/linux/netdevice.h **** extern void		free_netdev(struct net_device *dev);
 540:include/linux/netdevice.h **** extern void		synchronize_net(void);
 541:include/linux/netdevice.h **** extern int 		register_netdevice_notifier(struct notifier_block *nb);
 542:include/linux/netdevice.h **** extern int		unregister_netdevice_notifier(struct notifier_block *nb);
 543:include/linux/netdevice.h **** extern int		call_netdevice_notifiers(unsigned long val, void *v);
 544:include/linux/netdevice.h **** extern struct net_device	*dev_get_by_index(int ifindex);
 545:include/linux/netdevice.h **** extern struct net_device	*__dev_get_by_index(int ifindex);
 546:include/linux/netdevice.h **** extern int		dev_restart(struct net_device *dev);
 547:include/linux/netdevice.h **** #ifdef CONFIG_NETPOLL_TRAP
 548:include/linux/netdevice.h **** extern int		netpoll_trap(void);
 549:include/linux/netdevice.h **** #endif
 550:include/linux/netdevice.h **** 
 551:include/linux/netdevice.h **** typedef int gifconf_func_t(struct net_device * dev, char __user * bufptr, int len);
 552:include/linux/netdevice.h **** extern int		register_gifconf(unsigned int family, gifconf_func_t * gifconf);
 553:include/linux/netdevice.h **** static inline int unregister_gifconf(unsigned int family)
 554:include/linux/netdevice.h **** {
 555:include/linux/netdevice.h **** 	return register_gifconf(family, NULL);
 556:include/linux/netdevice.h **** }
 557:include/linux/netdevice.h **** 
GAS LISTING  			page 24


 558:include/linux/netdevice.h **** /*
 559:include/linux/netdevice.h ****  * Incoming packets are placed on per-cpu queues so that
 560:include/linux/netdevice.h ****  * no locking is needed.
 561:include/linux/netdevice.h ****  */
 562:include/linux/netdevice.h **** 
 563:include/linux/netdevice.h **** struct softnet_data
 564:include/linux/netdevice.h **** {
 565:include/linux/netdevice.h **** 	int			throttle;
 566:include/linux/netdevice.h **** 	int			cng_level;
 567:include/linux/netdevice.h **** 	int			avg_blog;
 568:include/linux/netdevice.h **** 	struct sk_buff_head	input_pkt_queue;
 569:include/linux/netdevice.h **** 	struct list_head	poll_list;
 570:include/linux/netdevice.h **** 	struct net_device	*output_queue;
 571:include/linux/netdevice.h **** 	struct sk_buff		*completion_queue;
 572:include/linux/netdevice.h **** 
 573:include/linux/netdevice.h **** 	struct net_device	backlog_dev;	/* Sorry. 8) */
 574:include/linux/netdevice.h **** };
 575:include/linux/netdevice.h **** 
 576:include/linux/netdevice.h **** DECLARE_PER_CPU(struct softnet_data,softnet_data);
 577:include/linux/netdevice.h **** 
 578:include/linux/netdevice.h **** #define HAVE_NETIF_QUEUE
 579:include/linux/netdevice.h **** 
 580:include/linux/netdevice.h **** static inline void __netif_schedule(struct net_device *dev)
 581:include/linux/netdevice.h **** {
 582:include/linux/netdevice.h **** 	if (!test_and_set_bit(__LINK_STATE_SCHED, &dev->state)) {
 583:include/linux/netdevice.h **** 		unsigned long flags;
 584:include/linux/netdevice.h **** 		struct softnet_data *sd;
 585:include/linux/netdevice.h **** 
 586:include/linux/netdevice.h **** 		local_irq_save(flags);
 587:include/linux/netdevice.h **** 		sd = &__get_cpu_var(softnet_data);
 588:include/linux/netdevice.h **** 		dev->next_sched = sd->output_queue;
 589:include/linux/netdevice.h **** 		sd->output_queue = dev;
 590:include/linux/netdevice.h **** 		raise_softirq_irqoff(NET_TX_SOFTIRQ);
 591:include/linux/netdevice.h **** 		local_irq_restore(flags);
 592:include/linux/netdevice.h **** 	}
 593:include/linux/netdevice.h **** }
 594:include/linux/netdevice.h **** 
 595:include/linux/netdevice.h **** static inline void netif_schedule(struct net_device *dev)
 596:include/linux/netdevice.h **** {
 597:include/linux/netdevice.h **** 	if (!test_bit(__LINK_STATE_XOFF, &dev->state))
 598:include/linux/netdevice.h **** 		__netif_schedule(dev);
 599:include/linux/netdevice.h **** }
 600:include/linux/netdevice.h **** 
 601:include/linux/netdevice.h **** static inline void netif_start_queue(struct net_device *dev)
 602:include/linux/netdevice.h **** {
 603:include/linux/netdevice.h **** 	clear_bit(__LINK_STATE_XOFF, &dev->state);
 604:include/linux/netdevice.h **** }
 605:include/linux/netdevice.h **** 
 606:include/linux/netdevice.h **** static inline void netif_wake_queue(struct net_device *dev)
 607:include/linux/netdevice.h **** {
 608:include/linux/netdevice.h **** #ifdef CONFIG_NETPOLL_TRAP
 609:include/linux/netdevice.h **** 	if (netpoll_trap())
 610:include/linux/netdevice.h **** 		return;
 611:include/linux/netdevice.h **** #endif
 612:include/linux/netdevice.h **** 	if (test_and_clear_bit(__LINK_STATE_XOFF, &dev->state))
 613:include/linux/netdevice.h **** 		__netif_schedule(dev);
 614:include/linux/netdevice.h **** }
GAS LISTING  			page 25


 615:include/linux/netdevice.h **** 
 616:include/linux/netdevice.h **** static inline void netif_stop_queue(struct net_device *dev)
 617:include/linux/netdevice.h **** {
 618:include/linux/netdevice.h **** #ifdef CONFIG_NETPOLL_TRAP
 619:include/linux/netdevice.h **** 	if (netpoll_trap())
 620:include/linux/netdevice.h **** 		return;
 621:include/linux/netdevice.h **** #endif
 622:include/linux/netdevice.h **** 	set_bit(__LINK_STATE_XOFF, &dev->state);
 623:include/linux/netdevice.h **** }
 624:include/linux/netdevice.h **** 
 625:include/linux/netdevice.h **** static inline int netif_queue_stopped(const struct net_device *dev)
 626:include/linux/netdevice.h **** {
 627:include/linux/netdevice.h **** 	return test_bit(__LINK_STATE_XOFF, &dev->state);
 628:include/linux/netdevice.h **** }
 629:include/linux/netdevice.h **** 
 630:include/linux/netdevice.h **** static inline int netif_running(const struct net_device *dev)
 631:include/linux/netdevice.h **** {
 632:include/linux/netdevice.h **** 	return test_bit(__LINK_STATE_START, &dev->state);
 633:include/linux/netdevice.h **** }
 634:include/linux/netdevice.h **** 
 635:include/linux/netdevice.h **** 
 636:include/linux/netdevice.h **** /* Use this variant when it is known for sure that it
 637:include/linux/netdevice.h ****  * is executing from interrupt context.
 638:include/linux/netdevice.h ****  */
 639:include/linux/netdevice.h **** static inline void dev_kfree_skb_irq(struct sk_buff *skb)
 640:include/linux/netdevice.h **** {
 641:include/linux/netdevice.h **** 	if (atomic_dec_and_test(&skb->users)) {
 642:include/linux/netdevice.h **** 		struct softnet_data *sd;
 643:include/linux/netdevice.h **** 		unsigned long flags;
 644:include/linux/netdevice.h **** 
 645:include/linux/netdevice.h **** 		local_irq_save(flags);
 646:include/linux/netdevice.h **** 		sd = &__get_cpu_var(softnet_data);
 647:include/linux/netdevice.h **** 		skb->next = sd->completion_queue;
 648:include/linux/netdevice.h **** 		sd->completion_queue = skb;
 649:include/linux/netdevice.h **** 		raise_softirq_irqoff(NET_TX_SOFTIRQ);
 650:include/linux/netdevice.h **** 		local_irq_restore(flags);
 651:include/linux/netdevice.h **** 	}
 652:include/linux/netdevice.h **** }
 653:include/linux/netdevice.h **** 
 654:include/linux/netdevice.h **** /* Use this variant in places where it could be invoked
 655:include/linux/netdevice.h ****  * either from interrupt or non-interrupt context.
 656:include/linux/netdevice.h ****  */
 657:include/linux/netdevice.h **** static inline void dev_kfree_skb_any(struct sk_buff *skb)
 658:include/linux/netdevice.h **** {
 659:include/linux/netdevice.h **** 	if (in_irq() || irqs_disabled())
 217              	.loc 5 659 0
 218              	
 219 00ec 9C58     	pushfl
 220              	
 221              	.LBE14:
 222 00ee F6C402   	testb $2,%ah
 223 00f1 752B     	jne .L20
 224              	.L21:
 225              	.LBB15:
 226              	.LBB16:
 227              	.LBB17:
 228              	.LBB18:
GAS LISTING  			page 26


 118:include/asm/atomic.h **** 		LOCK "decl %0"
 119:include/asm/atomic.h **** 		:"=m" (v->counter)
 120:include/asm/atomic.h **** 		:"m" (v->counter));
 121:include/asm/atomic.h **** }
 122:include/asm/atomic.h **** 
 123:include/asm/atomic.h **** /**
 124:include/asm/atomic.h ****  * atomic_dec_and_test - decrement and test
 125:include/asm/atomic.h ****  * @v: pointer of type atomic_t
 126:include/asm/atomic.h ****  * 
 127:include/asm/atomic.h ****  * Atomically decrements @v by 1 and
 128:include/asm/atomic.h ****  * returns true if the result is 0, or false for all other
 129:include/asm/atomic.h ****  * cases.
 130:include/asm/atomic.h ****  */ 
 131:include/asm/atomic.h **** static __inline__ int atomic_dec_and_test(atomic_t *v)
 132:include/asm/atomic.h **** {
 133:include/asm/atomic.h **** 	unsigned char c;
 134:include/asm/atomic.h **** 
 135:include/asm/atomic.h **** 	__asm__ __volatile__(
 229              	.loc 3 135 0
 230              	
 231 00f3 FF8AA000 	decl 160(%edx)
 231      00000F94 
 231      C0
 232              	
 233              	.LBE18:
 234              	.LBE17:
 235              	.loc 3 132 0
 236 00fc 84C0     	testb %al,%al
 237 00fe 743D     	je .L18
 238              	.LBB19:
 239              	.loc 5 645 0
 240              	
 241 0100 9C5BFA   	pushfl
 242              	.loc 5 647 0
 243              	
 244 0103 A1240000 	movl per_cpu__softnet_data+36,%eax
 244      00
 245 0108 8902     	movl %eax,(%edx)
 246              	.loc 5 649 0
 247 010a B8020000 	movl $2,%eax
 247      00
 248              	.loc 5 648 0
 249 010f 89152400 	movl %edx,per_cpu__softnet_data+36
 249      0000
 250              	.loc 5 649 0
 251 0115 E8FCFFFF 	call raise_softirq_irqoff
 251      FF
 252              	.loc 5 650 0
 253              	
 254 011a 539D     	pushl %ebx
 255              	
 256              	.LBE19:
 257              	.LBE16:
 258              	.LBE15:
 259 011c EB1F     	jmp .L18
 260              	.L20:
 261              	.LBB20:
GAS LISTING  			page 27


 262              	.LBB21:
 263              	.file 6 "include/linux/skbuff.h"
   1:include/linux/skbuff.h **** /*
   2:include/linux/skbuff.h ****  *	Definitions for the 'struct sk_buff' memory handlers.
   3:include/linux/skbuff.h ****  *
   4:include/linux/skbuff.h ****  *	Authors:
   5:include/linux/skbuff.h ****  *		Alan Cox, <gw4pts@gw4pts.ampr.org>
   6:include/linux/skbuff.h ****  *		Florian La Roche, <rzsfl@rz.uni-sb.de>
   7:include/linux/skbuff.h ****  *
   8:include/linux/skbuff.h ****  *	This program is free software; you can redistribute it and/or
   9:include/linux/skbuff.h ****  *	modify it under the terms of the GNU General Public License
  10:include/linux/skbuff.h ****  *	as published by the Free Software Foundation; either version
  11:include/linux/skbuff.h ****  *	2 of the License, or (at your option) any later version.
  12:include/linux/skbuff.h ****  */
  13:include/linux/skbuff.h **** 
  14:include/linux/skbuff.h **** #ifndef _LINUX_SKBUFF_H
  15:include/linux/skbuff.h **** #define _LINUX_SKBUFF_H
  16:include/linux/skbuff.h **** 
  17:include/linux/skbuff.h **** #include <linux/config.h>
  18:include/linux/skbuff.h **** #include <linux/kernel.h>
  19:include/linux/skbuff.h **** #include <linux/compiler.h>
  20:include/linux/skbuff.h **** #include <linux/time.h>
  21:include/linux/skbuff.h **** #include <linux/cache.h>
  22:include/linux/skbuff.h **** 
  23:include/linux/skbuff.h **** #include <asm/atomic.h>
  24:include/linux/skbuff.h **** #include <asm/types.h>
  25:include/linux/skbuff.h **** #include <linux/spinlock.h>
  26:include/linux/skbuff.h **** #include <linux/mm.h>
  27:include/linux/skbuff.h **** #include <linux/highmem.h>
  28:include/linux/skbuff.h **** #include <linux/poll.h>
  29:include/linux/skbuff.h **** #include <linux/net.h>
  30:include/linux/skbuff.h **** #include <net/checksum.h>
  31:include/linux/skbuff.h **** 
  32:include/linux/skbuff.h **** #define HAVE_ALLOC_SKB		/* For the drivers to know */
  33:include/linux/skbuff.h **** #define HAVE_ALIGNABLE_SKB	/* Ditto 8)		   */
  34:include/linux/skbuff.h **** #define SLAB_SKB 		/* Slabified skbuffs 	   */
  35:include/linux/skbuff.h **** 
  36:include/linux/skbuff.h **** #define CHECKSUM_NONE 0
  37:include/linux/skbuff.h **** #define CHECKSUM_HW 1
  38:include/linux/skbuff.h **** #define CHECKSUM_UNNECESSARY 2
  39:include/linux/skbuff.h **** 
  40:include/linux/skbuff.h **** #define SKB_DATA_ALIGN(X)	(((X) + (SMP_CACHE_BYTES - 1)) & \
  41:include/linux/skbuff.h **** 				 ~(SMP_CACHE_BYTES - 1))
  42:include/linux/skbuff.h **** #define SKB_MAX_ORDER(X, ORDER)	(((PAGE_SIZE << (ORDER)) - (X) - \
  43:include/linux/skbuff.h **** 				  sizeof(struct skb_shared_info)) & \
  44:include/linux/skbuff.h **** 				  ~(SMP_CACHE_BYTES - 1))
  45:include/linux/skbuff.h **** #define SKB_MAX_HEAD(X)		(SKB_MAX_ORDER((X), 0))
  46:include/linux/skbuff.h **** #define SKB_MAX_ALLOC		(SKB_MAX_ORDER(0, 2))
  47:include/linux/skbuff.h **** 
  48:include/linux/skbuff.h **** /* A. Checksumming of received packets by device.
  49:include/linux/skbuff.h ****  *
  50:include/linux/skbuff.h ****  *	NONE: device failed to checksum this packet.
  51:include/linux/skbuff.h ****  *		skb->csum is undefined.
  52:include/linux/skbuff.h ****  *
  53:include/linux/skbuff.h ****  *	UNNECESSARY: device parsed packet and wouldbe verified checksum.
  54:include/linux/skbuff.h ****  *		skb->csum is undefined.
  55:include/linux/skbuff.h ****  *	      It is bad option, but, unfortunately, many of vendors do this.
GAS LISTING  			page 28


  56:include/linux/skbuff.h ****  *	      Apparently with secret goal to sell you new device, when you
  57:include/linux/skbuff.h ****  *	      will add new protocol to your host. F.e. IPv6. 8)
  58:include/linux/skbuff.h ****  *
  59:include/linux/skbuff.h ****  *	HW: the most generic way. Device supplied checksum of _all_
  60:include/linux/skbuff.h ****  *	    the packet as seen by netif_rx in skb->csum.
  61:include/linux/skbuff.h ****  *	    NOTE: Even if device supports only some protocols, but
  62:include/linux/skbuff.h ****  *	    is able to produce some skb->csum, it MUST use HW,
  63:include/linux/skbuff.h ****  *	    not UNNECESSARY.
  64:include/linux/skbuff.h ****  *
  65:include/linux/skbuff.h ****  * B. Checksumming on output.
  66:include/linux/skbuff.h ****  *
  67:include/linux/skbuff.h ****  *	NONE: skb is checksummed by protocol or csum is not required.
  68:include/linux/skbuff.h ****  *
  69:include/linux/skbuff.h ****  *	HW: device is required to csum packet as seen by hard_start_xmit
  70:include/linux/skbuff.h ****  *	from skb->h.raw to the end and to record the checksum
  71:include/linux/skbuff.h ****  *	at skb->h.raw+skb->csum.
  72:include/linux/skbuff.h ****  *
  73:include/linux/skbuff.h ****  *	Device must show its capabilities in dev->features, set
  74:include/linux/skbuff.h ****  *	at device setup time.
  75:include/linux/skbuff.h ****  *	NETIF_F_HW_CSUM	- it is clever device, it is able to checksum
  76:include/linux/skbuff.h ****  *			  everything.
  77:include/linux/skbuff.h ****  *	NETIF_F_NO_CSUM - loopback or reliable single hop media.
  78:include/linux/skbuff.h ****  *	NETIF_F_IP_CSUM - device is dumb. It is able to csum only
  79:include/linux/skbuff.h ****  *			  TCP/UDP over IPv4. Sigh. Vendors like this
  80:include/linux/skbuff.h ****  *			  way by an unknown reason. Though, see comment above
  81:include/linux/skbuff.h ****  *			  about CHECKSUM_UNNECESSARY. 8)
  82:include/linux/skbuff.h ****  *
  83:include/linux/skbuff.h ****  *	Any questions? No questions, good. 		--ANK
  84:include/linux/skbuff.h ****  */
  85:include/linux/skbuff.h **** 
  86:include/linux/skbuff.h **** struct net_device;
  87:include/linux/skbuff.h **** 
  88:include/linux/skbuff.h **** #ifdef CONFIG_NETFILTER
  89:include/linux/skbuff.h **** struct nf_conntrack {
  90:include/linux/skbuff.h **** 	atomic_t use;
  91:include/linux/skbuff.h **** 	void (*destroy)(struct nf_conntrack *);
  92:include/linux/skbuff.h **** };
  93:include/linux/skbuff.h **** 
  94:include/linux/skbuff.h **** #ifdef CONFIG_BRIDGE_NETFILTER
  95:include/linux/skbuff.h **** struct nf_bridge_info {
  96:include/linux/skbuff.h **** 	atomic_t use;
  97:include/linux/skbuff.h **** 	struct net_device *physindev;
  98:include/linux/skbuff.h **** 	struct net_device *physoutdev;
  99:include/linux/skbuff.h **** #if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)
 100:include/linux/skbuff.h **** 	struct net_device *netoutdev;
 101:include/linux/skbuff.h **** #endif
 102:include/linux/skbuff.h **** 	unsigned int mask;
 103:include/linux/skbuff.h **** 	unsigned long data[32 / sizeof(unsigned long)];
 104:include/linux/skbuff.h **** };
 105:include/linux/skbuff.h **** #endif
 106:include/linux/skbuff.h **** 
 107:include/linux/skbuff.h **** #endif
 108:include/linux/skbuff.h **** 
 109:include/linux/skbuff.h **** struct sk_buff_head {
 110:include/linux/skbuff.h **** 	/* These two members must be first. */
 111:include/linux/skbuff.h **** 	struct sk_buff	*next;
 112:include/linux/skbuff.h **** 	struct sk_buff	*prev;
GAS LISTING  			page 29


 113:include/linux/skbuff.h **** 
 114:include/linux/skbuff.h **** 	__u32		qlen;
 115:include/linux/skbuff.h **** 	spinlock_t	lock;
 116:include/linux/skbuff.h **** };
 117:include/linux/skbuff.h **** 
 118:include/linux/skbuff.h **** struct sk_buff;
 119:include/linux/skbuff.h **** 
 120:include/linux/skbuff.h **** /* To allow 64K frame to be packed as single skb without frag_list */
 121:include/linux/skbuff.h **** #define MAX_SKB_FRAGS (65536/PAGE_SIZE + 2)
 122:include/linux/skbuff.h **** 
 123:include/linux/skbuff.h **** typedef struct skb_frag_struct skb_frag_t;
 124:include/linux/skbuff.h **** 
 125:include/linux/skbuff.h **** struct skb_frag_struct {
 126:include/linux/skbuff.h **** 	struct page *page;
 127:include/linux/skbuff.h **** 	__u16 page_offset;
 128:include/linux/skbuff.h **** 	__u16 size;
 129:include/linux/skbuff.h **** };
 130:include/linux/skbuff.h **** 
 131:include/linux/skbuff.h **** /* This data is invariant across clones and lives at
 132:include/linux/skbuff.h ****  * the end of the header data, ie. at skb->end.
 133:include/linux/skbuff.h ****  */
 134:include/linux/skbuff.h **** struct skb_shared_info {
 135:include/linux/skbuff.h **** 	atomic_t	dataref;
 136:include/linux/skbuff.h **** 	unsigned int	nr_frags;
 137:include/linux/skbuff.h **** 	unsigned short	tso_size;
 138:include/linux/skbuff.h **** 	unsigned short	tso_segs;
 139:include/linux/skbuff.h **** 	struct sk_buff	*frag_list;
 140:include/linux/skbuff.h **** 	skb_frag_t	frags[MAX_SKB_FRAGS];
 141:include/linux/skbuff.h **** };
 142:include/linux/skbuff.h **** 
 143:include/linux/skbuff.h **** /* We divide dataref into two halves.  The higher 16 bits hold references
 144:include/linux/skbuff.h ****  * to the payload part of skb->data.  The lower 16 bits hold references to
 145:include/linux/skbuff.h ****  * the entire skb->data.  It is up to the users of the skb to agree on
 146:include/linux/skbuff.h ****  * where the payload starts.
 147:include/linux/skbuff.h ****  *
 148:include/linux/skbuff.h ****  * All users must obey the rule that the skb->data reference count must be
 149:include/linux/skbuff.h ****  * greater than or equal to the payload reference count.
 150:include/linux/skbuff.h ****  *
 151:include/linux/skbuff.h ****  * Holding a reference to the payload part means that the user does not
 152:include/linux/skbuff.h ****  * care about modifications to the header part of skb->data.
 153:include/linux/skbuff.h ****  */
 154:include/linux/skbuff.h **** #define SKB_DATAREF_SHIFT 16
 155:include/linux/skbuff.h **** #define SKB_DATAREF_MASK ((1 << SKB_DATAREF_SHIFT) - 1)
 156:include/linux/skbuff.h **** 
 157:include/linux/skbuff.h **** /** 
 158:include/linux/skbuff.h ****  *	struct sk_buff - socket buffer
 159:include/linux/skbuff.h ****  *	@next: Next buffer in list
 160:include/linux/skbuff.h ****  *	@prev: Previous buffer in list
 161:include/linux/skbuff.h ****  *	@list: List we are on
 162:include/linux/skbuff.h ****  *	@sk: Socket we are owned by
 163:include/linux/skbuff.h ****  *	@stamp: Time we arrived
 164:include/linux/skbuff.h ****  *	@dev: Device we arrived on/are leaving by
 165:include/linux/skbuff.h ****  *	@input_dev: Device we arrived on
 166:include/linux/skbuff.h ****  *      @real_dev: The real device we are using
 167:include/linux/skbuff.h ****  *	@h: Transport layer header
 168:include/linux/skbuff.h ****  *	@nh: Network layer header
 169:include/linux/skbuff.h ****  *	@mac: Link layer header
GAS LISTING  			page 30


 170:include/linux/skbuff.h ****  *	@dst: destination entry
 171:include/linux/skbuff.h ****  *	@sp: the security path, used for xfrm
 172:include/linux/skbuff.h ****  *	@cb: Control buffer. Free for use by every layer. Put private vars here
 173:include/linux/skbuff.h ****  *	@len: Length of actual data
 174:include/linux/skbuff.h ****  *	@data_len: Data length
 175:include/linux/skbuff.h ****  *	@mac_len: Length of link layer header
 176:include/linux/skbuff.h ****  *	@csum: Checksum
 177:include/linux/skbuff.h ****  *	@local_df: allow local fragmentation
 178:include/linux/skbuff.h ****  *	@cloned: Head may be cloned (check refcnt to be sure)
 179:include/linux/skbuff.h ****  *	@nohdr: Payload reference only, must not modify header
 180:include/linux/skbuff.h ****  *	@pkt_type: Packet class
 181:include/linux/skbuff.h ****  *	@ip_summed: Driver fed us an IP checksum
 182:include/linux/skbuff.h ****  *	@priority: Packet queueing priority
 183:include/linux/skbuff.h ****  *	@users: User count - see {datagram,tcp}.c
 184:include/linux/skbuff.h ****  *	@protocol: Packet protocol from driver
 185:include/linux/skbuff.h ****  *	@security: Security level of packet
 186:include/linux/skbuff.h ****  *	@truesize: Buffer size 
 187:include/linux/skbuff.h ****  *	@head: Head of buffer
 188:include/linux/skbuff.h ****  *	@data: Data head pointer
 189:include/linux/skbuff.h ****  *	@tail: Tail pointer
 190:include/linux/skbuff.h ****  *	@end: End pointer
 191:include/linux/skbuff.h ****  *	@destructor: Destruct function
 192:include/linux/skbuff.h ****  *	@nfmark: Can be used for communication between hooks
 193:include/linux/skbuff.h ****  *	@nfcache: Cache info
 194:include/linux/skbuff.h ****  *	@nfct: Associated connection, if any
 195:include/linux/skbuff.h ****  *	@nfctinfo: Relationship of this skb to the connection
 196:include/linux/skbuff.h ****  *	@nf_debug: Netfilter debugging
 197:include/linux/skbuff.h ****  *	@nf_bridge: Saved data about a bridged frame - see br_netfilter.c
 198:include/linux/skbuff.h ****  *      @private: Data which is private to the HIPPI implementation
 199:include/linux/skbuff.h ****  *	@tc_index: Traffic control index
 200:include/linux/skbuff.h ****  *	@tc_verd: traffic control verdict
 201:include/linux/skbuff.h ****  *	@tc_classid: traffic control classid
 202:include/linux/skbuff.h ****  */
 203:include/linux/skbuff.h **** 
 204:include/linux/skbuff.h **** struct sk_buff {
 205:include/linux/skbuff.h **** 	/* These two members must be first. */
 206:include/linux/skbuff.h **** 	struct sk_buff		*next;
 207:include/linux/skbuff.h **** 	struct sk_buff		*prev;
 208:include/linux/skbuff.h **** 
 209:include/linux/skbuff.h **** 	struct sk_buff_head	*list;
 210:include/linux/skbuff.h **** 	struct sock		*sk;
 211:include/linux/skbuff.h **** 	struct timeval		stamp;
 212:include/linux/skbuff.h **** 	struct net_device	*dev;
 213:include/linux/skbuff.h **** 	struct net_device	*input_dev;
 214:include/linux/skbuff.h **** 	struct net_device	*real_dev;
 215:include/linux/skbuff.h **** 
 216:include/linux/skbuff.h **** 	union {
 217:include/linux/skbuff.h **** 		struct tcphdr	*th;
 218:include/linux/skbuff.h **** 		struct udphdr	*uh;
 219:include/linux/skbuff.h **** 		struct icmphdr	*icmph;
 220:include/linux/skbuff.h **** 		struct igmphdr	*igmph;
 221:include/linux/skbuff.h **** 		struct iphdr	*ipiph;
 222:include/linux/skbuff.h **** 		struct ipv6hdr	*ipv6h;
 223:include/linux/skbuff.h **** 		unsigned char	*raw;
 224:include/linux/skbuff.h **** 	} h;
 225:include/linux/skbuff.h **** 
 226:include/linux/skbuff.h **** 	union {
GAS LISTING  			page 31


 227:include/linux/skbuff.h **** 		struct iphdr	*iph;
 228:include/linux/skbuff.h **** 		struct ipv6hdr	*ipv6h;
 229:include/linux/skbuff.h **** 		struct arphdr	*arph;
 230:include/linux/skbuff.h **** 		unsigned char	*raw;
 231:include/linux/skbuff.h **** 	} nh;
 232:include/linux/skbuff.h **** 
 233:include/linux/skbuff.h **** 	union {
 234:include/linux/skbuff.h **** 	  	unsigned char 	*raw;
 235:include/linux/skbuff.h **** 	} mac;
 236:include/linux/skbuff.h **** 
 237:include/linux/skbuff.h **** 	struct  dst_entry	*dst;
 238:include/linux/skbuff.h **** 	struct	sec_path	*sp;
 239:include/linux/skbuff.h **** 
 240:include/linux/skbuff.h **** 	/*
 241:include/linux/skbuff.h **** 	 * This is the control buffer. It is free to use for every
 242:include/linux/skbuff.h **** 	 * layer. Please put your private variables there. If you
 243:include/linux/skbuff.h **** 	 * want to keep them across layers you have to do a skb_clone()
 244:include/linux/skbuff.h **** 	 * first. This is owned by whoever has the skb queued ATM.
 245:include/linux/skbuff.h **** 	 */
 246:include/linux/skbuff.h **** 	char			cb[40];
 247:include/linux/skbuff.h **** 
 248:include/linux/skbuff.h **** 	unsigned int		len,
 249:include/linux/skbuff.h **** 				data_len,
 250:include/linux/skbuff.h **** 				mac_len,
 251:include/linux/skbuff.h **** 				csum;
 252:include/linux/skbuff.h **** 	unsigned char		local_df,
 253:include/linux/skbuff.h **** 				cloned:1,
 254:include/linux/skbuff.h **** 				nohdr:1,
 255:include/linux/skbuff.h **** 				pkt_type,
 256:include/linux/skbuff.h **** 				ip_summed;
 257:include/linux/skbuff.h **** 	__u32			priority;
 258:include/linux/skbuff.h **** 	unsigned short		protocol,
 259:include/linux/skbuff.h **** 				security;
 260:include/linux/skbuff.h **** 
 261:include/linux/skbuff.h **** 	void			(*destructor)(struct sk_buff *skb);
 262:include/linux/skbuff.h **** #ifdef CONFIG_NETFILTER
 263:include/linux/skbuff.h ****         unsigned long		nfmark;
 264:include/linux/skbuff.h **** 	__u32			nfcache;
 265:include/linux/skbuff.h **** 	__u32			nfctinfo;
 266:include/linux/skbuff.h **** 	struct nf_conntrack	*nfct;
 267:include/linux/skbuff.h **** #ifdef CONFIG_NETFILTER_DEBUG
 268:include/linux/skbuff.h ****         unsigned int		nf_debug;
 269:include/linux/skbuff.h **** #endif
 270:include/linux/skbuff.h **** #ifdef CONFIG_BRIDGE_NETFILTER
 271:include/linux/skbuff.h **** 	struct nf_bridge_info	*nf_bridge;
 272:include/linux/skbuff.h **** #endif
 273:include/linux/skbuff.h **** #endif /* CONFIG_NETFILTER */
 274:include/linux/skbuff.h **** #if defined(CONFIG_HIPPI)
 275:include/linux/skbuff.h **** 	union {
 276:include/linux/skbuff.h **** 		__u32		ifield;
 277:include/linux/skbuff.h **** 	} private;
 278:include/linux/skbuff.h **** #endif
 279:include/linux/skbuff.h **** #ifdef CONFIG_NET_SCHED
 280:include/linux/skbuff.h ****        __u32			tc_index;        /* traffic control index */
 281:include/linux/skbuff.h **** #ifdef CONFIG_NET_CLS_ACT
 282:include/linux/skbuff.h **** 	__u32           tc_verd;               /* traffic control verdict */
 283:include/linux/skbuff.h **** 	__u32           tc_classid;            /* traffic control classid */
GAS LISTING  			page 32


 284:include/linux/skbuff.h **** #endif
 285:include/linux/skbuff.h **** 
 286:include/linux/skbuff.h **** #endif
 287:include/linux/skbuff.h **** 
 288:include/linux/skbuff.h **** 
 289:include/linux/skbuff.h **** 	/* These elements must be at the end, see alloc_skb() for details.  */
 290:include/linux/skbuff.h **** 	unsigned int		truesize;
 291:include/linux/skbuff.h **** 	atomic_t		users;
 292:include/linux/skbuff.h **** 	unsigned char		*head,
 293:include/linux/skbuff.h **** 				*data,
 294:include/linux/skbuff.h **** 				*tail,
 295:include/linux/skbuff.h **** 				*end;
 296:include/linux/skbuff.h **** };
 297:include/linux/skbuff.h **** 
 298:include/linux/skbuff.h **** #ifdef __KERNEL__
 299:include/linux/skbuff.h **** /*
 300:include/linux/skbuff.h ****  *	Handling routines are only of interest to the kernel
 301:include/linux/skbuff.h ****  */
 302:include/linux/skbuff.h **** #include <linux/slab.h>
 303:include/linux/skbuff.h **** 
 304:include/linux/skbuff.h **** #include <asm/system.h>
 305:include/linux/skbuff.h **** 
 306:include/linux/skbuff.h **** extern void	       __kfree_skb(struct sk_buff *skb);
 307:include/linux/skbuff.h **** extern struct sk_buff *alloc_skb(unsigned int size, int priority);
 308:include/linux/skbuff.h **** extern struct sk_buff *alloc_skb_from_cache(kmem_cache_t *cp,
 309:include/linux/skbuff.h **** 					    unsigned int size, int priority);
 310:include/linux/skbuff.h **** extern void	       kfree_skbmem(struct sk_buff *skb);
 311:include/linux/skbuff.h **** extern struct sk_buff *skb_clone(struct sk_buff *skb, int priority);
 312:include/linux/skbuff.h **** extern struct sk_buff *skb_copy(const struct sk_buff *skb, int priority);
 313:include/linux/skbuff.h **** extern struct sk_buff *pskb_copy(struct sk_buff *skb, int gfp_mask);
 314:include/linux/skbuff.h **** extern int	       pskb_expand_head(struct sk_buff *skb,
 315:include/linux/skbuff.h **** 					int nhead, int ntail, int gfp_mask);
 316:include/linux/skbuff.h **** extern struct sk_buff *skb_realloc_headroom(struct sk_buff *skb,
 317:include/linux/skbuff.h **** 					    unsigned int headroom);
 318:include/linux/skbuff.h **** extern struct sk_buff *skb_copy_expand(const struct sk_buff *skb,
 319:include/linux/skbuff.h **** 				       int newheadroom, int newtailroom,
 320:include/linux/skbuff.h **** 				       int priority);
 321:include/linux/skbuff.h **** extern struct sk_buff *		skb_pad(struct sk_buff *skb, int pad);
 322:include/linux/skbuff.h **** #define dev_kfree_skb(a)	kfree_skb(a)
 323:include/linux/skbuff.h **** extern void	      skb_over_panic(struct sk_buff *skb, int len,
 324:include/linux/skbuff.h **** 				     void *here);
 325:include/linux/skbuff.h **** extern void	      skb_under_panic(struct sk_buff *skb, int len,
 326:include/linux/skbuff.h **** 				      void *here);
 327:include/linux/skbuff.h **** 
 328:include/linux/skbuff.h **** /* Internal */
 329:include/linux/skbuff.h **** #define skb_shinfo(SKB)		((struct skb_shared_info *)((SKB)->end))
 330:include/linux/skbuff.h **** 
 331:include/linux/skbuff.h **** /**
 332:include/linux/skbuff.h ****  *	skb_queue_empty - check if a queue is empty
 333:include/linux/skbuff.h ****  *	@list: queue head
 334:include/linux/skbuff.h ****  *
 335:include/linux/skbuff.h ****  *	Returns true if the queue is empty, false otherwise.
 336:include/linux/skbuff.h ****  */
 337:include/linux/skbuff.h **** static inline int skb_queue_empty(const struct sk_buff_head *list)
 338:include/linux/skbuff.h **** {
 339:include/linux/skbuff.h **** 	return list->next == (struct sk_buff *)list;
 340:include/linux/skbuff.h **** }
GAS LISTING  			page 33


 341:include/linux/skbuff.h **** 
 342:include/linux/skbuff.h **** /**
 343:include/linux/skbuff.h ****  *	skb_get - reference buffer
 344:include/linux/skbuff.h ****  *	@skb: buffer to reference
 345:include/linux/skbuff.h ****  *
 346:include/linux/skbuff.h ****  *	Makes another reference to a socket buffer and returns a pointer
 347:include/linux/skbuff.h ****  *	to the buffer.
 348:include/linux/skbuff.h ****  */
 349:include/linux/skbuff.h **** static inline struct sk_buff *skb_get(struct sk_buff *skb)
 350:include/linux/skbuff.h **** {
 351:include/linux/skbuff.h **** 	atomic_inc(&skb->users);
 352:include/linux/skbuff.h **** 	return skb;
 353:include/linux/skbuff.h **** }
 354:include/linux/skbuff.h **** 
 355:include/linux/skbuff.h **** /*
 356:include/linux/skbuff.h ****  * If users == 1, we are the only owner and are can avoid redundant
 357:include/linux/skbuff.h ****  * atomic change.
 358:include/linux/skbuff.h ****  */
 359:include/linux/skbuff.h **** 
 360:include/linux/skbuff.h **** /**
 361:include/linux/skbuff.h ****  *	kfree_skb - free an sk_buff
 362:include/linux/skbuff.h ****  *	@skb: buffer to free
 363:include/linux/skbuff.h ****  *
 364:include/linux/skbuff.h ****  *	Drop a reference to the buffer and free it if the usage count has
 365:include/linux/skbuff.h ****  *	hit zero.
 366:include/linux/skbuff.h ****  */
 367:include/linux/skbuff.h **** static inline void kfree_skb(struct sk_buff *skb)
 368:include/linux/skbuff.h **** {
 369:include/linux/skbuff.h **** 	if (likely(atomic_read(&skb->users) == 1))
 264              	.loc 6 369 0
 265 011e 8B82A000 	movl 160(%edx),%eax
 265      0000
 266 0124 48       	decl %eax
 267 0125 7502     	jne .L29
 370:include/linux/skbuff.h **** 		smp_rmb();
 268              	.loc 6 370 0
 269 0127 EB0D     	jmp .L30
 270              	.L29:
 271              	.LBB22:
 272              	.LBB23:
 273              	.loc 3 135 0
 274              	
 275 0129 FF8AA000 	decl 160(%edx)
 275      00000F94 
 275      C0
 276              	
 277              	.LBE23:
 278              	.LBE22:
 279              	.loc 3 132 0
 280 0132 84C0     	testb %al,%al
 281 0134 7407     	je .L18
 282              	.L30:
 371:include/linux/skbuff.h **** 	else if (likely(!atomic_dec_and_test(&skb->users)))
 372:include/linux/skbuff.h **** 		return;
 373:include/linux/skbuff.h **** 	__kfree_skb(skb);
 283              	.loc 6 373 0
 284 0136 52       	pushl %edx
GAS LISTING  			page 34


 285              	.LCFI15:
 286 0137 E8FCFFFF 	call __kfree_skb
 286      FF
 287 013c 58       	popl %eax
 288              	.LCFI16:
 289              	.L18:
 290              	.LBE21:
 291              	.LBE20:
 292              	.LBE11:
 293              	.LBE10:
 294              	.loc 1 191 0
 295 013d 47       	incl %edi
 296 013e 0FB606   	movzbl (%esi),%eax
 297 0141 39C7     	cmpl %eax,%edi
 298 0143 7C8F     	jl .L35
 299              	.L37:
 193:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 			dev_kfree_skb_any(txb->fragments[i]);
 194:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	kfree(txb);
 300              	.loc 1 194 0
 301 0145 89742410 	movl %esi,16(%esp)
 195:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** }
 302              	.loc 1 195 0
 303 0149 5B       	popl %ebx
 304 014a 5E       	popl %esi
 305 014b 5F       	popl %edi
 306              	.loc 1 194 0
 307              	.LCFI17:
 308 014c E9FCFFFF 	jmp kfree
 308      FF
 309              	.L14:
 310              	.loc 1 195 0
 311 0151 5B       	popl %ebx
 312 0152 5E       	popl %esi
 313 0153 5F       	popl %edi
 314 0154 C3       	ret
 315              	.LFE924:
 318              	ieee80211_alloc_txb:
 319              	.LFB925:
 196:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 
 197:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** static struct ieee80211_txb *ieee80211_alloc_txb(int nr_frags, int txb_size,
 198:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 						 int headroom, unsigned __nocast gfp_mask)
 199:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** {
 320              	.loc 1 199 0
 321              	.L41:
 322 0155 55       	pushl %ebp
 323              	.LCFI18:
 324 0156 57       	pushl %edi
 325              	.LCFI19:
 326 0157 56       	pushl %esi
 327              	.LCFI20:
 328 0158 53       	pushl %ebx
 329              	.LCFI21:
 330              	.loc 1 199 0
 331 0159 8B6C2414 	movl 20(%esp),%ebp
 332              	.LBB24:
 333              	.file 7 "include/linux/slab.h"
   1:include/linux/slab.h **** /*
GAS LISTING  			page 35


   2:include/linux/slab.h ****  * linux/mm/slab.h
   3:include/linux/slab.h ****  * Written by Mark Hemment, 1996.
   4:include/linux/slab.h ****  * (markhe@nextd.demon.co.uk)
   5:include/linux/slab.h ****  */
   6:include/linux/slab.h **** 
   7:include/linux/slab.h **** #ifndef _LINUX_SLAB_H
   8:include/linux/slab.h **** #define	_LINUX_SLAB_H
   9:include/linux/slab.h **** 
  10:include/linux/slab.h **** #if	defined(__KERNEL__)
  11:include/linux/slab.h **** 
  12:include/linux/slab.h **** typedef struct kmem_cache_s kmem_cache_t;
  13:include/linux/slab.h **** 
  14:include/linux/slab.h **** #include	<linux/config.h>	/* kmalloc_sizes.h needs CONFIG_ options */
  15:include/linux/slab.h **** #include	<linux/gfp.h>
  16:include/linux/slab.h **** #include	<linux/init.h>
  17:include/linux/slab.h **** #include	<linux/types.h>
  18:include/linux/slab.h **** #include	<asm/page.h>		/* kmalloc_sizes.h needs PAGE_SIZE */
  19:include/linux/slab.h **** #include	<asm/cache.h>		/* kmalloc_sizes.h needs L1_CACHE_BYTES */
  20:include/linux/slab.h **** 
  21:include/linux/slab.h **** /* flags for kmem_cache_alloc() */
  22:include/linux/slab.h **** #define	SLAB_NOFS		GFP_NOFS
  23:include/linux/slab.h **** #define	SLAB_NOIO		GFP_NOIO
  24:include/linux/slab.h **** #define	SLAB_ATOMIC		GFP_ATOMIC
  25:include/linux/slab.h **** #define	SLAB_USER		GFP_USER
  26:include/linux/slab.h **** #define	SLAB_KERNEL		GFP_KERNEL
  27:include/linux/slab.h **** #define	SLAB_DMA		GFP_DMA
  28:include/linux/slab.h **** 
  29:include/linux/slab.h **** #define SLAB_LEVEL_MASK		GFP_LEVEL_MASK
  30:include/linux/slab.h **** 
  31:include/linux/slab.h **** #define	SLAB_NO_GROW		__GFP_NO_GROW	/* don't grow a cache */
  32:include/linux/slab.h **** 
  33:include/linux/slab.h **** /* flags to pass to kmem_cache_create().
  34:include/linux/slab.h ****  * The first 3 are only valid when the allocator as been build
  35:include/linux/slab.h ****  * SLAB_DEBUG_SUPPORT.
  36:include/linux/slab.h ****  */
  37:include/linux/slab.h **** #define	SLAB_DEBUG_FREE		0x00000100UL	/* Peform (expensive) checks on free */
  38:include/linux/slab.h **** #define	SLAB_DEBUG_INITIAL	0x00000200UL	/* Call constructor (as verifier) */
  39:include/linux/slab.h **** #define	SLAB_RED_ZONE		0x00000400UL	/* Red zone objs in a cache */
  40:include/linux/slab.h **** #define	SLAB_POISON		0x00000800UL	/* Poison objects */
  41:include/linux/slab.h **** #define	SLAB_NO_REAP		0x00001000UL	/* never reap from the cache */
  42:include/linux/slab.h **** #define	SLAB_HWCACHE_ALIGN	0x00002000UL	/* align objs on a h/w cache lines */
  43:include/linux/slab.h **** #define SLAB_CACHE_DMA		0x00004000UL	/* use GFP_DMA memory */
  44:include/linux/slab.h **** #define SLAB_MUST_HWCACHE_ALIGN	0x00008000UL	/* force alignment */
  45:include/linux/slab.h **** #define SLAB_STORE_USER		0x00010000UL	/* store the last owner for bug hunting */
  46:include/linux/slab.h **** #define SLAB_RECLAIM_ACCOUNT	0x00020000UL	/* track pages allocated to indicate
  47:include/linux/slab.h **** 						   what is reclaimable later*/
  48:include/linux/slab.h **** #define SLAB_PANIC		0x00040000UL	/* panic if kmem_cache_create() fails */
  49:include/linux/slab.h **** #define SLAB_DESTROY_BY_RCU	0x00080000UL	/* defer freeing pages to RCU */
  50:include/linux/slab.h **** 
  51:include/linux/slab.h **** /* flags passed to a constructor func */
  52:include/linux/slab.h **** #define	SLAB_CTOR_CONSTRUCTOR	0x001UL		/* if not set, then deconstructor */
  53:include/linux/slab.h **** #define SLAB_CTOR_ATOMIC	0x002UL		/* tell constructor it can't sleep */
  54:include/linux/slab.h **** #define	SLAB_CTOR_VERIFY	0x004UL		/* tell constructor it's a verify call */
  55:include/linux/slab.h **** 
  56:include/linux/slab.h **** /* prototypes */
  57:include/linux/slab.h **** extern void __init kmem_cache_init(void);
  58:include/linux/slab.h **** 
GAS LISTING  			page 36


  59:include/linux/slab.h **** extern kmem_cache_t *kmem_cache_create(const char *, size_t, size_t, unsigned long,
  60:include/linux/slab.h **** 				       void (*)(void *, kmem_cache_t *, unsigned long),
  61:include/linux/slab.h **** 				       void (*)(void *, kmem_cache_t *, unsigned long));
  62:include/linux/slab.h **** extern int kmem_cache_destroy(kmem_cache_t *);
  63:include/linux/slab.h **** extern int kmem_cache_shrink(kmem_cache_t *);
  64:include/linux/slab.h **** extern void *kmem_cache_alloc(kmem_cache_t *, unsigned int __nocast);
  65:include/linux/slab.h **** extern void kmem_cache_free(kmem_cache_t *, void *);
  66:include/linux/slab.h **** extern unsigned int kmem_cache_size(kmem_cache_t *);
  67:include/linux/slab.h **** extern kmem_cache_t *kmem_find_general_cachep(size_t size, int gfpflags);
  68:include/linux/slab.h **** 
  69:include/linux/slab.h **** /* Size description struct for general caches. */
  70:include/linux/slab.h **** struct cache_sizes {
  71:include/linux/slab.h **** 	size_t		 cs_size;
  72:include/linux/slab.h **** 	kmem_cache_t	*cs_cachep;
  73:include/linux/slab.h **** 	kmem_cache_t	*cs_dmacachep;
  74:include/linux/slab.h **** };
  75:include/linux/slab.h **** extern struct cache_sizes malloc_sizes[];
  76:include/linux/slab.h **** extern void *__kmalloc(size_t, unsigned int __nocast);
  77:include/linux/slab.h **** 
  78:include/linux/slab.h **** static inline void *kmalloc(size_t size, unsigned int __nocast flags)
  79:include/linux/slab.h **** {
 334              	.loc 7 79 0
 335 015d 8D04AD08 	leal 8(,%ebp,4),%eax
 335      000000
 336              	.LBB25:
  80:include/linux/slab.h **** 	if (__builtin_constant_p(size)) {
  81:include/linux/slab.h **** 		int i = 0;
  82:include/linux/slab.h **** #define CACHE(x) \
  83:include/linux/slab.h **** 		if (size <= x) \
  84:include/linux/slab.h **** 			goto found; \
  85:include/linux/slab.h **** 		else \
  86:include/linux/slab.h **** 			i++;
  87:include/linux/slab.h **** #include "kmalloc_sizes.h"
  88:include/linux/slab.h **** #undef CACHE
  89:include/linux/slab.h **** 		{
  90:include/linux/slab.h **** 			extern void __you_cannot_kmalloc_that_much(void);
  91:include/linux/slab.h **** 			__you_cannot_kmalloc_that_much();
  92:include/linux/slab.h **** 		}
  93:include/linux/slab.h **** found:
  94:include/linux/slab.h **** 		return kmem_cache_alloc((flags & GFP_DMA) ?
  95:include/linux/slab.h **** 			malloc_sizes[i].cs_dmacachep :
  96:include/linux/slab.h **** 			malloc_sizes[i].cs_cachep, flags);
  97:include/linux/slab.h **** 	}
 337              	.loc 7 97 0
 338 0164 FF742420 	pushl 32(%esp)
 339              	.LCFI22:
 340 0168 50       	pushl %eax
 341              	.LCFI23:
 342 0169 E8FCFFFF 	call __kmalloc
 342      FF
 343 016e 59       	popl %ecx
 344              	.LCFI24:
 345 016f 5E       	popl %esi
 346              	.LCFI25:
 347 0170 89C6     	movl %eax,%esi
 348              	.loc 7 80 0
 349 0172 31DB     	xorl %ebx,%ebx
GAS LISTING  			page 37


 350              	.LBE25:
 351              	.LBE24:
 200:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	struct ieee80211_txb *txb;
 201:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	int i;
 202:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	txb = kmalloc(sizeof(struct ieee80211_txb) + (sizeof(u8 *) * nr_frags),
 203:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		      gfp_mask);
 204:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	if (!txb)
 205:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		return NULL;
 352              	.loc 1 205 0
 353 0174 31C0     	xorl %eax,%eax
 354              	.loc 1 204 0
 355 0176 85F6     	testl %esi,%esi
 356 0178 0F84E400 	je .L38
 356      0000
 357 017e EB03     	jmp .L72
 358              	.L117:
 206:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 
 207:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	memset(txb, 0, sizeof(struct ieee80211_txb));
 208:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	txb->nr_frags = nr_frags;
 209:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	txb->frag_size = txb_size;
 210:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 
 211:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	for (i = 0; i < nr_frags; i++) {
 212:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		txb->fragments[i] = __dev_alloc_skb(txb_size + headroom,
 213:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 						    gfp_mask);
 214:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		if (unlikely(!txb->fragments[i])) {
 215:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 			i--;
 359              	.loc 1 215 0
 360 0180 4F       	decl %edi
 216:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 			break;
 361              	.loc 1 216 0
 362 0181 EB62     	jmp .L87
 363              	.L72:
 364              	.LBB26:
 365              	.LBB27:
 366              	.LBB28:
 367              	.file 8 "include/asm/string.h"
   1:include/asm/string.h **** #ifndef _I386_STRING_H_
   2:include/asm/string.h **** #define _I386_STRING_H_
   3:include/asm/string.h **** 
   4:include/asm/string.h **** #ifdef __KERNEL__
   5:include/asm/string.h **** #include <linux/config.h>
   6:include/asm/string.h **** /*
   7:include/asm/string.h ****  * On a 486 or Pentium, we are better off not using the
   8:include/asm/string.h ****  * byte string operations. But on a 386 or a PPro the
   9:include/asm/string.h ****  * byte string ops are faster than doing it by hand
  10:include/asm/string.h ****  * (MUCH faster on a Pentium).
  11:include/asm/string.h ****  */
  12:include/asm/string.h **** 
  13:include/asm/string.h **** /*
  14:include/asm/string.h ****  * This string-include defines all string functions as inline
  15:include/asm/string.h ****  * functions. Use gcc. It also assumes ds=es=data space, this should be
  16:include/asm/string.h ****  * normal. Most of the string-functions are rather heavily hand-optimized,
  17:include/asm/string.h ****  * see especially strsep,strstr,str[c]spn. They should work, but are not
  18:include/asm/string.h ****  * very easy to understand. Everything is done entirely within the register
  19:include/asm/string.h ****  * set, making the functions fast and clean. String instructions have been
  20:include/asm/string.h ****  * used through-out, making for "slightly" unclear code :-)
  21:include/asm/string.h ****  *
GAS LISTING  			page 38


  22:include/asm/string.h ****  *		NO Copyright (C) 1991, 1992 Linus Torvalds,
  23:include/asm/string.h ****  *		consider these trivial functions to be PD.
  24:include/asm/string.h ****  */
  25:include/asm/string.h **** 
  26:include/asm/string.h **** /* AK: in fact I bet it would be better to move this stuff all out of line.
  27:include/asm/string.h ****  */
  28:include/asm/string.h **** 
  29:include/asm/string.h **** #define __HAVE_ARCH_STRCPY
  30:include/asm/string.h **** static inline char * strcpy(char * dest,const char *src)
  31:include/asm/string.h **** {
  32:include/asm/string.h **** int d0, d1, d2;
  33:include/asm/string.h **** __asm__ __volatile__(
  34:include/asm/string.h **** 	"1:\tlodsb\n\t"
  35:include/asm/string.h **** 	"stosb\n\t"
  36:include/asm/string.h **** 	"testb %%al,%%al\n\t"
  37:include/asm/string.h **** 	"jne 1b"
  38:include/asm/string.h **** 	: "=&S" (d0), "=&D" (d1), "=&a" (d2)
  39:include/asm/string.h **** 	:"0" (src),"1" (dest) : "memory");
  40:include/asm/string.h **** return dest;
  41:include/asm/string.h **** }
  42:include/asm/string.h **** 
  43:include/asm/string.h **** #define __HAVE_ARCH_STRNCPY
  44:include/asm/string.h **** static inline char * strncpy(char * dest,const char *src,size_t count)
  45:include/asm/string.h **** {
  46:include/asm/string.h **** int d0, d1, d2, d3;
  47:include/asm/string.h **** __asm__ __volatile__(
  48:include/asm/string.h **** 	"1:\tdecl %2\n\t"
  49:include/asm/string.h **** 	"js 2f\n\t"
  50:include/asm/string.h **** 	"lodsb\n\t"
  51:include/asm/string.h **** 	"stosb\n\t"
  52:include/asm/string.h **** 	"testb %%al,%%al\n\t"
  53:include/asm/string.h **** 	"jne 1b\n\t"
  54:include/asm/string.h **** 	"rep\n\t"
  55:include/asm/string.h **** 	"stosb\n"
  56:include/asm/string.h **** 	"2:"
  57:include/asm/string.h **** 	: "=&S" (d0), "=&D" (d1), "=&c" (d2), "=&a" (d3)
  58:include/asm/string.h **** 	:"0" (src),"1" (dest),"2" (count) : "memory");
  59:include/asm/string.h **** return dest;
  60:include/asm/string.h **** }
  61:include/asm/string.h **** 
  62:include/asm/string.h **** #define __HAVE_ARCH_STRCAT
  63:include/asm/string.h **** static inline char * strcat(char * dest,const char * src)
  64:include/asm/string.h **** {
  65:include/asm/string.h **** int d0, d1, d2, d3;
  66:include/asm/string.h **** __asm__ __volatile__(
  67:include/asm/string.h **** 	"repne\n\t"
  68:include/asm/string.h **** 	"scasb\n\t"
  69:include/asm/string.h **** 	"decl %1\n"
  70:include/asm/string.h **** 	"1:\tlodsb\n\t"
  71:include/asm/string.h **** 	"stosb\n\t"
  72:include/asm/string.h **** 	"testb %%al,%%al\n\t"
  73:include/asm/string.h **** 	"jne 1b"
  74:include/asm/string.h **** 	: "=&S" (d0), "=&D" (d1), "=&a" (d2), "=&c" (d3)
  75:include/asm/string.h **** 	: "0" (src), "1" (dest), "2" (0), "3" (0xffffffffu):"memory");
  76:include/asm/string.h **** return dest;
  77:include/asm/string.h **** }
  78:include/asm/string.h **** 
GAS LISTING  			page 39


  79:include/asm/string.h **** #define __HAVE_ARCH_STRNCAT
  80:include/asm/string.h **** static inline char * strncat(char * dest,const char * src,size_t count)
  81:include/asm/string.h **** {
  82:include/asm/string.h **** int d0, d1, d2, d3;
  83:include/asm/string.h **** __asm__ __volatile__(
  84:include/asm/string.h **** 	"repne\n\t"
  85:include/asm/string.h **** 	"scasb\n\t"
  86:include/asm/string.h **** 	"decl %1\n\t"
  87:include/asm/string.h **** 	"movl %8,%3\n"
  88:include/asm/string.h **** 	"1:\tdecl %3\n\t"
  89:include/asm/string.h **** 	"js 2f\n\t"
  90:include/asm/string.h **** 	"lodsb\n\t"
  91:include/asm/string.h **** 	"stosb\n\t"
  92:include/asm/string.h **** 	"testb %%al,%%al\n\t"
  93:include/asm/string.h **** 	"jne 1b\n"
  94:include/asm/string.h **** 	"2:\txorl %2,%2\n\t"
  95:include/asm/string.h **** 	"stosb"
  96:include/asm/string.h **** 	: "=&S" (d0), "=&D" (d1), "=&a" (d2), "=&c" (d3)
  97:include/asm/string.h **** 	: "0" (src),"1" (dest),"2" (0),"3" (0xffffffffu), "g" (count)
  98:include/asm/string.h **** 	: "memory");
  99:include/asm/string.h **** return dest;
 100:include/asm/string.h **** }
 101:include/asm/string.h **** 
 102:include/asm/string.h **** #define __HAVE_ARCH_STRCMP
 103:include/asm/string.h **** static inline int strcmp(const char * cs,const char * ct)
 104:include/asm/string.h **** {
 105:include/asm/string.h **** int d0, d1;
 106:include/asm/string.h **** register int __res;
 107:include/asm/string.h **** __asm__ __volatile__(
 108:include/asm/string.h **** 	"1:\tlodsb\n\t"
 109:include/asm/string.h **** 	"scasb\n\t"
 110:include/asm/string.h **** 	"jne 2f\n\t"
 111:include/asm/string.h **** 	"testb %%al,%%al\n\t"
 112:include/asm/string.h **** 	"jne 1b\n\t"
 113:include/asm/string.h **** 	"xorl %%eax,%%eax\n\t"
 114:include/asm/string.h **** 	"jmp 3f\n"
 115:include/asm/string.h **** 	"2:\tsbbl %%eax,%%eax\n\t"
 116:include/asm/string.h **** 	"orb $1,%%al\n"
 117:include/asm/string.h **** 	"3:"
 118:include/asm/string.h **** 	:"=a" (__res), "=&S" (d0), "=&D" (d1)
 119:include/asm/string.h **** 	:"1" (cs),"2" (ct)
 120:include/asm/string.h **** 	:"memory");
 121:include/asm/string.h **** return __res;
 122:include/asm/string.h **** }
 123:include/asm/string.h **** 
 124:include/asm/string.h **** #define __HAVE_ARCH_STRNCMP
 125:include/asm/string.h **** static inline int strncmp(const char * cs,const char * ct,size_t count)
 126:include/asm/string.h **** {
 127:include/asm/string.h **** register int __res;
 128:include/asm/string.h **** int d0, d1, d2;
 129:include/asm/string.h **** __asm__ __volatile__(
 130:include/asm/string.h **** 	"1:\tdecl %3\n\t"
 131:include/asm/string.h **** 	"js 2f\n\t"
 132:include/asm/string.h **** 	"lodsb\n\t"
 133:include/asm/string.h **** 	"scasb\n\t"
 134:include/asm/string.h **** 	"jne 3f\n\t"
 135:include/asm/string.h **** 	"testb %%al,%%al\n\t"
GAS LISTING  			page 40


 136:include/asm/string.h **** 	"jne 1b\n"
 137:include/asm/string.h **** 	"2:\txorl %%eax,%%eax\n\t"
 138:include/asm/string.h **** 	"jmp 4f\n"
 139:include/asm/string.h **** 	"3:\tsbbl %%eax,%%eax\n\t"
 140:include/asm/string.h **** 	"orb $1,%%al\n"
 141:include/asm/string.h **** 	"4:"
 142:include/asm/string.h **** 	:"=a" (__res), "=&S" (d0), "=&D" (d1), "=&c" (d2)
 143:include/asm/string.h **** 	:"1" (cs),"2" (ct),"3" (count)
 144:include/asm/string.h **** 	:"memory");
 145:include/asm/string.h **** return __res;
 146:include/asm/string.h **** }
 147:include/asm/string.h **** 
 148:include/asm/string.h **** #define __HAVE_ARCH_STRCHR
 149:include/asm/string.h **** static inline char * strchr(const char * s, int c)
 150:include/asm/string.h **** {
 151:include/asm/string.h **** int d0;
 152:include/asm/string.h **** register char * __res;
 153:include/asm/string.h **** __asm__ __volatile__(
 154:include/asm/string.h **** 	"movb %%al,%%ah\n"
 155:include/asm/string.h **** 	"1:\tlodsb\n\t"
 156:include/asm/string.h **** 	"cmpb %%ah,%%al\n\t"
 157:include/asm/string.h **** 	"je 2f\n\t"
 158:include/asm/string.h **** 	"testb %%al,%%al\n\t"
 159:include/asm/string.h **** 	"jne 1b\n\t"
 160:include/asm/string.h **** 	"movl $1,%1\n"
 161:include/asm/string.h **** 	"2:\tmovl %1,%0\n\t"
 162:include/asm/string.h **** 	"decl %0"
 163:include/asm/string.h **** 	:"=a" (__res), "=&S" (d0)
 164:include/asm/string.h **** 	:"1" (s),"0" (c)
 165:include/asm/string.h **** 	:"memory");
 166:include/asm/string.h **** return __res;
 167:include/asm/string.h **** }
 168:include/asm/string.h **** 
 169:include/asm/string.h **** #define __HAVE_ARCH_STRRCHR
 170:include/asm/string.h **** static inline char * strrchr(const char * s, int c)
 171:include/asm/string.h **** {
 172:include/asm/string.h **** int d0, d1;
 173:include/asm/string.h **** register char * __res;
 174:include/asm/string.h **** __asm__ __volatile__(
 175:include/asm/string.h **** 	"movb %%al,%%ah\n"
 176:include/asm/string.h **** 	"1:\tlodsb\n\t"
 177:include/asm/string.h **** 	"cmpb %%ah,%%al\n\t"
 178:include/asm/string.h **** 	"jne 2f\n\t"
 179:include/asm/string.h **** 	"leal -1(%%esi),%0\n"
 180:include/asm/string.h **** 	"2:\ttestb %%al,%%al\n\t"
 181:include/asm/string.h **** 	"jne 1b"
 182:include/asm/string.h **** 	:"=g" (__res), "=&S" (d0), "=&a" (d1)
 183:include/asm/string.h **** 	:"0" (0),"1" (s),"2" (c)
 184:include/asm/string.h **** 	:"memory");
 185:include/asm/string.h **** return __res;
 186:include/asm/string.h **** }
 187:include/asm/string.h **** 
 188:include/asm/string.h **** #define __HAVE_ARCH_STRLEN
 189:include/asm/string.h **** static inline size_t strlen(const char * s)
 190:include/asm/string.h **** {
 191:include/asm/string.h **** int d0;
 192:include/asm/string.h **** register int __res;
GAS LISTING  			page 41


 193:include/asm/string.h **** __asm__ __volatile__(
 194:include/asm/string.h **** 	"repne\n\t"
 195:include/asm/string.h **** 	"scasb\n\t"
 196:include/asm/string.h **** 	"notl %0\n\t"
 197:include/asm/string.h **** 	"decl %0"
 198:include/asm/string.h **** 	:"=c" (__res), "=&D" (d0)
 199:include/asm/string.h **** 	:"1" (s),"a" (0), "0" (0xffffffffu)
 200:include/asm/string.h **** 	:"memory");
 201:include/asm/string.h **** return __res;
 202:include/asm/string.h **** }
 203:include/asm/string.h **** 
 204:include/asm/string.h **** static inline void * __memcpy(void * to, const void * from, size_t n)
 205:include/asm/string.h **** {
 206:include/asm/string.h **** int d0, d1, d2;
 207:include/asm/string.h **** __asm__ __volatile__(
 208:include/asm/string.h **** 	"rep ; movsl\n\t"
 209:include/asm/string.h **** 	"movl %4,%%ecx\n\t"
 210:include/asm/string.h **** 	"andl $3,%%ecx\n\t"
 211:include/asm/string.h **** #if 1	/* want to pay 2 byte penalty for a chance to skip microcoded rep? */
 212:include/asm/string.h **** 	"jz 1f\n\t"
 213:include/asm/string.h **** #endif
 214:include/asm/string.h **** 	"rep ; movsb\n\t"
 215:include/asm/string.h **** 	"1:"
 216:include/asm/string.h **** 	: "=&c" (d0), "=&D" (d1), "=&S" (d2)
 217:include/asm/string.h **** 	: "0" (n/4), "g" (n), "1" ((long) to), "2" ((long) from)
 218:include/asm/string.h **** 	: "memory");
 219:include/asm/string.h **** return (to);
 220:include/asm/string.h **** }
 221:include/asm/string.h **** 
 222:include/asm/string.h **** /*
 223:include/asm/string.h ****  * This looks ugly, but the compiler can optimize it totally,
 224:include/asm/string.h ****  * as the count is constant.
 225:include/asm/string.h ****  */
 226:include/asm/string.h **** static inline void * __constant_memcpy(void * to, const void * from, size_t n)
 227:include/asm/string.h **** {
 228:include/asm/string.h **** 	long esi, edi;
 229:include/asm/string.h **** 	if (!n) return to;
 230:include/asm/string.h **** #if 1	/* want to do small copies with non-string ops? */
 231:include/asm/string.h **** 	switch (n) {
 232:include/asm/string.h **** 		case 1: *(char*)to = *(char*)from; return to;
 233:include/asm/string.h **** 		case 2: *(short*)to = *(short*)from; return to;
 234:include/asm/string.h **** 		case 4: *(int*)to = *(int*)from; return to;
 235:include/asm/string.h **** #if 1	/* including those doable with two moves? */
 236:include/asm/string.h **** 		case 3: *(short*)to = *(short*)from;
 237:include/asm/string.h **** 			*((char*)to+2) = *((char*)from+2); return to;
 238:include/asm/string.h **** 		case 5: *(int*)to = *(int*)from;
 239:include/asm/string.h **** 			*((char*)to+4) = *((char*)from+4); return to;
 240:include/asm/string.h **** 		case 6: *(int*)to = *(int*)from;
 241:include/asm/string.h **** 			*((short*)to+2) = *((short*)from+2); return to;
 242:include/asm/string.h **** 		case 8: *(int*)to = *(int*)from;
 243:include/asm/string.h **** 			*((int*)to+1) = *((int*)from+1); return to;
 244:include/asm/string.h **** #endif
 245:include/asm/string.h **** 	}
 246:include/asm/string.h **** #endif
 247:include/asm/string.h **** 	esi = (long) from;
 248:include/asm/string.h **** 	edi = (long) to;
 249:include/asm/string.h **** 	if (n >= 5*4) {
GAS LISTING  			page 42


 250:include/asm/string.h **** 		/* large block: use rep prefix */
 251:include/asm/string.h **** 		int ecx;
 252:include/asm/string.h **** 		__asm__ __volatile__(
 253:include/asm/string.h **** 			"rep ; movsl"
 254:include/asm/string.h **** 			: "=&c" (ecx), "=&D" (edi), "=&S" (esi)
 255:include/asm/string.h **** 			: "0" (n/4), "1" (edi),"2" (esi)
 256:include/asm/string.h **** 			: "memory"
 257:include/asm/string.h **** 		);
 258:include/asm/string.h **** 	} else {
 259:include/asm/string.h **** 		/* small block: don't clobber ecx + smaller code */
 260:include/asm/string.h **** 		if (n >= 4*4) __asm__ __volatile__("movsl"
 261:include/asm/string.h **** 			:"=&D"(edi),"=&S"(esi):"0"(edi),"1"(esi):"memory");
 262:include/asm/string.h **** 		if (n >= 3*4) __asm__ __volatile__("movsl"
 263:include/asm/string.h **** 			:"=&D"(edi),"=&S"(esi):"0"(edi),"1"(esi):"memory");
 264:include/asm/string.h **** 		if (n >= 2*4) __asm__ __volatile__("movsl"
 265:include/asm/string.h **** 			:"=&D"(edi),"=&S"(esi):"0"(edi),"1"(esi):"memory");
 266:include/asm/string.h **** 		if (n >= 1*4) __asm__ __volatile__("movsl"
 267:include/asm/string.h **** 			:"=&D"(edi),"=&S"(esi):"0"(edi),"1"(esi):"memory");
 268:include/asm/string.h **** 	}
 269:include/asm/string.h **** 	switch (n % 4) {
 270:include/asm/string.h **** 		/* tail */
 271:include/asm/string.h **** 		case 0: return to;
 272:include/asm/string.h **** 		case 1: __asm__ __volatile__("movsb"
 273:include/asm/string.h **** 			:"=&D"(edi),"=&S"(esi):"0"(edi),"1"(esi):"memory");
 274:include/asm/string.h **** 			return to;
 275:include/asm/string.h **** 		case 2: __asm__ __volatile__("movsw"
 276:include/asm/string.h **** 			:"=&D"(edi),"=&S"(esi):"0"(edi),"1"(esi):"memory");
 277:include/asm/string.h **** 			return to;
 278:include/asm/string.h **** 		default: __asm__ __volatile__("movsw\n\tmovsb"
 279:include/asm/string.h **** 			:"=&D"(edi),"=&S"(esi):"0"(edi),"1"(esi):"memory");
 280:include/asm/string.h **** 			return to;
 281:include/asm/string.h **** 	}
 282:include/asm/string.h **** }
 283:include/asm/string.h **** 
 284:include/asm/string.h **** #define __HAVE_ARCH_MEMCPY
 285:include/asm/string.h **** 
 286:include/asm/string.h **** #ifdef CONFIG_X86_USE_3DNOW
 287:include/asm/string.h **** 
 288:include/asm/string.h **** #include <asm/mmx.h>
 289:include/asm/string.h **** 
 290:include/asm/string.h **** /*
 291:include/asm/string.h ****  *	This CPU favours 3DNow strongly (eg AMD Athlon)
 292:include/asm/string.h ****  */
 293:include/asm/string.h **** 
 294:include/asm/string.h **** static inline void * __constant_memcpy3d(void * to, const void * from, size_t len)
 295:include/asm/string.h **** {
 296:include/asm/string.h **** 	if (len < 512)
 297:include/asm/string.h **** 		return __constant_memcpy(to, from, len);
 298:include/asm/string.h **** 	return _mmx_memcpy(to, from, len);
 299:include/asm/string.h **** }
 300:include/asm/string.h **** 
 301:include/asm/string.h **** static __inline__ void *__memcpy3d(void *to, const void *from, size_t len)
 302:include/asm/string.h **** {
 303:include/asm/string.h **** 	if (len < 512)
 304:include/asm/string.h **** 		return __memcpy(to, from, len);
 305:include/asm/string.h **** 	return _mmx_memcpy(to, from, len);
 306:include/asm/string.h **** }
GAS LISTING  			page 43


 307:include/asm/string.h **** 
 308:include/asm/string.h **** #define memcpy(t, f, n) \
 309:include/asm/string.h **** (__builtin_constant_p(n) ? \
 310:include/asm/string.h ****  __constant_memcpy3d((t),(f),(n)) : \
 311:include/asm/string.h ****  __memcpy3d((t),(f),(n)))
 312:include/asm/string.h **** 
 313:include/asm/string.h **** #else
 314:include/asm/string.h **** 
 315:include/asm/string.h **** /*
 316:include/asm/string.h ****  *	No 3D Now!
 317:include/asm/string.h ****  */
 318:include/asm/string.h ****  
 319:include/asm/string.h **** #define memcpy(t, f, n) \
 320:include/asm/string.h **** (__builtin_constant_p(n) ? \
 321:include/asm/string.h ****  __constant_memcpy((t),(f),(n)) : \
 322:include/asm/string.h ****  __memcpy((t),(f),(n)))
 323:include/asm/string.h **** 
 324:include/asm/string.h **** #endif
 325:include/asm/string.h **** 
 326:include/asm/string.h **** #define __HAVE_ARCH_MEMMOVE
 327:include/asm/string.h **** void *memmove(void * dest,const void * src, size_t n);
 328:include/asm/string.h **** 
 329:include/asm/string.h **** #define memcmp __builtin_memcmp
 330:include/asm/string.h **** 
 331:include/asm/string.h **** #define __HAVE_ARCH_MEMCHR
 332:include/asm/string.h **** static inline void * memchr(const void * cs,int c,size_t count)
 333:include/asm/string.h **** {
 334:include/asm/string.h **** int d0;
 335:include/asm/string.h **** register void * __res;
 336:include/asm/string.h **** if (!count)
 337:include/asm/string.h **** 	return NULL;
 338:include/asm/string.h **** __asm__ __volatile__(
 339:include/asm/string.h **** 	"repne\n\t"
 340:include/asm/string.h **** 	"scasb\n\t"
 341:include/asm/string.h **** 	"je 1f\n\t"
 342:include/asm/string.h **** 	"movl $1,%0\n"
 343:include/asm/string.h **** 	"1:\tdecl %0"
 344:include/asm/string.h **** 	:"=D" (__res), "=&c" (d0)
 345:include/asm/string.h **** 	:"a" (c),"0" (cs),"1" (count)
 346:include/asm/string.h **** 	:"memory");
 347:include/asm/string.h **** return __res;
 348:include/asm/string.h **** }
 349:include/asm/string.h **** 
 350:include/asm/string.h **** static inline void * __memset_generic(void * s, char c,size_t count)
 351:include/asm/string.h **** {
 352:include/asm/string.h **** int d0, d1;
 353:include/asm/string.h **** __asm__ __volatile__(
 354:include/asm/string.h **** 	"rep\n\t"
 355:include/asm/string.h **** 	"stosb"
 356:include/asm/string.h **** 	: "=&c" (d0), "=&D" (d1)
 357:include/asm/string.h **** 	:"a" (c),"1" (s),"0" (count)
 358:include/asm/string.h **** 	:"memory");
 359:include/asm/string.h **** return s;
 360:include/asm/string.h **** }
 361:include/asm/string.h **** 
 362:include/asm/string.h **** /* we might want to write optimized versions of these later */
 363:include/asm/string.h **** #define __constant_count_memset(s,c,count) __memset_generic((s),(c),(count))
GAS LISTING  			page 44


 364:include/asm/string.h **** 
 365:include/asm/string.h **** /*
 366:include/asm/string.h ****  * memset(x,0,y) is a reasonably common thing to do, so we want to fill
 367:include/asm/string.h ****  * things 32 bits at a time even when we don't know the size of the
 368:include/asm/string.h ****  * area at compile-time..
 369:include/asm/string.h ****  */
 370:include/asm/string.h **** static inline void * __constant_c_memset(void * s, unsigned long c, size_t count)
 371:include/asm/string.h **** {
 372:include/asm/string.h **** int d0, d1;
 373:include/asm/string.h **** __asm__ __volatile__(
 374:include/asm/string.h **** 	"rep ; stosl\n\t"
 375:include/asm/string.h **** 	"testb $2,%b3\n\t"
 376:include/asm/string.h **** 	"je 1f\n\t"
 377:include/asm/string.h **** 	"stosw\n"
 378:include/asm/string.h **** 	"1:\ttestb $1,%b3\n\t"
 379:include/asm/string.h **** 	"je 2f\n\t"
 380:include/asm/string.h **** 	"stosb\n"
 381:include/asm/string.h **** 	"2:"
 382:include/asm/string.h **** 	:"=&c" (d0), "=&D" (d1)
 383:include/asm/string.h **** 	:"a" (c), "q" (count), "0" (count/4), "1" ((long) s)
 384:include/asm/string.h **** 	:"memory");
 385:include/asm/string.h **** return (s);	
 386:include/asm/string.h **** }
 387:include/asm/string.h **** 
 388:include/asm/string.h **** /* Added by Gertjan van Wingerde to make minix and sysv module work */
 389:include/asm/string.h **** #define __HAVE_ARCH_STRNLEN
 390:include/asm/string.h **** static inline size_t strnlen(const char * s, size_t count)
 391:include/asm/string.h **** {
 392:include/asm/string.h **** int d0;
 393:include/asm/string.h **** register int __res;
 394:include/asm/string.h **** __asm__ __volatile__(
 395:include/asm/string.h **** 	"movl %2,%0\n\t"
 396:include/asm/string.h **** 	"jmp 2f\n"
 397:include/asm/string.h **** 	"1:\tcmpb $0,(%0)\n\t"
 398:include/asm/string.h **** 	"je 3f\n\t"
 399:include/asm/string.h **** 	"incl %0\n"
 400:include/asm/string.h **** 	"2:\tdecl %1\n\t"
 401:include/asm/string.h **** 	"cmpl $-1,%1\n\t"
 402:include/asm/string.h **** 	"jne 1b\n"
 403:include/asm/string.h **** 	"3:\tsubl %2,%0"
 404:include/asm/string.h **** 	:"=a" (__res), "=&d" (d0)
 405:include/asm/string.h **** 	:"c" (s),"1" (count)
 406:include/asm/string.h **** 	:"memory");
 407:include/asm/string.h **** return __res;
 408:include/asm/string.h **** }
 409:include/asm/string.h **** /* end of additional stuff */
 410:include/asm/string.h **** 
 411:include/asm/string.h **** #define __HAVE_ARCH_STRSTR
 412:include/asm/string.h **** 
 413:include/asm/string.h **** extern char *strstr(const char *cs, const char *ct);
 414:include/asm/string.h **** 
 415:include/asm/string.h **** /*
 416:include/asm/string.h ****  * This looks horribly ugly, but the compiler can optimize it totally,
 417:include/asm/string.h ****  * as we by now know that both pattern and count is constant..
 418:include/asm/string.h ****  */
 419:include/asm/string.h **** static inline void * __constant_c_and_count_memset(void * s, unsigned long pattern, size_t count)
 420:include/asm/string.h **** {
GAS LISTING  			page 45


 421:include/asm/string.h **** 	switch (count) {
 422:include/asm/string.h **** 		case 0:
 423:include/asm/string.h **** 			return s;
 424:include/asm/string.h **** 		case 1:
 425:include/asm/string.h **** 			*(unsigned char *)s = pattern;
 426:include/asm/string.h **** 			return s;
 427:include/asm/string.h **** 		case 2:
 428:include/asm/string.h **** 			*(unsigned short *)s = pattern;
 429:include/asm/string.h **** 			return s;
 430:include/asm/string.h **** 		case 3:
 431:include/asm/string.h **** 			*(unsigned short *)s = pattern;
 432:include/asm/string.h **** 			*(2+(unsigned char *)s) = pattern;
 433:include/asm/string.h **** 			return s;
 434:include/asm/string.h **** 		case 4:
 435:include/asm/string.h **** 			*(unsigned long *)s = pattern;
 436:include/asm/string.h **** 			return s;
 437:include/asm/string.h **** 	}
 438:include/asm/string.h **** #define COMMON(x) \
 439:include/asm/string.h **** __asm__  __volatile__( \
 440:include/asm/string.h **** 	"rep ; stosl" \
 441:include/asm/string.h **** 	x \
 442:include/asm/string.h **** 	: "=&c" (d0), "=&D" (d1) \
 443:include/asm/string.h **** 	: "a" (pattern),"0" (count/4),"1" ((long) s) \
 444:include/asm/string.h **** 	: "memory")
 445:include/asm/string.h **** {
 446:include/asm/string.h **** 	int d0, d1;
 447:include/asm/string.h **** 	switch (count % 4) {
 448:include/asm/string.h **** 		case 0: COMMON(""); return s;
 368              	.loc 8 448 0
 369 0183 B9020000 	movl $2,%ecx
 369      00
 370 0188 89F7     	movl %esi,%edi
 371 018a 89D8     	movl %ebx,%eax
 372              	
 373 018c F3AB     	rep
 374              	
 375              	.LBE28:
 376              	.LBE27:
 377              	.LBE26:
 378              	.loc 1 208 0
 379 018e 89EA     	movl %ebp,%edx
 380 0190 8816     	movb %dl,(%esi)
 381              	.loc 1 209 0
 382 0192 8B4C2418 	movl 24(%esp),%ecx
 383 0196 66894E04 	movw %cx,4(%esi)
 384              	.loc 1 211 0
 385 019a 31FF     	xorl %edi,%edi
 386              	.L118:
 387 019c 39EF     	cmpl %ebp,%edi
 388 019e 7D45     	jge .L87
 389              	.LBB29:
 390              	.LBB30:
 374:include/linux/skbuff.h **** }
 375:include/linux/skbuff.h **** 
 376:include/linux/skbuff.h **** /**
 377:include/linux/skbuff.h ****  *	skb_cloned - is the buffer a clone
 378:include/linux/skbuff.h ****  *	@skb: buffer to check
GAS LISTING  			page 46


 379:include/linux/skbuff.h ****  *
 380:include/linux/skbuff.h ****  *	Returns true if the buffer was generated with skb_clone() and is
 381:include/linux/skbuff.h ****  *	one of multiple shared copies of the buffer. Cloned buffers are
 382:include/linux/skbuff.h ****  *	shared data so must not be written to under normal circumstances.
 383:include/linux/skbuff.h ****  */
 384:include/linux/skbuff.h **** static inline int skb_cloned(const struct sk_buff *skb)
 385:include/linux/skbuff.h **** {
 386:include/linux/skbuff.h **** 	return skb->cloned &&
 387:include/linux/skbuff.h **** 	       (atomic_read(&skb_shinfo(skb)->dataref) & SKB_DATAREF_MASK) != 1;
 388:include/linux/skbuff.h **** }
 389:include/linux/skbuff.h **** 
 390:include/linux/skbuff.h **** /**
 391:include/linux/skbuff.h ****  *	skb_header_cloned - is the header a clone
 392:include/linux/skbuff.h ****  *	@skb: buffer to check
 393:include/linux/skbuff.h ****  *
 394:include/linux/skbuff.h ****  *	Returns true if modifying the header part of the buffer requires
 395:include/linux/skbuff.h ****  *	the data to be copied.
 396:include/linux/skbuff.h ****  */
 397:include/linux/skbuff.h **** static inline int skb_header_cloned(const struct sk_buff *skb)
 398:include/linux/skbuff.h **** {
 399:include/linux/skbuff.h **** 	int dataref;
 400:include/linux/skbuff.h **** 
 401:include/linux/skbuff.h **** 	if (!skb->cloned)
 402:include/linux/skbuff.h **** 		return 0;
 403:include/linux/skbuff.h **** 
 404:include/linux/skbuff.h **** 	dataref = atomic_read(&skb_shinfo(skb)->dataref);
 405:include/linux/skbuff.h **** 	dataref = (dataref & SKB_DATAREF_MASK) - (dataref >> SKB_DATAREF_SHIFT);
 406:include/linux/skbuff.h **** 	return dataref != 1;
 407:include/linux/skbuff.h **** }
 408:include/linux/skbuff.h **** 
 409:include/linux/skbuff.h **** /**
 410:include/linux/skbuff.h ****  *	skb_header_release - release reference to header
 411:include/linux/skbuff.h ****  *	@skb: buffer to operate on
 412:include/linux/skbuff.h ****  *
 413:include/linux/skbuff.h ****  *	Drop a reference to the header part of the buffer.  This is done
 414:include/linux/skbuff.h ****  *	by acquiring a payload reference.  You must not read from the header
 415:include/linux/skbuff.h ****  *	part of skb->data after this.
 416:include/linux/skbuff.h ****  */
 417:include/linux/skbuff.h **** static inline void skb_header_release(struct sk_buff *skb)
 418:include/linux/skbuff.h **** {
 419:include/linux/skbuff.h **** 	BUG_ON(skb->nohdr);
 420:include/linux/skbuff.h **** 	skb->nohdr = 1;
 421:include/linux/skbuff.h **** 	atomic_add(1 << SKB_DATAREF_SHIFT, &skb_shinfo(skb)->dataref);
 422:include/linux/skbuff.h **** }
 423:include/linux/skbuff.h **** 
 424:include/linux/skbuff.h **** /**
 425:include/linux/skbuff.h ****  *	skb_shared - is the buffer shared
 426:include/linux/skbuff.h ****  *	@skb: buffer to check
 427:include/linux/skbuff.h ****  *
 428:include/linux/skbuff.h ****  *	Returns true if more than one person has a reference to this
 429:include/linux/skbuff.h ****  *	buffer.
 430:include/linux/skbuff.h ****  */
 431:include/linux/skbuff.h **** static inline int skb_shared(const struct sk_buff *skb)
 432:include/linux/skbuff.h **** {
 433:include/linux/skbuff.h **** 	return atomic_read(&skb->users) != 1;
 434:include/linux/skbuff.h **** }
 435:include/linux/skbuff.h **** 
GAS LISTING  			page 47


 436:include/linux/skbuff.h **** /**
 437:include/linux/skbuff.h ****  *	skb_share_check - check if buffer is shared and if so clone it
 438:include/linux/skbuff.h ****  *	@skb: buffer to check
 439:include/linux/skbuff.h ****  *	@pri: priority for memory allocation
 440:include/linux/skbuff.h ****  *
 441:include/linux/skbuff.h ****  *	If the buffer is shared the buffer is cloned and the old copy
 442:include/linux/skbuff.h ****  *	drops a reference. A new clone with a single reference is returned.
 443:include/linux/skbuff.h ****  *	If the buffer is not shared the original buffer is returned. When
 444:include/linux/skbuff.h ****  *	being called from interrupt status or with spinlocks held pri must
 445:include/linux/skbuff.h ****  *	be GFP_ATOMIC.
 446:include/linux/skbuff.h ****  *
 447:include/linux/skbuff.h ****  *	NULL is returned on a memory allocation failure.
 448:include/linux/skbuff.h ****  */
 449:include/linux/skbuff.h **** static inline struct sk_buff *skb_share_check(struct sk_buff *skb, int pri)
 450:include/linux/skbuff.h **** {
 451:include/linux/skbuff.h **** 	might_sleep_if(pri & __GFP_WAIT);
 452:include/linux/skbuff.h **** 	if (skb_shared(skb)) {
 453:include/linux/skbuff.h **** 		struct sk_buff *nskb = skb_clone(skb, pri);
 454:include/linux/skbuff.h **** 		kfree_skb(skb);
 455:include/linux/skbuff.h **** 		skb = nskb;
 456:include/linux/skbuff.h **** 	}
 457:include/linux/skbuff.h **** 	return skb;
 458:include/linux/skbuff.h **** }
 459:include/linux/skbuff.h **** 
 460:include/linux/skbuff.h **** /*
 461:include/linux/skbuff.h ****  *	Copy shared buffers into a new sk_buff. We effectively do COW on
 462:include/linux/skbuff.h ****  *	packets to handle cases where we have a local reader and forward
 463:include/linux/skbuff.h ****  *	and a couple of other messy ones. The normal one is tcpdumping
 464:include/linux/skbuff.h ****  *	a packet thats being forwarded.
 465:include/linux/skbuff.h ****  */
 466:include/linux/skbuff.h **** 
 467:include/linux/skbuff.h **** /**
 468:include/linux/skbuff.h ****  *	skb_unshare - make a copy of a shared buffer
 469:include/linux/skbuff.h ****  *	@skb: buffer to check
 470:include/linux/skbuff.h ****  *	@pri: priority for memory allocation
 471:include/linux/skbuff.h ****  *
 472:include/linux/skbuff.h ****  *	If the socket buffer is a clone then this function creates a new
 473:include/linux/skbuff.h ****  *	copy of the data, drops a reference count on the old copy and returns
 474:include/linux/skbuff.h ****  *	the new copy with the reference count at 1. If the buffer is not a clone
 475:include/linux/skbuff.h ****  *	the original buffer is returned. When called with a spinlock held or
 476:include/linux/skbuff.h ****  *	from interrupt state @pri must be %GFP_ATOMIC
 477:include/linux/skbuff.h ****  *
 478:include/linux/skbuff.h ****  *	%NULL is returned on a memory allocation failure.
 479:include/linux/skbuff.h ****  */
 480:include/linux/skbuff.h **** static inline struct sk_buff *skb_unshare(struct sk_buff *skb, int pri)
 481:include/linux/skbuff.h **** {
 482:include/linux/skbuff.h **** 	might_sleep_if(pri & __GFP_WAIT);
 483:include/linux/skbuff.h **** 	if (skb_cloned(skb)) {
 484:include/linux/skbuff.h **** 		struct sk_buff *nskb = skb_copy(skb, pri);
 485:include/linux/skbuff.h **** 		kfree_skb(skb);	/* Free our shared copy */
 486:include/linux/skbuff.h **** 		skb = nskb;
 487:include/linux/skbuff.h **** 	}
 488:include/linux/skbuff.h **** 	return skb;
 489:include/linux/skbuff.h **** }
 490:include/linux/skbuff.h **** 
 491:include/linux/skbuff.h **** /**
 492:include/linux/skbuff.h ****  *	skb_peek
GAS LISTING  			page 48


 493:include/linux/skbuff.h ****  *	@list_: list to peek at
 494:include/linux/skbuff.h ****  *
 495:include/linux/skbuff.h ****  *	Peek an &sk_buff. Unlike most other operations you _MUST_
 496:include/linux/skbuff.h ****  *	be careful with this one. A peek leaves the buffer on the
 497:include/linux/skbuff.h ****  *	list and someone else may run off with it. You must hold
 498:include/linux/skbuff.h ****  *	the appropriate locks or have a private queue to do this.
 499:include/linux/skbuff.h ****  *
 500:include/linux/skbuff.h ****  *	Returns %NULL for an empty list or a pointer to the head element.
 501:include/linux/skbuff.h ****  *	The reference count is not incremented and the reference is therefore
 502:include/linux/skbuff.h ****  *	volatile. Use with caution.
 503:include/linux/skbuff.h ****  */
 504:include/linux/skbuff.h **** static inline struct sk_buff *skb_peek(struct sk_buff_head *list_)
 505:include/linux/skbuff.h **** {
 506:include/linux/skbuff.h **** 	struct sk_buff *list = ((struct sk_buff *)list_)->next;
 507:include/linux/skbuff.h **** 	if (list == (struct sk_buff *)list_)
 508:include/linux/skbuff.h **** 		list = NULL;
 509:include/linux/skbuff.h **** 	return list;
 510:include/linux/skbuff.h **** }
 511:include/linux/skbuff.h **** 
 512:include/linux/skbuff.h **** /**
 513:include/linux/skbuff.h ****  *	skb_peek_tail
 514:include/linux/skbuff.h ****  *	@list_: list to peek at
 515:include/linux/skbuff.h ****  *
 516:include/linux/skbuff.h ****  *	Peek an &sk_buff. Unlike most other operations you _MUST_
 517:include/linux/skbuff.h ****  *	be careful with this one. A peek leaves the buffer on the
 518:include/linux/skbuff.h ****  *	list and someone else may run off with it. You must hold
 519:include/linux/skbuff.h ****  *	the appropriate locks or have a private queue to do this.
 520:include/linux/skbuff.h ****  *
 521:include/linux/skbuff.h ****  *	Returns %NULL for an empty list or a pointer to the tail element.
 522:include/linux/skbuff.h ****  *	The reference count is not incremented and the reference is therefore
 523:include/linux/skbuff.h ****  *	volatile. Use with caution.
 524:include/linux/skbuff.h ****  */
 525:include/linux/skbuff.h **** static inline struct sk_buff *skb_peek_tail(struct sk_buff_head *list_)
 526:include/linux/skbuff.h **** {
 527:include/linux/skbuff.h **** 	struct sk_buff *list = ((struct sk_buff *)list_)->prev;
 528:include/linux/skbuff.h **** 	if (list == (struct sk_buff *)list_)
 529:include/linux/skbuff.h **** 		list = NULL;
 530:include/linux/skbuff.h **** 	return list;
 531:include/linux/skbuff.h **** }
 532:include/linux/skbuff.h **** 
 533:include/linux/skbuff.h **** /**
 534:include/linux/skbuff.h ****  *	skb_queue_len	- get queue length
 535:include/linux/skbuff.h ****  *	@list_: list to measure
 536:include/linux/skbuff.h ****  *
 537:include/linux/skbuff.h ****  *	Return the length of an &sk_buff queue.
 538:include/linux/skbuff.h ****  */
 539:include/linux/skbuff.h **** static inline __u32 skb_queue_len(const struct sk_buff_head *list_)
 540:include/linux/skbuff.h **** {
 541:include/linux/skbuff.h **** 	return list_->qlen;
 542:include/linux/skbuff.h **** }
 543:include/linux/skbuff.h **** 
 544:include/linux/skbuff.h **** static inline void skb_queue_head_init(struct sk_buff_head *list)
 545:include/linux/skbuff.h **** {
 546:include/linux/skbuff.h **** 	spin_lock_init(&list->lock);
 547:include/linux/skbuff.h **** 	list->prev = list->next = (struct sk_buff *)list;
 548:include/linux/skbuff.h **** 	list->qlen = 0;
 549:include/linux/skbuff.h **** }
GAS LISTING  			page 49


 550:include/linux/skbuff.h **** 
 551:include/linux/skbuff.h **** /*
 552:include/linux/skbuff.h ****  *	Insert an sk_buff at the start of a list.
 553:include/linux/skbuff.h ****  *
 554:include/linux/skbuff.h ****  *	The "__skb_xxxx()" functions are the non-atomic ones that
 555:include/linux/skbuff.h ****  *	can only be called with interrupts disabled.
 556:include/linux/skbuff.h ****  */
 557:include/linux/skbuff.h **** 
 558:include/linux/skbuff.h **** /**
 559:include/linux/skbuff.h ****  *	__skb_queue_head - queue a buffer at the list head
 560:include/linux/skbuff.h ****  *	@list: list to use
 561:include/linux/skbuff.h ****  *	@newsk: buffer to queue
 562:include/linux/skbuff.h ****  *
 563:include/linux/skbuff.h ****  *	Queue a buffer at the start of a list. This function takes no locks
 564:include/linux/skbuff.h ****  *	and you must therefore hold required locks before calling it.
 565:include/linux/skbuff.h ****  *
 566:include/linux/skbuff.h ****  *	A buffer cannot be placed on two lists at the same time.
 567:include/linux/skbuff.h ****  */
 568:include/linux/skbuff.h **** extern void skb_queue_head(struct sk_buff_head *list, struct sk_buff *newsk);
 569:include/linux/skbuff.h **** static inline void __skb_queue_head(struct sk_buff_head *list,
 570:include/linux/skbuff.h **** 				    struct sk_buff *newsk)
 571:include/linux/skbuff.h **** {
 572:include/linux/skbuff.h **** 	struct sk_buff *prev, *next;
 573:include/linux/skbuff.h **** 
 574:include/linux/skbuff.h **** 	newsk->list = list;
 575:include/linux/skbuff.h **** 	list->qlen++;
 576:include/linux/skbuff.h **** 	prev = (struct sk_buff *)list;
 577:include/linux/skbuff.h **** 	next = prev->next;
 578:include/linux/skbuff.h **** 	newsk->next = next;
 579:include/linux/skbuff.h **** 	newsk->prev = prev;
 580:include/linux/skbuff.h **** 	next->prev  = prev->next = newsk;
 581:include/linux/skbuff.h **** }
 582:include/linux/skbuff.h **** 
 583:include/linux/skbuff.h **** /**
 584:include/linux/skbuff.h ****  *	__skb_queue_tail - queue a buffer at the list tail
 585:include/linux/skbuff.h ****  *	@list: list to use
 586:include/linux/skbuff.h ****  *	@newsk: buffer to queue
 587:include/linux/skbuff.h ****  *
 588:include/linux/skbuff.h ****  *	Queue a buffer at the end of a list. This function takes no locks
 589:include/linux/skbuff.h ****  *	and you must therefore hold required locks before calling it.
 590:include/linux/skbuff.h ****  *
 591:include/linux/skbuff.h ****  *	A buffer cannot be placed on two lists at the same time.
 592:include/linux/skbuff.h ****  */
 593:include/linux/skbuff.h **** extern void skb_queue_tail(struct sk_buff_head *list, struct sk_buff *newsk);
 594:include/linux/skbuff.h **** static inline void __skb_queue_tail(struct sk_buff_head *list,
 595:include/linux/skbuff.h **** 				   struct sk_buff *newsk)
 596:include/linux/skbuff.h **** {
 597:include/linux/skbuff.h **** 	struct sk_buff *prev, *next;
 598:include/linux/skbuff.h **** 
 599:include/linux/skbuff.h **** 	newsk->list = list;
 600:include/linux/skbuff.h **** 	list->qlen++;
 601:include/linux/skbuff.h **** 	next = (struct sk_buff *)list;
 602:include/linux/skbuff.h **** 	prev = next->prev;
 603:include/linux/skbuff.h **** 	newsk->next = next;
 604:include/linux/skbuff.h **** 	newsk->prev = prev;
 605:include/linux/skbuff.h **** 	next->prev  = prev->next = newsk;
 606:include/linux/skbuff.h **** }
GAS LISTING  			page 50


 607:include/linux/skbuff.h **** 
 608:include/linux/skbuff.h **** 
 609:include/linux/skbuff.h **** /**
 610:include/linux/skbuff.h ****  *	__skb_dequeue - remove from the head of the queue
 611:include/linux/skbuff.h ****  *	@list: list to dequeue from
 612:include/linux/skbuff.h ****  *
 613:include/linux/skbuff.h ****  *	Remove the head of the list. This function does not take any locks
 614:include/linux/skbuff.h ****  *	so must be used with appropriate locks held only. The head item is
 615:include/linux/skbuff.h ****  *	returned or %NULL if the list is empty.
 616:include/linux/skbuff.h ****  */
 617:include/linux/skbuff.h **** extern struct sk_buff *skb_dequeue(struct sk_buff_head *list);
 618:include/linux/skbuff.h **** static inline struct sk_buff *__skb_dequeue(struct sk_buff_head *list)
 619:include/linux/skbuff.h **** {
 620:include/linux/skbuff.h **** 	struct sk_buff *next, *prev, *result;
 621:include/linux/skbuff.h **** 
 622:include/linux/skbuff.h **** 	prev = (struct sk_buff *) list;
 623:include/linux/skbuff.h **** 	next = prev->next;
 624:include/linux/skbuff.h **** 	result = NULL;
 625:include/linux/skbuff.h **** 	if (next != prev) {
 626:include/linux/skbuff.h **** 		result	     = next;
 627:include/linux/skbuff.h **** 		next	     = next->next;
 628:include/linux/skbuff.h **** 		list->qlen--;
 629:include/linux/skbuff.h **** 		next->prev   = prev;
 630:include/linux/skbuff.h **** 		prev->next   = next;
 631:include/linux/skbuff.h **** 		result->next = result->prev = NULL;
 632:include/linux/skbuff.h **** 		result->list = NULL;
 633:include/linux/skbuff.h **** 	}
 634:include/linux/skbuff.h **** 	return result;
 635:include/linux/skbuff.h **** }
 636:include/linux/skbuff.h **** 
 637:include/linux/skbuff.h **** 
 638:include/linux/skbuff.h **** /*
 639:include/linux/skbuff.h ****  *	Insert a packet on a list.
 640:include/linux/skbuff.h ****  */
 641:include/linux/skbuff.h **** extern void        skb_insert(struct sk_buff *old, struct sk_buff *newsk);
 642:include/linux/skbuff.h **** static inline void __skb_insert(struct sk_buff *newsk,
 643:include/linux/skbuff.h **** 				struct sk_buff *prev, struct sk_buff *next,
 644:include/linux/skbuff.h **** 				struct sk_buff_head *list)
 645:include/linux/skbuff.h **** {
 646:include/linux/skbuff.h **** 	newsk->next = next;
 647:include/linux/skbuff.h **** 	newsk->prev = prev;
 648:include/linux/skbuff.h **** 	next->prev  = prev->next = newsk;
 649:include/linux/skbuff.h **** 	newsk->list = list;
 650:include/linux/skbuff.h **** 	list->qlen++;
 651:include/linux/skbuff.h **** }
 652:include/linux/skbuff.h **** 
 653:include/linux/skbuff.h **** /*
 654:include/linux/skbuff.h ****  *	Place a packet after a given packet in a list.
 655:include/linux/skbuff.h ****  */
 656:include/linux/skbuff.h **** extern void	   skb_append(struct sk_buff *old, struct sk_buff *newsk);
 657:include/linux/skbuff.h **** static inline void __skb_append(struct sk_buff *old, struct sk_buff *newsk)
 658:include/linux/skbuff.h **** {
 659:include/linux/skbuff.h **** 	__skb_insert(newsk, old, old->next, old->list);
 660:include/linux/skbuff.h **** }
 661:include/linux/skbuff.h **** 
 662:include/linux/skbuff.h **** /*
 663:include/linux/skbuff.h ****  * remove sk_buff from list. _Must_ be called atomically, and with
GAS LISTING  			page 51


 664:include/linux/skbuff.h ****  * the list known..
 665:include/linux/skbuff.h ****  */
 666:include/linux/skbuff.h **** extern void	   skb_unlink(struct sk_buff *skb);
 667:include/linux/skbuff.h **** static inline void __skb_unlink(struct sk_buff *skb, struct sk_buff_head *list)
 668:include/linux/skbuff.h **** {
 669:include/linux/skbuff.h **** 	struct sk_buff *next, *prev;
 670:include/linux/skbuff.h **** 
 671:include/linux/skbuff.h **** 	list->qlen--;
 672:include/linux/skbuff.h **** 	next	   = skb->next;
 673:include/linux/skbuff.h **** 	prev	   = skb->prev;
 674:include/linux/skbuff.h **** 	skb->next  = skb->prev = NULL;
 675:include/linux/skbuff.h **** 	skb->list  = NULL;
 676:include/linux/skbuff.h **** 	next->prev = prev;
 677:include/linux/skbuff.h **** 	prev->next = next;
 678:include/linux/skbuff.h **** }
 679:include/linux/skbuff.h **** 
 680:include/linux/skbuff.h **** 
 681:include/linux/skbuff.h **** /* XXX: more streamlined implementation */
 682:include/linux/skbuff.h **** 
 683:include/linux/skbuff.h **** /**
 684:include/linux/skbuff.h ****  *	__skb_dequeue_tail - remove from the tail of the queue
 685:include/linux/skbuff.h ****  *	@list: list to dequeue from
 686:include/linux/skbuff.h ****  *
 687:include/linux/skbuff.h ****  *	Remove the tail of the list. This function does not take any locks
 688:include/linux/skbuff.h ****  *	so must be used with appropriate locks held only. The tail item is
 689:include/linux/skbuff.h ****  *	returned or %NULL if the list is empty.
 690:include/linux/skbuff.h ****  */
 691:include/linux/skbuff.h **** extern struct sk_buff *skb_dequeue_tail(struct sk_buff_head *list);
 692:include/linux/skbuff.h **** static inline struct sk_buff *__skb_dequeue_tail(struct sk_buff_head *list)
 693:include/linux/skbuff.h **** {
 694:include/linux/skbuff.h **** 	struct sk_buff *skb = skb_peek_tail(list);
 695:include/linux/skbuff.h **** 	if (skb)
 696:include/linux/skbuff.h **** 		__skb_unlink(skb, list);
 697:include/linux/skbuff.h **** 	return skb;
 698:include/linux/skbuff.h **** }
 699:include/linux/skbuff.h **** 
 700:include/linux/skbuff.h **** 
 701:include/linux/skbuff.h **** static inline int skb_is_nonlinear(const struct sk_buff *skb)
 702:include/linux/skbuff.h **** {
 703:include/linux/skbuff.h **** 	return skb->data_len;
 704:include/linux/skbuff.h **** }
 705:include/linux/skbuff.h **** 
 706:include/linux/skbuff.h **** static inline unsigned int skb_headlen(const struct sk_buff *skb)
 707:include/linux/skbuff.h **** {
 708:include/linux/skbuff.h **** 	return skb->len - skb->data_len;
 709:include/linux/skbuff.h **** }
 710:include/linux/skbuff.h **** 
 711:include/linux/skbuff.h **** static inline int skb_pagelen(const struct sk_buff *skb)
 712:include/linux/skbuff.h **** {
 713:include/linux/skbuff.h **** 	int i, len = 0;
 714:include/linux/skbuff.h **** 
 715:include/linux/skbuff.h **** 	for (i = (int)skb_shinfo(skb)->nr_frags - 1; i >= 0; i--)
 716:include/linux/skbuff.h **** 		len += skb_shinfo(skb)->frags[i].size;
 717:include/linux/skbuff.h **** 	return len + skb_headlen(skb);
 718:include/linux/skbuff.h **** }
 719:include/linux/skbuff.h **** 
 720:include/linux/skbuff.h **** static inline void skb_fill_page_desc(struct sk_buff *skb, int i,
GAS LISTING  			page 52


 721:include/linux/skbuff.h **** 				      struct page *page, int off, int size)
 722:include/linux/skbuff.h **** {
 723:include/linux/skbuff.h **** 	skb_frag_t *frag = &skb_shinfo(skb)->frags[i];
 724:include/linux/skbuff.h **** 
 725:include/linux/skbuff.h **** 	frag->page		  = page;
 726:include/linux/skbuff.h **** 	frag->page_offset	  = off;
 727:include/linux/skbuff.h **** 	frag->size		  = size;
 728:include/linux/skbuff.h **** 	skb_shinfo(skb)->nr_frags = i + 1;
 729:include/linux/skbuff.h **** }
 730:include/linux/skbuff.h **** 
 731:include/linux/skbuff.h **** #define SKB_PAGE_ASSERT(skb) 	BUG_ON(skb_shinfo(skb)->nr_frags)
 732:include/linux/skbuff.h **** #define SKB_FRAG_ASSERT(skb) 	BUG_ON(skb_shinfo(skb)->frag_list)
 733:include/linux/skbuff.h **** #define SKB_LINEAR_ASSERT(skb)  BUG_ON(skb_is_nonlinear(skb))
 734:include/linux/skbuff.h **** 
 735:include/linux/skbuff.h **** /*
 736:include/linux/skbuff.h ****  *	Add data to an sk_buff
 737:include/linux/skbuff.h ****  */
 738:include/linux/skbuff.h **** static inline unsigned char *__skb_put(struct sk_buff *skb, unsigned int len)
 739:include/linux/skbuff.h **** {
 740:include/linux/skbuff.h **** 	unsigned char *tmp = skb->tail;
 741:include/linux/skbuff.h **** 	SKB_LINEAR_ASSERT(skb);
 742:include/linux/skbuff.h **** 	skb->tail += len;
 743:include/linux/skbuff.h **** 	skb->len  += len;
 744:include/linux/skbuff.h **** 	return tmp;
 745:include/linux/skbuff.h **** }
 746:include/linux/skbuff.h **** 
 747:include/linux/skbuff.h **** /**
 748:include/linux/skbuff.h ****  *	skb_put - add data to a buffer
 749:include/linux/skbuff.h ****  *	@skb: buffer to use
 750:include/linux/skbuff.h ****  *	@len: amount of data to add
 751:include/linux/skbuff.h ****  *
 752:include/linux/skbuff.h ****  *	This function extends the used data area of the buffer. If this would
 753:include/linux/skbuff.h ****  *	exceed the total buffer size the kernel will panic. A pointer to the
 754:include/linux/skbuff.h ****  *	first byte of the extra data is returned.
 755:include/linux/skbuff.h ****  */
 756:include/linux/skbuff.h **** static inline unsigned char *skb_put(struct sk_buff *skb, unsigned int len)
 757:include/linux/skbuff.h **** {
 758:include/linux/skbuff.h **** 	unsigned char *tmp = skb->tail;
 759:include/linux/skbuff.h **** 	SKB_LINEAR_ASSERT(skb);
 760:include/linux/skbuff.h **** 	skb->tail += len;
 761:include/linux/skbuff.h **** 	skb->len  += len;
 762:include/linux/skbuff.h **** 	if (unlikely(skb->tail>skb->end))
 763:include/linux/skbuff.h **** 		skb_over_panic(skb, len, current_text_addr());
 764:include/linux/skbuff.h **** 	return tmp;
 765:include/linux/skbuff.h **** }
 766:include/linux/skbuff.h **** 
 767:include/linux/skbuff.h **** static inline unsigned char *__skb_push(struct sk_buff *skb, unsigned int len)
 768:include/linux/skbuff.h **** {
 769:include/linux/skbuff.h **** 	skb->data -= len;
 770:include/linux/skbuff.h **** 	skb->len  += len;
 771:include/linux/skbuff.h **** 	return skb->data;
 772:include/linux/skbuff.h **** }
 773:include/linux/skbuff.h **** 
 774:include/linux/skbuff.h **** /**
 775:include/linux/skbuff.h ****  *	skb_push - add data to the start of a buffer
 776:include/linux/skbuff.h ****  *	@skb: buffer to use
 777:include/linux/skbuff.h ****  *	@len: amount of data to add
GAS LISTING  			page 53


 778:include/linux/skbuff.h ****  *
 779:include/linux/skbuff.h ****  *	This function extends the used data area of the buffer at the buffer
 780:include/linux/skbuff.h ****  *	start. If this would exceed the total buffer headroom the kernel will
 781:include/linux/skbuff.h ****  *	panic. A pointer to the first byte of the extra data is returned.
 782:include/linux/skbuff.h ****  */
 783:include/linux/skbuff.h **** static inline unsigned char *skb_push(struct sk_buff *skb, unsigned int len)
 784:include/linux/skbuff.h **** {
 785:include/linux/skbuff.h **** 	skb->data -= len;
 786:include/linux/skbuff.h **** 	skb->len  += len;
 787:include/linux/skbuff.h **** 	if (unlikely(skb->data<skb->head))
 788:include/linux/skbuff.h **** 		skb_under_panic(skb, len, current_text_addr());
 789:include/linux/skbuff.h **** 	return skb->data;
 790:include/linux/skbuff.h **** }
 791:include/linux/skbuff.h **** 
 792:include/linux/skbuff.h **** static inline unsigned char *__skb_pull(struct sk_buff *skb, unsigned int len)
 793:include/linux/skbuff.h **** {
 794:include/linux/skbuff.h **** 	skb->len -= len;
 795:include/linux/skbuff.h **** 	BUG_ON(skb->len < skb->data_len);
 796:include/linux/skbuff.h **** 	return skb->data += len;
 797:include/linux/skbuff.h **** }
 798:include/linux/skbuff.h **** 
 799:include/linux/skbuff.h **** /**
 800:include/linux/skbuff.h ****  *	skb_pull - remove data from the start of a buffer
 801:include/linux/skbuff.h ****  *	@skb: buffer to use
 802:include/linux/skbuff.h ****  *	@len: amount of data to remove
 803:include/linux/skbuff.h ****  *
 804:include/linux/skbuff.h ****  *	This function removes data from the start of a buffer, returning
 805:include/linux/skbuff.h ****  *	the memory to the headroom. A pointer to the next data in the buffer
 806:include/linux/skbuff.h ****  *	is returned. Once the data has been pulled future pushes will overwrite
 807:include/linux/skbuff.h ****  *	the old data.
 808:include/linux/skbuff.h ****  */
 809:include/linux/skbuff.h **** static inline unsigned char *skb_pull(struct sk_buff *skb, unsigned int len)
 810:include/linux/skbuff.h **** {
 811:include/linux/skbuff.h **** 	return unlikely(len > skb->len) ? NULL : __skb_pull(skb, len);
 812:include/linux/skbuff.h **** }
 813:include/linux/skbuff.h **** 
 814:include/linux/skbuff.h **** extern unsigned char *__pskb_pull_tail(struct sk_buff *skb, int delta);
 815:include/linux/skbuff.h **** 
 816:include/linux/skbuff.h **** static inline unsigned char *__pskb_pull(struct sk_buff *skb, unsigned int len)
 817:include/linux/skbuff.h **** {
 818:include/linux/skbuff.h **** 	if (len > skb_headlen(skb) &&
 819:include/linux/skbuff.h **** 	    !__pskb_pull_tail(skb, len-skb_headlen(skb)))
 820:include/linux/skbuff.h **** 		return NULL;
 821:include/linux/skbuff.h **** 	skb->len -= len;
 822:include/linux/skbuff.h **** 	return skb->data += len;
 823:include/linux/skbuff.h **** }
 824:include/linux/skbuff.h **** 
 825:include/linux/skbuff.h **** static inline unsigned char *pskb_pull(struct sk_buff *skb, unsigned int len)
 826:include/linux/skbuff.h **** {
 827:include/linux/skbuff.h **** 	return unlikely(len > skb->len) ? NULL : __pskb_pull(skb, len);
 828:include/linux/skbuff.h **** }
 829:include/linux/skbuff.h **** 
 830:include/linux/skbuff.h **** static inline int pskb_may_pull(struct sk_buff *skb, unsigned int len)
 831:include/linux/skbuff.h **** {
 832:include/linux/skbuff.h **** 	if (likely(len <= skb_headlen(skb)))
 833:include/linux/skbuff.h **** 		return 1;
 834:include/linux/skbuff.h **** 	if (unlikely(len > skb->len))
GAS LISTING  			page 54


 835:include/linux/skbuff.h **** 		return 0;
 836:include/linux/skbuff.h **** 	return __pskb_pull_tail(skb, len-skb_headlen(skb)) != NULL;
 837:include/linux/skbuff.h **** }
 838:include/linux/skbuff.h **** 
 839:include/linux/skbuff.h **** /**
 840:include/linux/skbuff.h ****  *	skb_headroom - bytes at buffer head
 841:include/linux/skbuff.h ****  *	@skb: buffer to check
 842:include/linux/skbuff.h ****  *
 843:include/linux/skbuff.h ****  *	Return the number of bytes of free space at the head of an &sk_buff.
 844:include/linux/skbuff.h ****  */
 845:include/linux/skbuff.h **** static inline int skb_headroom(const struct sk_buff *skb)
 846:include/linux/skbuff.h **** {
 847:include/linux/skbuff.h **** 	return skb->data - skb->head;
 848:include/linux/skbuff.h **** }
 849:include/linux/skbuff.h **** 
 850:include/linux/skbuff.h **** /**
 851:include/linux/skbuff.h ****  *	skb_tailroom - bytes at buffer end
 852:include/linux/skbuff.h ****  *	@skb: buffer to check
 853:include/linux/skbuff.h ****  *
 854:include/linux/skbuff.h ****  *	Return the number of bytes of free space at the tail of an sk_buff
 855:include/linux/skbuff.h ****  */
 856:include/linux/skbuff.h **** static inline int skb_tailroom(const struct sk_buff *skb)
 857:include/linux/skbuff.h **** {
 858:include/linux/skbuff.h **** 	return skb_is_nonlinear(skb) ? 0 : skb->end - skb->tail;
 859:include/linux/skbuff.h **** }
 860:include/linux/skbuff.h **** 
 861:include/linux/skbuff.h **** /**
 862:include/linux/skbuff.h ****  *	skb_reserve - adjust headroom
 863:include/linux/skbuff.h ****  *	@skb: buffer to alter
 864:include/linux/skbuff.h ****  *	@len: bytes to move
 865:include/linux/skbuff.h ****  *
 866:include/linux/skbuff.h ****  *	Increase the headroom of an empty &sk_buff by reducing the tail
 867:include/linux/skbuff.h ****  *	room. This is only allowed for an empty buffer.
 868:include/linux/skbuff.h ****  */
 869:include/linux/skbuff.h **** static inline void skb_reserve(struct sk_buff *skb, unsigned int len)
 870:include/linux/skbuff.h **** {
 871:include/linux/skbuff.h **** 	skb->data += len;
 872:include/linux/skbuff.h **** 	skb->tail += len;
 873:include/linux/skbuff.h **** }
 874:include/linux/skbuff.h **** 
 875:include/linux/skbuff.h **** /*
 876:include/linux/skbuff.h ****  * CPUs often take a performance hit when accessing unaligned memory
 877:include/linux/skbuff.h ****  * locations. The actual performance hit varies, it can be small if the
 878:include/linux/skbuff.h ****  * hardware handles it or large if we have to take an exception and fix it
 879:include/linux/skbuff.h ****  * in software.
 880:include/linux/skbuff.h ****  *
 881:include/linux/skbuff.h ****  * Since an ethernet header is 14 bytes network drivers often end up with
 882:include/linux/skbuff.h ****  * the IP header at an unaligned offset. The IP header can be aligned by
 883:include/linux/skbuff.h ****  * shifting the start of the packet by 2 bytes. Drivers should do this
 884:include/linux/skbuff.h ****  * with:
 885:include/linux/skbuff.h ****  *
 886:include/linux/skbuff.h ****  * skb_reserve(NET_IP_ALIGN);
 887:include/linux/skbuff.h ****  *
 888:include/linux/skbuff.h ****  * The downside to this alignment of the IP header is that the DMA is now
 889:include/linux/skbuff.h ****  * unaligned. On some architectures the cost of an unaligned DMA is high
 890:include/linux/skbuff.h ****  * and this cost outweighs the gains made by aligning the IP header.
 891:include/linux/skbuff.h ****  * 
GAS LISTING  			page 55


 892:include/linux/skbuff.h ****  * Since this trade off varies between architectures, we allow NET_IP_ALIGN
 893:include/linux/skbuff.h ****  * to be overridden.
 894:include/linux/skbuff.h ****  */
 895:include/linux/skbuff.h **** #ifndef NET_IP_ALIGN
 896:include/linux/skbuff.h **** #define NET_IP_ALIGN	2
 897:include/linux/skbuff.h **** #endif
 898:include/linux/skbuff.h **** 
 899:include/linux/skbuff.h **** extern int ___pskb_trim(struct sk_buff *skb, unsigned int len, int realloc);
 900:include/linux/skbuff.h **** 
 901:include/linux/skbuff.h **** static inline void __skb_trim(struct sk_buff *skb, unsigned int len)
 902:include/linux/skbuff.h **** {
 903:include/linux/skbuff.h **** 	if (!skb->data_len) {
 904:include/linux/skbuff.h **** 		skb->len  = len;
 905:include/linux/skbuff.h **** 		skb->tail = skb->data + len;
 906:include/linux/skbuff.h **** 	} else
 907:include/linux/skbuff.h **** 		___pskb_trim(skb, len, 0);
 908:include/linux/skbuff.h **** }
 909:include/linux/skbuff.h **** 
 910:include/linux/skbuff.h **** /**
 911:include/linux/skbuff.h ****  *	skb_trim - remove end from a buffer
 912:include/linux/skbuff.h ****  *	@skb: buffer to alter
 913:include/linux/skbuff.h ****  *	@len: new length
 914:include/linux/skbuff.h ****  *
 915:include/linux/skbuff.h ****  *	Cut the length of a buffer down by removing data from the tail. If
 916:include/linux/skbuff.h ****  *	the buffer is already under the length specified it is not modified.
 917:include/linux/skbuff.h ****  */
 918:include/linux/skbuff.h **** static inline void skb_trim(struct sk_buff *skb, unsigned int len)
 919:include/linux/skbuff.h **** {
 920:include/linux/skbuff.h **** 	if (skb->len > len)
 921:include/linux/skbuff.h **** 		__skb_trim(skb, len);
 922:include/linux/skbuff.h **** }
 923:include/linux/skbuff.h **** 
 924:include/linux/skbuff.h **** 
 925:include/linux/skbuff.h **** static inline int __pskb_trim(struct sk_buff *skb, unsigned int len)
 926:include/linux/skbuff.h **** {
 927:include/linux/skbuff.h **** 	if (!skb->data_len) {
 928:include/linux/skbuff.h **** 		skb->len  = len;
 929:include/linux/skbuff.h **** 		skb->tail = skb->data+len;
 930:include/linux/skbuff.h **** 		return 0;
 931:include/linux/skbuff.h **** 	}
 932:include/linux/skbuff.h **** 	return ___pskb_trim(skb, len, 1);
 933:include/linux/skbuff.h **** }
 934:include/linux/skbuff.h **** 
 935:include/linux/skbuff.h **** static inline int pskb_trim(struct sk_buff *skb, unsigned int len)
 936:include/linux/skbuff.h **** {
 937:include/linux/skbuff.h **** 	return (len < skb->len) ? __pskb_trim(skb, len) : 0;
 938:include/linux/skbuff.h **** }
 939:include/linux/skbuff.h **** 
 940:include/linux/skbuff.h **** /**
 941:include/linux/skbuff.h ****  *	skb_orphan - orphan a buffer
 942:include/linux/skbuff.h ****  *	@skb: buffer to orphan
 943:include/linux/skbuff.h ****  *
 944:include/linux/skbuff.h ****  *	If a buffer currently has an owner then we call the owner's
 945:include/linux/skbuff.h ****  *	destructor function and make the @skb unowned. The buffer continues
 946:include/linux/skbuff.h ****  *	to exist but is no longer charged to its former owner.
 947:include/linux/skbuff.h ****  */
 948:include/linux/skbuff.h **** static inline void skb_orphan(struct sk_buff *skb)
GAS LISTING  			page 56


 949:include/linux/skbuff.h **** {
 950:include/linux/skbuff.h **** 	if (skb->destructor)
 951:include/linux/skbuff.h **** 		skb->destructor(skb);
 952:include/linux/skbuff.h **** 	skb->destructor = NULL;
 953:include/linux/skbuff.h **** 	skb->sk		= NULL;
 954:include/linux/skbuff.h **** }
 955:include/linux/skbuff.h **** 
 956:include/linux/skbuff.h **** /**
 957:include/linux/skbuff.h ****  *	__skb_queue_purge - empty a list
 958:include/linux/skbuff.h ****  *	@list: list to empty
 959:include/linux/skbuff.h ****  *
 960:include/linux/skbuff.h ****  *	Delete all buffers on an &sk_buff list. Each buffer is removed from
 961:include/linux/skbuff.h ****  *	the list and one reference dropped. This function does not take the
 962:include/linux/skbuff.h ****  *	list lock and the caller must hold the relevant locks to use it.
 963:include/linux/skbuff.h ****  */
 964:include/linux/skbuff.h **** extern void skb_queue_purge(struct sk_buff_head *list);
 965:include/linux/skbuff.h **** static inline void __skb_queue_purge(struct sk_buff_head *list)
 966:include/linux/skbuff.h **** {
 967:include/linux/skbuff.h **** 	struct sk_buff *skb;
 968:include/linux/skbuff.h **** 	while ((skb = __skb_dequeue(list)) != NULL)
 969:include/linux/skbuff.h **** 		kfree_skb(skb);
 970:include/linux/skbuff.h **** }
 971:include/linux/skbuff.h **** 
 972:include/linux/skbuff.h **** #ifndef CONFIG_HAVE_ARCH_DEV_ALLOC_SKB
 973:include/linux/skbuff.h **** /**
 974:include/linux/skbuff.h ****  *	__dev_alloc_skb - allocate an skbuff for sending
 975:include/linux/skbuff.h ****  *	@length: length to allocate
 976:include/linux/skbuff.h ****  *	@gfp_mask: get_free_pages mask, passed to alloc_skb
 977:include/linux/skbuff.h ****  *
 978:include/linux/skbuff.h ****  *	Allocate a new &sk_buff and assign it a usage count of one. The
 979:include/linux/skbuff.h ****  *	buffer has unspecified headroom built in. Users should allocate
 980:include/linux/skbuff.h ****  *	the headroom they think they need without accounting for the
 981:include/linux/skbuff.h ****  *	built in space. The built in space is used for optimisations.
 982:include/linux/skbuff.h ****  *
 983:include/linux/skbuff.h ****  *	%NULL is returned in there is no free memory.
 984:include/linux/skbuff.h ****  */
 985:include/linux/skbuff.h **** static inline struct sk_buff *__dev_alloc_skb(unsigned int length,
 986:include/linux/skbuff.h **** 					      int gfp_mask)
 987:include/linux/skbuff.h **** {
 988:include/linux/skbuff.h **** 	struct sk_buff *skb = alloc_skb(length + 16, gfp_mask);
 391              	.loc 6 988 0
 392 01a0 FF742420 	pushl 32(%esp)
 393              	.LCFI26:
 394 01a4 8B54241C 	movl 28(%esp),%edx
 395 01a8 8B4C2420 	movl 32(%esp),%ecx
 396 01ac 8D440A10 	leal 16(%edx,%ecx),%eax
 397 01b0 50       	pushl %eax
 398              	.LCFI27:
 399 01b1 E8FCFFFF 	call alloc_skb
 399      FF
 400 01b6 5B       	popl %ebx
 401              	.LCFI28:
 989:include/linux/skbuff.h **** 	if (likely(skb))
 402              	.loc 6 989 0
 403 01b7 85C0     	testl %eax,%eax
 404              	.loc 6 988 0
 405 01b9 5A       	popl %edx
GAS LISTING  			page 57


 406              	.LCFI29:
 407              	.loc 6 989 0
 408 01ba 740E     	je .L89
 409              	.LBB31:
 410              	.LBB32:
 411              	.loc 6 871 0
 412 01bc 8380A800 	addl $16,168(%eax)
 412      000010
 413              	.loc 6 872 0
 414 01c3 8380AC00 	addl $16,172(%eax)
 414      000010
 415              	.L89:
 416              	.LBE32:
 417              	.LBE31:
 418              	.LBE30:
 419              	.LBE29:
 420              	.loc 1 214 0
 421 01ca 85C0     	testl %eax,%eax
 422              	.loc 6 987 0
 423 01cc 8944BE08 	movl %eax,8(%esi,%edi,4)
 424              	.loc 1 214 0
 425 01d0 74AE     	je .L117
 426              	.LBB33:
 427              	.LBB34:
 428              	.loc 6 871 0
 429 01d2 8B54241C 	movl 28(%esp),%edx
 430 01d6 0190A800 	addl %edx,168(%eax)
 430      0000
 431              	.loc 6 872 0
 432 01dc 0190AC00 	addl %edx,172(%eax)
 432      0000
 433              	.LBE34:
 434              	.LBE33:
 435              	.loc 1 211 0
 436 01e2 47       	incl %edi
 437 01e3 EBB7     	jmp .L118
 438              	.L87:
 217:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		}
 218:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		skb_reserve(txb->fragments[i], headroom);
 219:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	}
 220:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	if (unlikely(i != nr_frags)) {
 439              	.loc 1 220 0
 440 01e5 39EF     	cmpl %ebp,%edi
 221:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		while (i >= 0)
 222:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 			dev_kfree_skb_any(txb->fragments[i--]);
 223:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		kfree(txb);
 224:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		return NULL;
 225:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	}
 226:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	return txb;
 441              	.loc 1 226 0
 442 01e7 89F0     	movl %esi,%eax
 443              	.loc 1 220 0
 444 01e9 7477     	je .L38
 445              	.L120:
 446              	.loc 6 373 0
 447 01eb 85FF     	testl %edi,%edi
 448 01ed 786A     	js .L116
GAS LISTING  			page 58


 449              	.LBB35:
 450              	.loc 5 658 0
 451 01ef 89F8     	movl %edi,%eax
 452 01f1 8B548608 	movl 8(%esi,%eax,4),%edx
 453 01f5 4F       	decl %edi
 454              	.LBB36:
 455              	.LBB37:
 456              	.LBB38:
 457              	.loc 4 91 0
 458 01f6 B800E0FF 	movl $-8192,%eax
 458      FF
 459              	
 460 01fb 21E0     	andl %esp,%eax
 461              	
 462              	.LBE38:
 463              	.LBE37:
 464              	.loc 4 89 0
 465 01fd F7401400 	testl $268369920,20(%eax)
 465      00FF0F
 466 0204 7507     	jne .L99
 467              	.LBB39:
 468              	.loc 5 659 0
 469              	
 470 0206 9C58     	pushfl
 471              	
 472              	.LBE39:
 473 0208 F6C402   	testb $2,%ah
 474 020b 752B     	jne .L98
 475              	.L99:
 476              	.LBB40:
 477              	.LBB41:
 478              	.LBB42:
 479              	.LBB43:
 480              	.loc 3 135 0
 481              	
 482 020d FF8AA000 	decl 160(%edx)
 482      00000F94 
 482      C0
 483              	
 484              	.LBE43:
 485              	.LBE42:
 486              	.loc 3 132 0
 487 0216 84C0     	testb %al,%al
 488 0218 74D1     	je .L120
 489              	.LBB44:
 490              	.loc 5 645 0
 491              	
 492 021a 9C5BFA   	pushfl
 493              	.loc 5 647 0
 494              	
 495 021d A1240000 	movl per_cpu__softnet_data+36,%eax
 495      00
 496 0222 8902     	movl %eax,(%edx)
 497              	.loc 5 649 0
 498 0224 B8020000 	movl $2,%eax
 498      00
 499              	.loc 5 648 0
GAS LISTING  			page 59


 500 0229 89152400 	movl %edx,per_cpu__softnet_data+36
 500      0000
 501              	.loc 5 649 0
 502 022f E8FCFFFF 	call raise_softirq_irqoff
 502      FF
 503              	.loc 5 650 0
 504              	
 505 0234 539D     	pushl %ebx
 506              	
 507              	.LBE44:
 508              	.LBE41:
 509              	.LBE40:
 510 0236 EBB3     	jmp .L120
 511              	.L98:
 512              	.LBB45:
 513              	.LBB46:
 514              	.loc 6 369 0
 515 0238 8B82A000 	movl 160(%edx),%eax
 515      0000
 516 023e 48       	decl %eax
 517 023f 7502     	jne .L107
 518              	.loc 6 370 0
 519 0241 EB0D     	jmp .L108
 520              	.L107:
 521              	.LBB47:
 522              	.LBB48:
 523              	.loc 3 135 0
 524              	
 525 0243 FF8AA000 	decl 160(%edx)
 525      00000F94 
 525      C0
 526              	
 527              	.LBE48:
 528              	.LBE47:
 529              	.loc 3 132 0
 530 024c 84C0     	testb %al,%al
 531 024e 749B     	je .L120
 532              	.L108:
 533              	.loc 6 373 0
 534 0250 52       	pushl %edx
 535              	.LCFI30:
 536 0251 E8FCFFFF 	call __kfree_skb
 536      FF
 537 0256 59       	popl %ecx
 538              	.LCFI31:
 539 0257 EB92     	jmp .L120
 540              	.L116:
 541              	.LBE46:
 542              	.LBE45:
 543              	.LBE36:
 544              	.LBE35:
 545              	.loc 1 223 0
 546 0259 56       	pushl %esi
 547              	.LCFI32:
 548 025a E8FCFFFF 	call kfree
 548      FF
 549              	.loc 1 224 0
GAS LISTING  			page 60


 550 025f 5A       	popl %edx
 551              	.LCFI33:
 552 0260 31C0     	xorl %eax,%eax
 553              	.L38:
 227:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** }
 554              	.loc 1 227 0
 555 0262 5B       	popl %ebx
 556 0263 5E       	popl %esi
 557 0264 5F       	popl %edi
 558 0265 5D       	popl %ebp
 559 0266 C3       	ret
 560              	.LFE925:
 562              	.section .rodata.str1.1
 563              	.LC1:
 564 0023 3C343E25 	.string "<4>%s: No xmit handler.\n"
 564      733A204E 
 564      6F20786D 
 564      69742068 
 564      616E646C 
 565              	.LC2:
 566 003c 3C343E25 	.string "<4>%s: skb too small (%d).\n"
 566      733A2073 
 566      6B622074 
 566      6F6F2073 
 566      6D616C6C 
 567              	.LC3:
 568 0058 3C333E69 	.string "<3>ieee80211: msdu encryption failed\n"
 568      65656538 
 568      30323131 
 568      3A206D73 
 568      64752065 
 569              	.LC4:
 570 007e 3C343E25 	.string "<4>%s: Could not allocate TXB\n"
 570      733A2043 
 570      6F756C64 
 570      206E6F74 
 570      20616C6C 
 571              	.text
 572              	.globl ieee80211_xmit
 574              	ieee80211_xmit:
 575              	.LFB926:
 228:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 
 229:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** /* Incoming skb is converted to a txb which consists of
 230:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c ****  * a block of 802.11 fragment packets (stored as skbs) */
 231:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** int ieee80211_xmit(struct sk_buff *skb, struct net_device *dev)
 232:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** {
 576              	.loc 1 232 0
 577 0267 55       	pushl %ebp
 578              	.LCFI34:
 579 0268 57       	pushl %edi
 580              	.LCFI35:
 581 0269 56       	pushl %esi
 582              	.LCFI36:
 583 026a 53       	pushl %ebx
 584              	.LCFI37:
 585 026b 81EC8400 	subl $132,%esp
 585      0000
GAS LISTING  			page 61


 586              	.LCFI38:
 587              	.LBB49:
 588              	.LBB50:
 589              	.loc 5 494 0
 590 0271 8B84249C 	movl 156(%esp),%eax
 590      000000
 591 0278 05200200 	addl $544,%eax
 591      00
 592              	.LBE50:
 593              	.LBE49:
 233:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	struct ieee80211_device *ieee = netdev_priv(dev);
 234:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	struct ieee80211_txb *txb = NULL;
 235:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	struct ieee80211_hdr_3addr *frag_hdr;
 236:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	int i, bytes_per_frag, nr_frags, bytes_last_frag, frag_size,
 237:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	    rts_required;
 238:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	unsigned long flags;
 239:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	struct net_device_stats *stats = &ieee->stats;
 594              	.loc 1 239 0
 595 027d 8B94249C 	movl 156(%esp),%edx
 595      000000
 596              	.LBB51:
 597              	.LBB52:
 598              	.loc 5 494 0
 599 0284 89442440 	movl %eax,64(%esp)
 600              	.LBE52:
 601              	.LBE51:
 602              	.loc 1 239 0
 603 0288 81C2B402 	addl $692,%edx
 603      0000
 240:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	int ether_type, encrypt, host_encrypt, host_encrypt_msdu, host_build_iv;
 241:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	int bytes, fc, hdr_len;
 242:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	struct sk_buff *skb_frag;
 243:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	struct ieee80211_hdr_3addr header = {	/* Ensure zero initialized */
 604              	.loc 1 243 0
 605 028e 31C0     	xorl %eax,%eax
 606 0290 8D7C2464 	leal 100(%esp),%edi
 607 0294 FC       	cld
 608 0295 B9060000 	movl $6,%ecx
 608      00
 609              	.loc 1 239 0
 610 029a 89542424 	movl %edx,36(%esp)
 611              	.loc 1 234 0
 612 029e C744243C 	movl $0,60(%esp)
 612      00000000 
 613              	.loc 1 243 0
 614 02a6 F3       	rep
 615 02a7 AB       	stosl
 244:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		.duration_id = 0,
 245:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		.seq_ctl = 0
 246:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	};
 247:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	u8 dest[ETH_ALEN], src[ETH_ALEN];
 248:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	struct ieee80211_crypt_data *crypt;
 249:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	int priority = skb->priority;
 616              	.loc 1 249 0
 617 02a8 8B942498 	movl 152(%esp),%edx
 617      000000
 618 02af 8B5274   	movl 116(%edx),%edx
GAS LISTING  			page 62


 619 02b2 89542404 	movl %edx,4(%esp)
 250:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	int snapped = 0;
 620              	.loc 1 250 0
 621 02b6 C7042400 	movl $0,(%esp)
 621      000000
 251:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 
 252:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	if (ieee->is_queue_full && (*ieee->is_queue_full) (dev, priority))
 622              	.loc 1 252 0
 623 02bd 8B5C2440 	movl 64(%esp),%ebx
 624 02c1 8B838007 	movl 1920(%ebx),%eax
 624      0000
 625 02c7 85C0     	testl %eax,%eax
 626 02c9 7419     	je .L123
 627 02cb 52       	pushl %edx
 628              	.LCFI39:
 629 02cc FFB424A0 	pushl 160(%esp)
 629      000000
 630              	.LCFI40:
 631 02d3 FFD0     	call *%eax
 632 02d5 5D       	popl %ebp
 633              	.LCFI41:
 634 02d6 85C0     	testl %eax,%eax
 635 02d8 5A       	popl %edx
 636              	.LCFI42:
 253:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		return NETDEV_TX_BUSY;
 637              	.loc 1 253 0
 638 02d9 BA010000 	movl $1,%edx
 638      00
 639              	.loc 1 252 0
 640 02de 0F85520A 	jne .L121
 640      0000
 641              	.L123:
 254:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 
 255:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	spin_lock_irqsave(&ieee->lock, flags);
 642              	.loc 1 255 0
 643              	
 644 02e4 9C8F4424 	pushfl
 644      28FA
 256:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 
 257:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	/* If there is no driver handler to take the TXB, dont' bother
 258:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	 * creating it... */
 259:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	if (!ieee->hard_start_xmit) {
 645              	.loc 1 259 0
 646              	
 647 02ea 8B7C2440 	movl 64(%esp),%edi
 648 02ee 83BF7807 	cmpl $0,1912(%edi)
 648      000000
 649 02f5 7513     	jne .L127
 260:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		printk(KERN_WARNING "%s: No xmit handler.\n", ieee->dev->name);
 650              	.loc 1 260 0
 651 02f7 FF37     	pushl (%edi)
 652              	.LCFI43:
 653 02f9 68230000 	pushl $.LC1
 653      00
 654              	.LCFI44:
 655 02fe E8FCFFFF 	call printk
 655      FF
GAS LISTING  			page 63


 261:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		goto success;
 656              	.loc 1 261 0
 657 0303 5E       	popl %esi
 658              	.LCFI45:
 659 0304 5F       	popl %edi
 660              	.LCFI46:
 661 0305 E93A0900 	jmp .L602
 661      00
 662              	.L127:
 262:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	}
 263:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 
 264:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	if (unlikely(skb->len < SNAP_SIZE + sizeof(u16))) {
 663              	.loc 1 264 0
 664 030a 8B942498 	movl 152(%esp),%edx
 664      000000
 665 0311 8B4260   	movl 96(%edx),%eax
 666 0314 83F807   	cmpl $7,%eax
 667 0317 7719     	ja .L129
 265:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		printk(KERN_WARNING "%s: skb too small (%d).\n",
 668              	.loc 1 265 0
 669 0319 50       	pushl %eax
 670              	.LCFI47:
 671 031a 8B5C2444 	movl 68(%esp),%ebx
 672 031e FF33     	pushl (%ebx)
 673              	.LCFI48:
 674 0320 683C0000 	pushl $.LC2
 674      00
 675              	.LCFI49:
 676 0325 E8FCFFFF 	call printk
 676      FF
 266:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		       ieee->dev->name, skb->len);
 267:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		goto success;
 677              	.loc 1 267 0
 678 032a 83C40C   	addl $12,%esp
 679              	.LCFI50:
 680 032d E9120900 	jmp .L602
 680      00
 681              	.L129:
 268:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	}
 269:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 
 270:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	ether_type = ntohs(((struct ethhdr *)skb->data)->h_proto);
 682              	.loc 1 270 0
 683 0332 8BBC2498 	movl 152(%esp),%edi
 683      000000
 684 0339 8B8FA800 	movl 168(%edi),%ecx
 684      0000
 685 033f 0FB7410C 	movzwl 12(%ecx),%eax
 686              	.LBB53:
 687              	.LBB54:
 688              	.LBB55:
 689              	.LBB56:
 690              	.loc 2 135 0
 691 0343 89C2     	movl %eax,%edx
 692 0345 C1E208   	sall $8,%edx
 693 0348 C1E808   	shrl $8,%eax
 694 034b 09C2     	orl %eax,%edx
 695              	.LBE56:
GAS LISTING  			page 64


 696              	.LBE55:
 697              	.LBE54:
 698              	.LBE53:
 699              	.loc 2 134 0
 700 034d 0FB7D2   	movzwl %dx,%edx
 701 0350 89542420 	movl %edx,32(%esp)
 271:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 
 272:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	crypt = ieee->crypt[ieee->tx_keyidx];
 702              	.loc 1 272 0
 703 0354 8B542440 	movl 64(%esp),%edx
 704 0358 8B82B006 	movl 1712(%edx),%eax
 704      0000
 705 035e 8B8482A0 	movl 1696(%edx,%eax,4),%eax
 705      060000
 273:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 
 274:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	encrypt = !(ether_type == ETH_P_PAE && ieee->ieee802_1x) &&
 706              	.loc 1 274 0
 707 0365 817C2420 	cmpl $34958,32(%esp)
 707      8E880000 
 708              	.loc 1 272 0
 709 036d 89442408 	movl %eax,8(%esp)
 710              	.loc 1 274 0
 711 0371 C744241C 	movl $0,28(%esp)
 711      00000000 
 712 0379 7509     	jne .L134
 713 037b 83BA8006 	cmpl $0,1664(%edx)
 713      000000
 714 0382 7512     	jne .L133
 715              	.L134:
 716 0384 8B5C2440 	movl 64(%esp),%ebx
 717 0388 F6430504 	testb $4,5(%ebx)
 718 038c 7408     	je .L133
 719 038e C744241C 	movl $1,28(%esp)
 719      01000000 
 720              	.L133:
 275:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	    ieee->sec.encrypt;
 276:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 
 277:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	host_encrypt = ieee->host_encrypt && encrypt && crypt;
 721              	.loc 1 277 0
 722 0396 C7442418 	movl $0,24(%esp)
 722      00000000 
 723 039e 8B7C2440 	movl 64(%esp),%edi
 724 03a2 83BF6806 	cmpl $0,1640(%edi)
 724      000000
 725 03a9 7416     	je .L135
 726 03ab 837C241C 	cmpl $0,28(%esp)
 726      00
 727 03b0 740F     	je .L135
 728 03b2 837C2408 	cmpl $0,8(%esp)
 728      00
 729 03b7 7408     	je .L135
 730 03b9 C7442418 	movl $1,24(%esp)
 730      01000000 
 731              	.L135:
 278:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	host_encrypt_msdu = ieee->host_encrypt_msdu && encrypt && crypt;
 732              	.loc 1 278 0
 733 03c1 8B442440 	movl 64(%esp),%eax
GAS LISTING  			page 65


 734 03c5 31DB     	xorl %ebx,%ebx
 735 03c7 83B86C06 	cmpl $0,1644(%eax)
 735      000000
 736 03ce 7410     	je .L136
 737 03d0 837C241C 	cmpl $0,28(%esp)
 737      00
 738 03d5 7409     	je .L136
 739 03d7 837C2408 	cmpl $0,8(%esp)
 739      00
 740 03dc 7402     	je .L136
 741 03de B301     	movb $1,%bl
 742              	.L136:
 279:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	host_build_iv = ieee->host_build_iv && encrypt && crypt;
 743              	.loc 1 279 0
 744 03e0 C7442414 	movl $0,20(%esp)
 744      00000000 
 745 03e8 8B542440 	movl 64(%esp),%edx
 746 03ec 83BA7C06 	cmpl $0,1660(%edx)
 746      000000
 747 03f3 7416     	je .L137
 748 03f5 837C241C 	cmpl $0,28(%esp)
 748      00
 749 03fa 7416     	je .L628
 750 03fc 837C2408 	cmpl $0,8(%esp)
 750      00
 751 0401 7408     	je .L137
 752 0403 C7442414 	movl $1,20(%esp)
 752      01000000 
 753              	.L137:
 280:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 
 281:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	if (!encrypt && ieee->ieee802_1x &&
 754              	.loc 1 281 0
 755 040b 837C241C 	cmpl $0,28(%esp)
 755      00
 756 0410 752C     	jne .L138
 757              	.L628:
 758 0412 8B7C2440 	movl 64(%esp),%edi
 759 0416 83BF8006 	cmpl $0,1664(%edi)
 759      000000
 760 041d 741F     	je .L138
 761 041f 83BF8806 	cmpl $0,1672(%edi)
 761      000000
 762 0426 7416     	je .L138
 763 0428 817C2420 	cmpl $34958,32(%esp)
 763      8E880000 
 764 0430 740C     	je .L138
 282:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	    ieee->drop_unencrypted && ether_type != ETH_P_PAE) {
 283:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		stats->tx_dropped++;
 765              	.loc 1 283 0
 766 0432 8B442424 	movl 36(%esp),%eax
 767 0436 FF401C   	incl 28(%eax)
 284:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		goto success;
 768              	.loc 1 284 0
 769 0439 E9060800 	jmp .L602
 769      00
 770              	.L138:
 771              	.LBB57:
GAS LISTING  			page 66


 772              	.LBB58:
 773              	.loc 8 240 0
 774 043e 8B01     	movl (%ecx),%eax
 775 0440 89442454 	movl %eax,84(%esp)
 776              	.loc 8 241 0
 777 0444 668B4104 	movw 4(%ecx),%ax
 778 0448 66894424 	movw %ax,88(%esp)
 778      58
 779              	.LBE58:
 780              	.LBE57:
 781              	.LBB59:
 782              	.loc 8 227 0
 783 044d 8BBC2498 	movl 152(%esp),%edi
 783      000000
 784 0454 8B97A800 	movl 168(%edi),%edx
 784      0000
 785              	.LBB60:
 786              	.loc 8 240 0
 787 045a 8B4206   	movl 6(%edx),%eax
 788 045d 89442444 	movl %eax,68(%esp)
 789              	.loc 8 241 0
 790 0461 668B420A 	movw 10(%edx),%ax
 791 0465 66894424 	movw %ax,72(%esp)
 791      48
 792              	.LBE60:
 793              	.LBE59:
 794              	.LBB61:
 795              	.LBB62:
 796              	.loc 6 811 0
 797 046a 8B4760   	movl 96(%edi),%eax
 798 046d 83F80D   	cmpl $13,%eax
 799 0470 761B     	jbe .L188
 800              	.LBB63:
 801              	.LBB64:
 802              	.loc 6 794 0
 803 0472 83E80E   	subl $14,%eax
 804              	.loc 6 795 0
 805 0475 3B4764   	cmpl 100(%edi),%eax
 806              	.loc 6 794 0
 807 0478 894760   	movl %eax,96(%edi)
 808              	.loc 6 795 0
 809 047b 7302     	jae .L185
 810              	
 811 047d 0F0B     	ud2
 812              	
 813              	
 814              	.L185:
 815 047f 8B842498 	movl 152(%esp),%eax
 815      000000
 816 0486 8380A800 	addl $14,168(%eax)
 816      00000E
 817              	.L188:
 818              	.LBE64:
 819              	.LBE63:
 820              	.LBE62:
 821              	.LBE61:
 285:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	}
GAS LISTING  			page 67


 286:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 
 287:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	/* Save source and destination addresses */
 288:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	memcpy(dest, skb->data, ETH_ALEN);
 289:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	memcpy(src, skb->data + ETH_ALEN, ETH_ALEN);
 290:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 
 291:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	/* Advance the SKB to the start of the payload */
 292:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	skb_pull(skb, sizeof(struct ethhdr));
 293:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 
 294:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	/* Determine total amount of storage required for TXB packets */
 295:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	bytes = skb->len + SNAP_SIZE + sizeof(u16);
 822              	.loc 1 295 0
 823 048d 8B942498 	movl 152(%esp),%edx
 823      000000
 824 0494 8B7A60   	movl 96(%edx),%edi
 825 0497 83C708   	addl $8,%edi
 296:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 
 297:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	if (host_encrypt || host_build_iv)
 826              	.loc 1 297 0
 827 049a 837C2418 	cmpl $0,24(%esp)
 827      00
 828              	.loc 1 295 0
 829 049f 897C2410 	movl %edi,16(%esp)
 830              	.loc 1 297 0
 831 04a3 750F     	jne .L190
 832 04a5 837C2414 	cmpl $0,20(%esp)
 832      00
 298:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		fc = IEEE80211_FTYPE_DATA | IEEE80211_STYPE_DATA |
 299:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		    IEEE80211_FCTL_PROTECTED;
 300:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	else
 301:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		fc = IEEE80211_FTYPE_DATA | IEEE80211_STYPE_DATA;
 833              	.loc 1 301 0
 834 04aa C744240C 	movl $8,12(%esp)
 834      08000000 
 835              	.loc 1 297 0
 836 04b2 7408     	je .L191
 837              	.L190:
 838              	.loc 1 298 0
 839 04b4 C744240C 	movl $16392,12(%esp)
 839      08400000 
 840              	.L191:
 302:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 
 303:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	if (ieee->iw_mode == IW_MODE_INFRA) {
 841              	.loc 1 303 0
 842 04bc 8B542440 	movl 64(%esp),%edx
 843 04c0 8B82F005 	movl 1520(%edx),%eax
 843      0000
 844 04c6 83F802   	cmpl $2,%eax
 845 04c9 753D     	jne .L192
 304:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		fc |= IEEE80211_FCTL_TODS;
 846              	.loc 1 304 0
 847 04cb 814C240C 	orl $256,12(%esp)
 847      00010000 
 848              	.LBB65:
 849              	.LBB66:
 850              	.loc 8 240 0
 851 04d3 8B825007 	movl 1872(%edx),%eax
 851      0000
GAS LISTING  			page 68


 852 04d9 89442468 	movl %eax,104(%esp)
 853              	.loc 8 241 0
 854 04dd 668B8254 	movw 1876(%edx),%ax
 854      070000
 855 04e4 66894424 	movw %ax,108(%esp)
 855      6C
 856              	.LBE66:
 857              	.LBE65:
 858              	.LBB67:
 859              	.LBB68:
 860              	.loc 8 240 0
 861 04e9 8B442444 	movl 68(%esp),%eax
 862 04ed 8944246E 	movl %eax,110(%esp)
 863              	.loc 8 241 0
 864 04f1 8B442448 	movl 72(%esp),%eax
 865 04f5 66894424 	movw %ax,114(%esp)
 865      72
 866              	.LBE68:
 867              	.LBE67:
 868              	.LBB69:
 869              	.LBB70:
 870              	.loc 8 240 0
 871 04fa 8B442454 	movl 84(%esp),%eax
 872 04fe 89442474 	movl %eax,116(%esp)
 873              	.loc 8 241 0
 874 0502 8B442458 	movl 88(%esp),%eax
 875 0506 EB3A     	jmp .L637
 876              	.L192:
 877              	.LBE70:
 878              	.LBE69:
 305:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		/* To DS: Addr1 = BSSID, Addr2 = SA, Addr3 = DA */
 306:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		memcpy(header.addr1, ieee->bssid, ETH_ALEN);
 307:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		memcpy(header.addr2, src, ETH_ALEN);
 308:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		memcpy(header.addr3, dest, ETH_ALEN);
 309:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	} else if (ieee->iw_mode == IW_MODE_ADHOC) {
 879              	.loc 1 309 0
 880 0508 48       	decl %eax
 881 0509 753C     	jne .L259
 882              	.LBB71:
 883              	.LBB72:
 884              	.loc 8 240 0
 885 050b 8B442454 	movl 84(%esp),%eax
 886 050f 89442468 	movl %eax,104(%esp)
 887              	.loc 8 241 0
 888 0513 8B442458 	movl 88(%esp),%eax
 889 0517 66894424 	movw %ax,108(%esp)
 889      6C
 890              	.LBE72:
 891              	.LBE71:
 892              	.LBB73:
 893              	.LBB74:
 894              	.loc 8 240 0
 895 051c 8B442444 	movl 68(%esp),%eax
 896 0520 8944246E 	movl %eax,110(%esp)
 897              	.loc 8 241 0
 898 0524 8B442448 	movl 72(%esp),%eax
 899 0528 66894424 	movw %ax,114(%esp)
GAS LISTING  			page 69


 899      72
 900              	.LBE74:
 901              	.LBE73:
 902              	.LBB75:
 903              	.LBB76:
 904              	.loc 8 240 0
 905 052d 8B7C2440 	movl 64(%esp),%edi
 906 0531 8B875007 	movl 1872(%edi),%eax
 906      0000
 907 0537 89442474 	movl %eax,116(%esp)
 908              	.loc 8 241 0
 909 053b 668B8754 	movw 1876(%edi),%ax
 909      070000
 910              	.L637:
 911 0542 66894424 	movw %ax,120(%esp)
 911      78
 912              	.L259:
 913              	.LBE76:
 914              	.LBE75:
 310:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		/* not From/To DS: Addr1 = DA, Addr2 = SA, Addr3 = BSSID */
 311:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		memcpy(header.addr1, dest, ETH_ALEN);
 312:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		memcpy(header.addr2, src, ETH_ALEN);
 313:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		memcpy(header.addr3, ieee->bssid, ETH_ALEN);
 314:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	}
 315:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	header.frame_ctl = cpu_to_le16(fc);
 915              	.loc 1 315 0
 916 0547 8B44240C 	movl 12(%esp),%eax
 316:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	hdr_len = IEEE80211_3ADDR_LEN;
 317:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 
 318:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	/* Encrypt msdu first on the whole data packet. */
 319:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	if ((host_encrypt || host_encrypt_msdu) &&
 917              	.loc 1 319 0
 918 054b 837C2418 	cmpl $0,24(%esp)
 918      00
 919              	.loc 1 315 0
 920 0550 66894424 	movw %ax,100(%esp)
 920      64
 921              	.loc 1 319 0
 922 0555 7508     	jne .L328
 923 0557 85DB     	testl %ebx,%ebx
 924 0559 0F84B802 	je .L632
 924      0000
 925              	.L328:
 926 055f 837C2408 	cmpl $0,8(%esp)
 926      00
 927 0564 0F84A602 	je .L327
 927      0000
 928 056a 8B542408 	movl 8(%esp),%edx
 929 056e 8B4208   	movl 8(%edx),%eax
 930 0571 85C0     	testl %eax,%eax
 931 0573 0F849702 	je .L327
 931      0000
 932 0579 83782000 	cmpl $0,32(%eax)
 933 057d 0F848D02 	je .L327
 933      0000
 934              	.LBB77:
 320:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	    crypt && crypt->ops && crypt->ops->encrypt_msdu) {
GAS LISTING  			page 70


 321:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		int res = 0;
 322:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		int len = bytes + hdr_len + crypt->ops->extra_msdu_prefix_len +
 935              	.loc 1 322 0
 936 0583 8B5044   	movl 68(%eax),%edx
 937 0586 8B4048   	movl 72(%eax),%eax
 938 0589 03442410 	addl 16(%esp),%eax
 939              	.LBB78:
 940              	.LBB79:
 941              	.LBB80:
 942              	.LBB81:
 943              	.loc 6 988 0
 944 058d 8D441028 	leal 40(%eax,%edx),%eax
 945 0591 6A20     	pushl $32
 946              	.LCFI51:
 947 0593 50       	pushl %eax
 948              	.LCFI52:
 949 0594 E8FCFFFF 	call alloc_skb
 949      FF
 950 0599 59       	popl %ecx
 951              	.LCFI53:
 952              	.loc 6 989 0
 953 059a 85C0     	testl %eax,%eax
 954              	.loc 6 988 0
 955 059c 5B       	popl %ebx
 956              	.LCFI54:
 957 059d 89C5     	movl %eax,%ebp
 958              	.loc 6 989 0
 959 059f 0F847407 	je .L623
 959      0000
 960              	.LBB82:
 961              	.LBB83:
 962              	.loc 6 871 0
 963 05a5 8B90A800 	movl 168(%eax),%edx
 963      0000
 964              	.loc 6 872 0
 965 05ab 8B88AC00 	movl 172(%eax),%ecx
 965      0000
 966              	.loc 6 871 0
 967 05b1 83C210   	addl $16,%edx
 968              	.loc 6 872 0
 969 05b4 83C110   	addl $16,%ecx
 970              	.loc 6 871 0
 971 05b7 8990A800 	movl %edx,168(%eax)
 971      0000
 972              	.loc 6 872 0
 973 05bd 8988AC00 	movl %ecx,172(%eax)
 973      0000
 974              	.LBE83:
 975              	.LBE82:
 976              	.LBE81:
 977              	.LBE80:
 978              	.LBE79:
 979              	.LBE78:
 980              	.LBB84:
 981              	.loc 6 870 0
 982 05c3 8B5C2408 	movl 8(%esp),%ebx
 983 05c7 8B4308   	movl 8(%ebx),%eax
GAS LISTING  			page 71


 984 05ca 8B4044   	movl 68(%eax),%eax
 985              	.LBB85:
 986              	.loc 6 871 0
 987 05cd 01C2     	addl %eax,%edx
 988              	.loc 6 872 0
 989 05cf 8D3C01   	leal (%ecx,%eax),%edi
 990              	.LBE85:
 991              	.LBE84:
 992              	.LBB86:
 993              	.LBB87:
 994              	.LBB88:
 995              	.loc 6 702 0
 996 05d2 837D6400 	cmpl $0,100(%ebp)
 997              	.LBE88:
 998              	.LBE87:
 999              	.LBE86:
 1000              	.LBB89:
 1001              	.LBB90:
 1002              	.loc 6 871 0
 1003 05d6 8995A800 	movl %edx,168(%ebp)
 1003      0000
 1004              	.loc 6 872 0
 1005 05dc 89BDAC00 	movl %edi,172(%ebp)
 1005      0000
 1006              	.LBE90:
 1007              	.LBE89:
 1008              	.LBB91:
 1009              	.LBB92:
 1010              	.LBB93:
 1011              	.loc 6 702 0
 1012 05e2 7402     	je .L338
 1013              	.loc 6 759 0
 1014              	
 1015 05e4 0F0B     	ud2
 1016              	
 1017              	
 1018              	.L338:
 1019              	.loc 6 760 0
 1020 05e6 8D4718   	leal 24(%edi),%eax
 1021              	.loc 6 761 0
 1022 05e9 83456018 	addl $24,96(%ebp)
 1023              	.loc 6 762 0
 1024 05ed 3B85B000 	cmpl 176(%ebp),%eax
 1024      0000
 1025              	.loc 6 760 0
 1026 05f3 8985AC00 	movl %eax,172(%ebp)
 1026      0000
 1027              	.loc 6 762 0
 1028 05f9 7611     	jbe .L341
 1029              	.LBB94:
 1030              	.loc 6 763 0
 1031              	
 1032 05fb B8000600 	movl $1f,%eax
 1032      00
 1033              	1:
 1034              	
 1035              	.LBE94:
GAS LISTING  			page 72


 1036 0600 50       	pushl %eax
 1037              	.LCFI55:
 1038 0601 6A18     	pushl $24
 1039              	.LCFI56:
 1040 0603 55       	pushl %ebp
 1041              	.LCFI57:
 1042 0604 E8FCFFFF 	call skb_over_panic
 1042      FF
 1043 0609 83C40C   	addl $12,%esp
 1044              	.LCFI58:
 1045              	.L341:
 1046              	.LBE93:
 1047              	.LBE92:
 1048              	.loc 8 227 0
 1049 060c 8D742464 	leal 100(%esp),%esi
 1050              	.LBB95:
 1051              	.LBB96:
 1052              	.loc 8 252 0
 1053 0610 B9060000 	movl $6,%ecx
 1053      00
 1054              	
 1055 0615 F3A5     	rep
 1056              	
 1057              	.LBE96:
 1058              	.LBE95:
 1059              	.LBE91:
 323:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		    crypt->ops->extra_msdu_postfix_len;
 324:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		struct sk_buff *skb_new = dev_alloc_skb(len);
 325:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 
 326:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		if (unlikely(!skb_new))
 327:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 			goto failed;
 328:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 
 329:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		skb_reserve(skb_new, crypt->ops->extra_msdu_prefix_len);
 330:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		memcpy(skb_put(skb_new, hdr_len), &header, hdr_len);
 331:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		snapped = 1;
 1060              	.loc 1 331 0
 1061 0617 C7042401 	movl $1,(%esp)
 1061      000000
 1062              	.LBB97:
 1063              	.LBB98:
 1064              	.loc 6 702 0
 1065 061e 837D6400 	cmpl $0,100(%ebp)
 1066              	.loc 6 758 0
 1067 0622 8B9DAC00 	movl 172(%ebp),%ebx
 1067      0000
 1068              	.loc 6 702 0
 1069 0628 7402     	je .L371
 1070              	.loc 6 759 0
 1071              	
 1072 062a 0F0B     	ud2
 1073              	
 1074              	
 1075              	.L371:
 1076              	.loc 6 760 0
 1077 062c 8D4308   	leal 8(%ebx),%eax
 1078              	.loc 6 761 0
 1079 062f 83456008 	addl $8,96(%ebp)
GAS LISTING  			page 73


 1080              	.loc 6 762 0
 1081 0633 3B85B000 	cmpl 176(%ebp),%eax
 1081      0000
 1082              	.loc 6 760 0
 1083 0639 8985AC00 	movl %eax,172(%ebp)
 1083      0000
 1084              	.loc 6 762 0
 1085 063f 7611     	jbe .L374
 1086              	.LBB99:
 1087              	.loc 6 763 0
 1088              	
 1089 0641 B8460600 	movl $1f,%eax
 1089      00
 1090              	1:
 1091              	
 1092              	.LBE99:
 1093 0646 50       	pushl %eax
 1094              	.LCFI59:
 1095 0647 6A08     	pushl $8
 1096              	.LCFI60:
 1097 0649 55       	pushl %ebp
 1098              	.LCFI61:
 1099 064a E8FCFFFF 	call skb_over_panic
 1099      FF
 1100 064f 83C40C   	addl $12,%esp
 1101              	.LCFI62:
 1102              	.L374:
 1103              	.LBE98:
 1104              	.LBE97:
 1105              	.loc 6 757 0
 1106 0652 FF742420 	pushl 32(%esp)
 1107              	.LCFI63:
 1108 0656 53       	pushl %ebx
 1109              	.LCFI64:
 1110 0657 E8A4F9FF 	call ieee80211_copy_snap
 1110      FF
 332:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		ieee80211_copy_snap(skb_put(skb_new, SNAP_SIZE + sizeof(u16)),
 333:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 				    ether_type);
 334:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		memcpy(skb_put(skb_new, skb->len), skb->data, skb->len);
 1111              	.loc 1 334 0
 1112 065c 58       	popl %eax
 1113              	.LCFI65:
 1114 065d 5A       	popl %edx
 1115              	.LCFI66:
 1116 065e 8BBC2498 	movl 152(%esp),%edi
 1116      000000
 1117              	.LBB100:
 1118              	.LBB101:
 1119              	.LBB102:
 1120              	.loc 6 702 0
 1121 0665 837D6400 	cmpl $0,100(%ebp)
 1122 0669 8B5760   	movl 96(%edi),%edx
 1123 066c 8BBDAC00 	movl 172(%ebp),%edi
 1123      0000
 1124 0672 7402     	je .L405
 1125              	.loc 6 759 0
 1126              	
GAS LISTING  			page 74


 1127 0674 0F0B     	ud2
 1128              	
 1129              	
 1130              	.L405:
 1131              	.loc 6 760 0
 1132 0676 8D0417   	leal (%edi,%edx),%eax
 1133              	.loc 6 761 0
 1134 0679 015560   	addl %edx,96(%ebp)
 1135              	.loc 6 762 0
 1136 067c 3B85B000 	cmpl 176(%ebp),%eax
 1136      0000
 1137              	.loc 6 760 0
 1138 0682 8985AC00 	movl %eax,172(%ebp)
 1138      0000
 1139              	.loc 6 762 0
 1140 0688 7610     	jbe .L408
 1141              	.LBB103:
 1142              	.loc 6 763 0
 1143              	
 1144 068a B88F0600 	movl $1f,%eax
 1144      00
 1145              	1:
 1146              	
 1147              	.LBE103:
 1148 068f 50       	pushl %eax
 1149              	.LCFI67:
 1150 0690 52       	pushl %edx
 1151              	.LCFI68:
 1152 0691 55       	pushl %ebp
 1153              	.LCFI69:
 1154 0692 E8FCFFFF 	call skb_over_panic
 1154      FF
 1155 0697 83C40C   	addl $12,%esp
 1156              	.LCFI70:
 1157              	.L408:
 1158              	.LBE102:
 1159              	.LBE101:
 1160              	.loc 8 205 0
 1161 069a 8B842498 	movl 152(%esp),%eax
 1161      000000
 1162 06a1 8BB0A800 	movl 168(%eax),%esi
 1162      0000
 1163 06a7 8B4060   	movl 96(%eax),%eax
 1164              	.LBB104:
 1165              	.loc 8 207 0
 1166 06aa 89C1     	movl %eax,%ecx
 1167 06ac C1E902   	shrl $2,%ecx
 1168              	
 1169 06af F3A5     	rep
 1170 06b1 89C1     	movl %eax,%ecx
 1171 06b3 83E103   	andl $3,%ecx
 1172 06b6 7402     	jz 1f
 1173 06b8 F3A4     	rep
 1174              	1:
 1175              	
 1176              	.LBE104:
 1177              	.LBE100:
GAS LISTING  			page 75


 335:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		res = crypt->ops->encrypt_msdu(skb_new, hdr_len, crypt->priv);
 1178              	.loc 1 335 0
 1179 06ba 8B5C2408 	movl 8(%esp),%ebx
 1180 06be 8B4308   	movl 8(%ebx),%eax
 1181 06c1 FF730C   	pushl 12(%ebx)
 1182              	.LCFI71:
 1183 06c4 6A18     	pushl $24
 1184              	.LCFI72:
 1185 06c6 55       	pushl %ebp
 1186              	.LCFI73:
 1187 06c7 FF5020   	call *32(%eax)
 336:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		if (res < 0) {
 1188              	.loc 1 336 0
 1189 06ca 83C40C   	addl $12,%esp
 1190              	.LCFI74:
 1191 06cd 85C0     	testl %eax,%eax
 1192 06cf 797D     	jns .L411
 337:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 			IEEE80211_ERROR("msdu encryption failed\n");
 1193              	.loc 1 337 0
 1194 06d1 68580000 	pushl $.LC3
 1194      00
 1195              	.LCFI75:
 1196 06d6 E8FCFFFF 	call printk
 1196      FF
 1197              	.loc 5 658 0
 1198 06db 58       	popl %eax
 1199              	.LCFI76:
 1200              	.LBB105:
 1201              	.LBB106:
 1202              	.LBB107:
 1203              	.LBB108:
 1204              	.loc 4 91 0
 1205 06dc B800E0FF 	movl $-8192,%eax
 1205      FF
 1206              	
 1207 06e1 21E0     	andl %esp,%eax
 1208              	
 1209              	.LBE108:
 1210              	.LBE107:
 1211              	.loc 4 89 0
 1212 06e3 F7401400 	testl $268369920,20(%eax)
 1212      00FF0F
 1213 06ea 7507     	jne .L413
 1214              	.LBB109:
 1215              	.loc 5 659 0
 1216              	
 1217 06ec 9C58     	pushfl
 1218              	
 1219              	.LBE109:
 1220 06ee F6C402   	testb $2,%ah
 1221 06f1 7533     	jne .L412
 1222              	.L413:
 1223              	.LBB110:
 1224              	.LBB111:
 1225              	.LBB112:
 1226              	.LBB113:
 1227              	.loc 3 135 0
GAS LISTING  			page 76


 1228              	
 1229 06f3 FF8DA000 	decl 160(%ebp)
 1229      00000F94 
 1229      C0
 1230              	
 1231              	.LBE113:
 1232              	.LBE112:
 1233              	.loc 3 132 0
 1234 06fc 84C0     	testb %al,%al
 1235 06fe 0F841506 	je .L623
 1235      0000
 1236              	.LBB114:
 1237              	.loc 5 645 0
 1238              	
 1239 0704 9C5BFA   	pushfl
 1240              	.loc 5 647 0
 1241              	
 1242 0707 A1240000 	movl per_cpu__softnet_data+36,%eax
 1242      00
 1243 070c 894500   	movl %eax,(%ebp)
 1244              	.loc 5 649 0
 1245 070f B8020000 	movl $2,%eax
 1245      00
 1246              	.loc 5 648 0
 1247 0714 892D2400 	movl %ebp,per_cpu__softnet_data+36
 1247      0000
 1248              	.loc 5 649 0
 1249 071a E8FCFFFF 	call raise_softirq_irqoff
 1249      FF
 1250              	.loc 5 650 0
 1251              	
 1252 071f 539D     	pushl %ebx
 1253              	
 1254              	.LBE114:
 1255              	.LBE111:
 1256              	.LBE110:
 1257 0721 E9F30500 	jmp .L623
 1257      00
 1258              	.L412:
 1259              	.LBB115:
 1260              	.LBB116:
 1261              	.loc 6 369 0
 1262 0726 8B85A000 	movl 160(%ebp),%eax
 1262      0000
 1263 072c 48       	decl %eax
 1264 072d 7502     	jne .L421
 1265              	.loc 6 370 0
 1266 072f EB11     	jmp .L422
 1267              	.L421:
 1268              	.LBB117:
 1269              	.LBB118:
 1270              	.loc 3 135 0
 1271              	
 1272 0731 FF8DA000 	decl 160(%ebp)
 1272      00000F94 
 1272      C0
 1273              	
GAS LISTING  			page 77


 1274              	.LBE118:
 1275              	.LBE117:
 1276              	.loc 3 132 0
 1277 073a 84C0     	testb %al,%al
 1278 073c 0F84D705 	je .L623
 1278      0000
 1279              	.L422:
 1280              	.loc 6 373 0
 1281 0742 55       	pushl %ebp
 1282              	.LCFI77:
 1283 0743 E8FCFFFF 	call __kfree_skb
 1283      FF
 1284 0748 5F       	popl %edi
 1285              	.LCFI78:
 1286              	.LBE116:
 1287              	.LBE115:
 1288              	.LBE106:
 1289              	.LBE105:
 338:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 			dev_kfree_skb_any(skb_new);
 339:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 			goto failed;
 1290              	.loc 1 339 0
 1291 0749 E9CB0500 	jmp .L623
 1291      00
 1292              	.L411:
 1293              	.LBB119:
 1294              	.LBB120:
 1295              	.LBB121:
 1296              	.LBB122:
 1297              	.loc 4 91 0
 1298 074e B800E0FF 	movl $-8192,%eax
 1298      FF
 1299              	
 1300 0753 21E0     	andl %esp,%eax
 1301              	
 1302              	.LBE122:
 1303              	.LBE121:
 1304              	.loc 4 89 0
 1305 0755 F7401400 	testl $268369920,20(%eax)
 1305      00FF0F
 1306 075c 7507     	jne .L428
 1307              	.LBB123:
 1308              	.loc 5 659 0
 1309              	
 1310 075e 9C58     	pushfl
 1311              	
 1312              	.LBE123:
 1313 0760 F6C402   	testb $2,%ah
 1314 0763 7532     	jne .L427
 1315              	.L428:
 1316              	.LBB124:
 1317              	.LBB125:
 1318              	.LBB126:
 1319              	.LBB127:
 1320              	.loc 3 135 0
 1321 0765 8BBC2498 	movl 152(%esp),%edi
 1321      000000
 1322              	
GAS LISTING  			page 78


 1323 076c FF8FA000 	decl 160(%edi)
 1323      00000F94 
 1323      C0
 1324              	
 1325              	.LBE127:
 1326              	.LBE126:
 1327              	.loc 3 132 0
 1328 0775 84C0     	testb %al,%al
 1329 0777 7451     	je .L441
 1330              	.LBB128:
 1331              	.loc 5 645 0
 1332              	
 1333 0779 9C5BFA   	pushfl
 1334              	.loc 5 647 0
 1335              	
 1336 077c A1240000 	movl per_cpu__softnet_data+36,%eax
 1336      00
 1337 0781 8907     	movl %eax,(%edi)
 1338              	.loc 5 649 0
 1339 0783 B8020000 	movl $2,%eax
 1339      00
 1340              	.loc 5 648 0
 1341 0788 893D2400 	movl %edi,per_cpu__softnet_data+36
 1341      0000
 1342              	.loc 5 649 0
 1343 078e E8FCFFFF 	call raise_softirq_irqoff
 1343      FF
 1344              	.loc 5 650 0
 1345              	
 1346 0793 539D     	pushl %ebx
 1347              	
 1348              	.LBE128:
 1349              	.LBE125:
 1350              	.LBE124:
 1351 0795 EB33     	jmp .L441
 1352              	.L427:
 1353              	.LBB129:
 1354              	.LBB130:
 1355              	.loc 6 369 0
 1356 0797 8B942498 	movl 152(%esp),%edx
 1356      000000
 1357 079e 8B82A000 	movl 160(%edx),%eax
 1357      0000
 1358 07a4 48       	decl %eax
 1359 07a5 7502     	jne .L436
 1360              	.loc 6 370 0
 1361 07a7 EB14     	jmp .L437
 1362              	.L436:
 1363              	.LBB131:
 1364              	.LBB132:
 1365              	.loc 3 135 0
 1366 07a9 8B9C2498 	movl 152(%esp),%ebx
 1366      000000
 1367              	
 1368 07b0 FF8BA000 	decl 160(%ebx)
 1368      00000F94 
 1368      C0
GAS LISTING  			page 79


 1369              	
 1370              	.LBE132:
 1371              	.LBE131:
 1372              	.loc 3 132 0
 1373 07b9 84C0     	testb %al,%al
 1374 07bb 740D     	je .L441
 1375              	.L437:
 1376              	.loc 6 373 0
 1377 07bd FFB42498 	pushl 152(%esp)
 1377      000000
 1378              	.LCFI79:
 1379 07c4 E8FCFFFF 	call __kfree_skb
 1379      FF
 1380 07c9 5E       	popl %esi
 1381              	.LCFI80:
 1382              	.L441:
 1383              	.LBE130:
 1384              	.LBE129:
 1385              	.LBE120:
 1386              	.LBE119:
 340:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		}
 341:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		dev_kfree_skb_any(skb);
 342:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		skb = skb_new;
 1387              	.loc 1 342 0
 1388 07ca 89AC2498 	movl %ebp,152(%esp)
 1388      000000
 343:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		bytes += crypt->ops->extra_msdu_prefix_len +
 1389              	.loc 1 343 0
 1390 07d1 8B7C2408 	movl 8(%esp),%edi
 1391 07d5 8B4708   	movl 8(%edi),%eax
 1392 07d8 8B5048   	movl 72(%eax),%edx
 1393 07db 035044   	addl 68(%eax),%edx
 1394 07de 01542410 	addl %edx,16(%esp)
 1395              	.LBB133:
 1396              	.LBB134:
 1397              	.loc 6 811 0
 1398 07e2 8B5560   	movl 96(%ebp),%edx
 1399 07e5 B8180000 	movl $24,%eax
 1399      00
 1400 07ea 39D0     	cmpl %edx,%eax
 1401 07ec 7722     	ja .L327
 1402              	.LBB135:
 1403              	.LBB136:
 1404              	.loc 6 794 0
 1405 07ee 8D42E8   	leal -24(%edx),%eax
 1406 07f1 894560   	movl %eax,96(%ebp)
 1407              	.loc 6 795 0
 1408 07f4 8B942498 	movl 152(%esp),%edx
 1408      000000
 1409 07fb 3B4264   	cmpl 100(%edx),%eax
 1410 07fe 7302     	jae .L444
 1411              	
 1412 0800 0F0B     	ud2
 1413              	
 1414              	
 1415              	.L444:
 1416 0802 8B9C2498 	movl 152(%esp),%ebx
GAS LISTING  			page 80


 1416      000000
 1417 0809 8383A800 	addl $24,168(%ebx)
 1417      000018
 1418              	.L327:
 1419              	.LBE136:
 1420              	.LBE135:
 1421              	.LBE134:
 1422              	.LBE133:
 1423              	.LBE77:
 344:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		    crypt->ops->extra_msdu_postfix_len;
 345:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		skb_pull(skb, hdr_len);
 346:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	}
 347:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 
 348:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	if (host_encrypt || ieee->host_open_frag) {
 1424              	.loc 1 348 0
 1425 0810 837C2418 	cmpl $0,24(%esp)
 1425      00
 1426 0815 7511     	jne .L449
 1427              	.L632:
 1428 0817 8B7C2440 	movl 64(%esp),%edi
 1429 081b 83BF7806 	cmpl $0,1656(%edi)
 1429      000000
 1430 0822 0F848F00 	je .L448
 1430      0000
 1431              	.L449:
 1432              	.LBB137:
 1433              	.LBB138:
 1434              	.file 9 "include/linux/etherdevice.h"
   1:include/linux/etherdevice.h **** /*
   2:include/linux/etherdevice.h ****  * INET		An implementation of the TCP/IP protocol suite for the LINUX
   3:include/linux/etherdevice.h ****  *		operating system.  NET  is implemented using the  BSD Socket
   4:include/linux/etherdevice.h ****  *		interface as the means of communication with the user level.
   5:include/linux/etherdevice.h ****  *
   6:include/linux/etherdevice.h ****  *		Definitions for the Ethernet handlers.
   7:include/linux/etherdevice.h ****  *
   8:include/linux/etherdevice.h ****  * Version:	@(#)eth.h	1.0.4	05/13/93
   9:include/linux/etherdevice.h ****  *
  10:include/linux/etherdevice.h ****  * Authors:	Ross Biro
  11:include/linux/etherdevice.h ****  *		Fred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>
  12:include/linux/etherdevice.h ****  *
  13:include/linux/etherdevice.h ****  *		Relocated to include/linux where it belongs by Alan Cox 
  14:include/linux/etherdevice.h ****  *							<gw4pts@gw4pts.ampr.org>
  15:include/linux/etherdevice.h ****  *
  16:include/linux/etherdevice.h ****  *		This program is free software; you can redistribute it and/or
  17:include/linux/etherdevice.h ****  *		modify it under the terms of the GNU General Public License
  18:include/linux/etherdevice.h ****  *		as published by the Free Software Foundation; either version
  19:include/linux/etherdevice.h ****  *		2 of the License, or (at your option) any later version.
  20:include/linux/etherdevice.h ****  *
  21:include/linux/etherdevice.h ****  *	WARNING: This move may well be temporary. This file will get merged with others RSN.
  22:include/linux/etherdevice.h ****  *
  23:include/linux/etherdevice.h ****  */
  24:include/linux/etherdevice.h **** #ifndef _LINUX_ETHERDEVICE_H
  25:include/linux/etherdevice.h **** #define _LINUX_ETHERDEVICE_H
  26:include/linux/etherdevice.h **** 
  27:include/linux/etherdevice.h **** #include <linux/if_ether.h>
  28:include/linux/etherdevice.h **** #include <linux/random.h>
  29:include/linux/etherdevice.h **** 
GAS LISTING  			page 81


  30:include/linux/etherdevice.h **** #ifdef __KERNEL__
  31:include/linux/etherdevice.h **** extern int		eth_header(struct sk_buff *skb, struct net_device *dev,
  32:include/linux/etherdevice.h **** 				   unsigned short type, void *daddr,
  33:include/linux/etherdevice.h **** 				   void *saddr, unsigned len);
  34:include/linux/etherdevice.h **** extern int		eth_rebuild_header(struct sk_buff *skb);
  35:include/linux/etherdevice.h **** extern unsigned short	eth_type_trans(struct sk_buff *skb, struct net_device *dev);
  36:include/linux/etherdevice.h **** extern void		eth_header_cache_update(struct hh_cache *hh, struct net_device *dev,
  37:include/linux/etherdevice.h **** 						unsigned char * haddr);
  38:include/linux/etherdevice.h **** extern int		eth_header_cache(struct neighbour *neigh,
  39:include/linux/etherdevice.h **** 					 struct hh_cache *hh);
  40:include/linux/etherdevice.h **** 
  41:include/linux/etherdevice.h **** extern struct net_device *alloc_etherdev(int sizeof_priv);
  42:include/linux/etherdevice.h **** static inline void eth_copy_and_sum (struct sk_buff *dest, 
  43:include/linux/etherdevice.h **** 				     const unsigned char *src, 
  44:include/linux/etherdevice.h **** 				     int len, int base)
  45:include/linux/etherdevice.h **** {
  46:include/linux/etherdevice.h **** 	memcpy (dest->data, src, len);
  47:include/linux/etherdevice.h **** }
  48:include/linux/etherdevice.h **** 
  49:include/linux/etherdevice.h **** /**
  50:include/linux/etherdevice.h ****  * is_zero_ether_addr - Determine if give Ethernet address is all
  51:include/linux/etherdevice.h ****  * zeros.
  52:include/linux/etherdevice.h ****  */
  53:include/linux/etherdevice.h **** static inline int is_zero_ether_addr(const u8 *addr)
  54:include/linux/etherdevice.h **** {
  55:include/linux/etherdevice.h **** 	return !(addr[0] | addr[1] | addr[2] | addr[3] | addr[4] | addr[5]);
  56:include/linux/etherdevice.h **** }
  57:include/linux/etherdevice.h **** 
  58:include/linux/etherdevice.h **** /**
  59:include/linux/etherdevice.h ****  * is_multicast_ether_addr - Determine if the given Ethernet address is a
  60:include/linux/etherdevice.h ****  * multicast address.
  61:include/linux/etherdevice.h ****  *
  62:include/linux/etherdevice.h ****  * @addr: Pointer to a six-byte array containing the Ethernet address
  63:include/linux/etherdevice.h ****  *
  64:include/linux/etherdevice.h ****  * Return true if the address is a multicast address.
  65:include/linux/etherdevice.h ****  */
  66:include/linux/etherdevice.h **** static inline int is_multicast_ether_addr(const u8 *addr)
  67:include/linux/etherdevice.h **** {
  68:include/linux/etherdevice.h **** 	return addr[0] & 0x01;
 1435              	.loc 9 68 0
 1436 0828 8A442454 	movb 84(%esp),%al
 1437              	.LBE138:
 1438              	.LBE137:
 1439              	.loc 9 67 0
 1440 082c A801     	testb $1,%al
 1441 082e 7518     	jne .L451
 1442              	.LBB139:
 1443              	.LBB140:
 1444              	.file 10 "/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h"
   1:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** /*
   2:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h ****  * Merged with mainline ieee80211.h in Aug 2004.  Original ieee802_11
   3:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h ****  * remains copyright by the original authors
   4:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h ****  *
   5:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h ****  * Portions of the merged code are based on Host AP (software wireless
   6:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h ****  * LAN access point) driver for Intersil Prism2/2.5/3.
   7:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h ****  *
   8:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h ****  * Copyright (c) 2001-2002, SSH Communications Security Corp and Jouni Malinen
GAS LISTING  			page 82


   9:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h ****  * <jkmaline@cc.hut.fi>
  10:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h ****  * Copyright (c) 2002-2003, Jouni Malinen <jkmaline@cc.hut.fi>
  11:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h ****  *
  12:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h ****  * Adaption to a generic IEEE 802.11 stack by James Ketrenos
  13:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h ****  * <jketreno@linux.intel.com>
  14:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h ****  * Copyright (c) 2004-2005, Intel Corporation
  15:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h ****  *
  16:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h ****  * This program is free software; you can redistribute it and/or modify
  17:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h ****  * it under the terms of the GNU General Public License version 2 as
  18:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h ****  * published by the Free Software Foundation. See README and COPYING for
  19:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h ****  * more details.
  20:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h ****  *
  21:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h ****  * API Version History
  22:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h ****  * 1.0.x -- Initial version
  23:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h ****  * 1.1.x -- Added radiotap, QoS, TIM, ieee80211_geo APIs,
  24:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h ****  *          various structure changes, and crypto API init method
  25:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h ****  */
  26:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #ifndef IEEE80211_H
  27:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_H
  28:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #include <linux/if_ether.h>	/* ETH_ALEN */
  29:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #include <linux/kernel.h>	/* ARRAY_SIZE */
  30:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #include <linux/wireless.h>
  31:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
  32:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_VERSION "1.1.12"
  33:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
  34:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_DATA_LEN		2304
  35:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** /* Maximum size for the MA-UNITDATA primitive, 802.11 standard section
  36:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h ****    6.2.1.1.2.
  37:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
  38:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h ****    The figure in section 7.1.2 suggests a body size of up to 2312
  39:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h ****    bytes is allowed, which is a bit confusing, I suspect this
  40:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h ****    represents the 2304 bytes of real data, plus a possible 8 bytes of
  41:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h ****    WEP IV and ICV. (this interpretation suggested by Ramiro Barreiro) */
  42:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
  43:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_1ADDR_LEN 10
  44:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_2ADDR_LEN 16
  45:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_3ADDR_LEN 24
  46:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_4ADDR_LEN 30
  47:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_FCS_LEN    4
  48:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_HLEN			(IEEE80211_4ADDR_LEN)
  49:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_FRAME_LEN		(IEEE80211_DATA_LEN + IEEE80211_HLEN)
  50:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
  51:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define MIN_FRAG_THRESHOLD     256U
  52:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define	MAX_FRAG_THRESHOLD     2346U
  53:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
  54:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** /* Frame control field constants */
  55:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_FCTL_VERS		0x0003
  56:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_FCTL_FTYPE		0x000c
  57:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_FCTL_STYPE		0x00f0
  58:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_FCTL_TODS		0x0100
  59:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_FCTL_FROMDS		0x0200
  60:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_FCTL_MOREFRAGS	0x0400
  61:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_FCTL_RETRY		0x0800
  62:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_FCTL_PM		0x1000
  63:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_FCTL_MOREDATA		0x2000
  64:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_FCTL_PROTECTED	0x4000
  65:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_FCTL_ORDER		0x8000
GAS LISTING  			page 83


  66:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
  67:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_FTYPE_MGMT		0x0000
  68:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_FTYPE_CTL		0x0004
  69:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_FTYPE_DATA		0x0008
  70:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
  71:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** /* management */
  72:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_STYPE_ASSOC_REQ	0x0000
  73:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_STYPE_ASSOC_RESP 	0x0010
  74:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_STYPE_REASSOC_REQ	0x0020
  75:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_STYPE_REASSOC_RESP	0x0030
  76:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_STYPE_PROBE_REQ	0x0040
  77:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_STYPE_PROBE_RESP	0x0050
  78:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_STYPE_BEACON		0x0080
  79:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_STYPE_ATIM		0x0090
  80:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_STYPE_DISASSOC	0x00A0
  81:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_STYPE_AUTH		0x00B0
  82:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_STYPE_DEAUTH		0x00C0
  83:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_STYPE_ACTION		0x00D0
  84:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
  85:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** /* control */
  86:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_STYPE_PSPOLL		0x00A0
  87:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_STYPE_RTS		0x00B0
  88:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_STYPE_CTS		0x00C0
  89:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_STYPE_ACK		0x00D0
  90:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_STYPE_CFEND		0x00E0
  91:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_STYPE_CFENDACK	0x00F0
  92:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
  93:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** /* data */
  94:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_STYPE_DATA		0x0000
  95:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_STYPE_DATA_CFACK	0x0010
  96:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_STYPE_DATA_CFPOLL	0x0020
  97:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_STYPE_DATA_CFACKPOLL	0x0030
  98:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_STYPE_NULLFUNC	0x0040
  99:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_STYPE_CFACK		0x0050
 100:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_STYPE_CFPOLL		0x0060
 101:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_STYPE_CFACKPOLL	0x0070
 102:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_STYPE_QOS_DATA        0x0080
 103:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 104:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_SCTL_FRAG		0x000F
 105:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_SCTL_SEQ		0xFFF0
 106:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 107:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** /* debug macros */
 108:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 109:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #ifdef CONFIG_IEEE80211_DEBUG
 110:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** extern u32 ieee80211_debug_level;
 111:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_DEBUG(level, fmt, args...) \
 112:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** do { if (ieee80211_debug_level & (level)) \
 113:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h ****   printk(KERN_DEBUG "ieee80211: %c %s " fmt, \
 114:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h ****          in_interrupt() ? 'I' : 'U', __FUNCTION__ , ## args); } while (0)
 115:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #else
 116:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_DEBUG(level, fmt, args...) do {} while (0)
 117:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #endif				/* CONFIG_IEEE80211_DEBUG */
 118:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 119:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** /* debug macros not dependent on CONFIG_IEEE80211_DEBUG */
 120:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 121:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define MAC_FMT "%02x:%02x:%02x:%02x:%02x:%02x"
 122:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define MAC_ARG(x) ((u8*)(x))[0],((u8*)(x))[1],((u8*)(x))[2],((u8*)(x))[3],((u8*)(x))[4],((u8*)(x))
GAS LISTING  			page 84


 123:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 124:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** /* compatibility macros */
 125:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #if WIRELESS_EXT < 17
 126:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IW_QUAL_QUAL_UPDATED    0x01    /* Value was updated since last read */
 127:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IW_QUAL_LEVEL_UPDATED   0x02
 128:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IW_QUAL_NOISE_UPDATED   0x04
 129:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IW_QUAL_ALL_UPDATED     0x07
 130:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IW_QUAL_QUAL_INVALID    0x10    /* Driver doesn't provide value */
 131:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IW_QUAL_LEVEL_INVALID   0x20
 132:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IW_QUAL_NOISE_INVALID   0x40
 133:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IW_QUAL_ALL_INVALID     0x70
 134:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #endif
 135:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 136:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #if WIRELESS_EXT < 19
 137:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IW_QUAL_DBM             0x08    /* Level + Noise are dBm */
 138:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #endif
 139:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 140:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #ifndef __bitwise /* if __leXX is not defined */
 141:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** typedef __u16 __le16;
 142:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** typedef __u64 __le64;
 143:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #endif
 144:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 145:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #ifndef DEFINE_SPINLOCK
 146:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define DEFINE_SPINLOCK(s)              spinlock_t s = SPIN_LOCK_UNLOCKED
 147:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #endif
 148:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 149:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** /* escape_essid() is intended to be used in debug (and possibly error)
 150:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h ****  * messages. It should never be used for passing essid to user space. */
 151:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** const char *escape_essid(const char *essid, u8 essid_len);
 152:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 153:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** /*
 154:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h ****  * To use the debug system:
 155:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h ****  *
 156:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h ****  * If you are defining a new debug classification, simply add it to the #define
 157:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h ****  * list here in the form of:
 158:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h ****  *
 159:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h ****  * #define IEEE80211_DL_xxxx VALUE
 160:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h ****  *
 161:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h ****  * shifting value to the left one bit from the previous entry.  xxxx should be
 162:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h ****  * the name of the classification (for example, WEP)
 163:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h ****  *
 164:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h ****  * You then need to either add a IEEE80211_xxxx_DEBUG() macro definition for your
 165:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h ****  * classification, or use IEEE80211_DEBUG(IEEE80211_DL_xxxx, ...) whenever you want
 166:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h ****  * to send output to that classification.
 167:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h ****  *
 168:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h ****  * To add your debug level to the list of levels seen when you perform
 169:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h ****  *
 170:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h ****  * % cat /proc/net/ieee80211/debug_level
 171:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h ****  *
 172:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h ****  * you simply need to add your entry to the ieee80211_debug_level array.
 173:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h ****  *
 174:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h ****  * If you do not see debug_level in /proc/net/ieee80211 then you do not have
 175:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h ****  * CONFIG_IEEE80211_DEBUG defined in your kernel configuration
 176:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h ****  *
 177:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h ****  */
 178:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 179:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_DL_INFO          (1<<0)
GAS LISTING  			page 85


 180:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_DL_WX            (1<<1)
 181:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_DL_SCAN          (1<<2)
 182:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_DL_STATE         (1<<3)
 183:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_DL_MGMT          (1<<4)
 184:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_DL_FRAG          (1<<5)
 185:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_DL_DROP          (1<<7)
 186:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 187:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_DL_TX            (1<<8)
 188:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_DL_RX            (1<<9)
 189:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_DL_QOS           (1<<31)
 190:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 191:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_ERROR(f, a...) printk(KERN_ERR "ieee80211: " f, ## a)
 192:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_WARNING(f, a...) printk(KERN_WARNING "ieee80211: " f, ## a)
 193:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_DEBUG_INFO(f, a...)   IEEE80211_DEBUG(IEEE80211_DL_INFO, f, ## a)
 194:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 195:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_DEBUG_WX(f, a...)     IEEE80211_DEBUG(IEEE80211_DL_WX, f, ## a)
 196:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_DEBUG_SCAN(f, a...)   IEEE80211_DEBUG(IEEE80211_DL_SCAN, f, ## a)
 197:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_DEBUG_STATE(f, a...)  IEEE80211_DEBUG(IEEE80211_DL_STATE, f, ## a)
 198:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_DEBUG_MGMT(f, a...)  IEEE80211_DEBUG(IEEE80211_DL_MGMT, f, ## a)
 199:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_DEBUG_FRAG(f, a...)  IEEE80211_DEBUG(IEEE80211_DL_FRAG, f, ## a)
 200:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_DEBUG_DROP(f, a...)  IEEE80211_DEBUG(IEEE80211_DL_DROP, f, ## a)
 201:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_DEBUG_TX(f, a...)  IEEE80211_DEBUG(IEEE80211_DL_TX, f, ## a)
 202:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_DEBUG_RX(f, a...)  IEEE80211_DEBUG(IEEE80211_DL_RX, f, ## a)
 203:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_DEBUG_QOS(f, a...)  IEEE80211_DEBUG(IEEE80211_DL_QOS, f, ## a)
 204:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #include <linux/netdevice.h>
 205:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #include <linux/wireless.h>
 206:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #include <linux/if_arp.h>	/* ARPHRD_ETHER */
 207:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 208:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #ifndef WIRELESS_SPY
 209:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define WIRELESS_SPY		/* enable iwspy support */
 210:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #endif
 211:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #include <net/iw_handler.h>	/* new driver API */
 212:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 213:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #ifndef ETH_P_PAE
 214:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define ETH_P_PAE 0x888E	/* Port Access Entity (IEEE 802.1X) */
 215:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #endif				/* ETH_P_PAE */
 216:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 217:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define ETH_P_PREAUTH 0x88C7	/* IEEE 802.11i pre-authentication */
 218:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 219:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #ifndef ETH_P_80211_RAW
 220:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define ETH_P_80211_RAW (ETH_P_ECONET + 1)
 221:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #endif
 222:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 223:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** /* IEEE 802.11 defines */
 224:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 225:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define P80211_OUI_LEN 3
 226:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 227:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** struct ieee80211_snap_hdr {
 228:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 229:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 dsap;		/* always 0xAA */
 230:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 ssap;		/* always 0xAA */
 231:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 ctrl;		/* always 0x03 */
 232:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 oui[P80211_OUI_LEN];	/* organizational universal id */
 233:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 234:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** } __attribute__ ((packed));
 235:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 236:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define SNAP_SIZE sizeof(struct ieee80211_snap_hdr)
GAS LISTING  			page 86


 237:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 238:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define WLAN_FC_GET_VERS(fc) ((fc) & IEEE80211_FCTL_VERS)
 239:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define WLAN_FC_GET_TYPE(fc) ((fc) & IEEE80211_FCTL_FTYPE)
 240:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define WLAN_FC_GET_STYPE(fc) ((fc) & IEEE80211_FCTL_STYPE)
 241:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 242:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define WLAN_GET_SEQ_FRAG(seq) ((seq) & IEEE80211_SCTL_FRAG)
 243:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define WLAN_GET_SEQ_SEQ(seq)  ((seq) & IEEE80211_SCTL_SEQ)
 244:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 245:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** /* Authentication algorithms */
 246:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define WLAN_AUTH_OPEN 0
 247:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define WLAN_AUTH_SHARED_KEY 1
 248:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define WLAN_AUTH_LEAP 2
 249:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 250:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define WLAN_AUTH_CHALLENGE_LEN 128
 251:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 252:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define WLAN_CAPABILITY_ESS (1<<0)
 253:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define WLAN_CAPABILITY_IBSS (1<<1)
 254:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define WLAN_CAPABILITY_CF_POLLABLE (1<<2)
 255:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define WLAN_CAPABILITY_CF_POLL_REQUEST (1<<3)
 256:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define WLAN_CAPABILITY_PRIVACY (1<<4)
 257:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define WLAN_CAPABILITY_SHORT_PREAMBLE (1<<5)
 258:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define WLAN_CAPABILITY_PBCC (1<<6)
 259:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define WLAN_CAPABILITY_CHANNEL_AGILITY (1<<7)
 260:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define WLAN_CAPABILITY_SPECTRUM_MGMT (1<<8)
 261:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define WLAN_CAPABILITY_QOS (1<<9)
 262:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define WLAN_CAPABILITY_SHORT_SLOT_TIME (1<<10)
 263:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define WLAN_CAPABILITY_DSSS_OFDM (1<<13)
 264:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 265:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** /* Status codes */
 266:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** enum ieee80211_statuscode {
 267:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	WLAN_STATUS_SUCCESS = 0,
 268:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	WLAN_STATUS_UNSPECIFIED_FAILURE = 1,
 269:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	WLAN_STATUS_CAPS_UNSUPPORTED = 10,
 270:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	WLAN_STATUS_REASSOC_NO_ASSOC = 11,
 271:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	WLAN_STATUS_ASSOC_DENIED_UNSPEC = 12,
 272:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	WLAN_STATUS_NOT_SUPPORTED_AUTH_ALG = 13,
 273:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	WLAN_STATUS_UNKNOWN_AUTH_TRANSACTION = 14,
 274:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	WLAN_STATUS_CHALLENGE_FAIL = 15,
 275:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	WLAN_STATUS_AUTH_TIMEOUT = 16,
 276:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	WLAN_STATUS_AP_UNABLE_TO_HANDLE_NEW_STA = 17,
 277:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	WLAN_STATUS_ASSOC_DENIED_RATES = 18,
 278:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	/* 802.11b */
 279:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	WLAN_STATUS_ASSOC_DENIED_NOSHORTPREAMBLE = 19,
 280:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	WLAN_STATUS_ASSOC_DENIED_NOPBCC = 20,
 281:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	WLAN_STATUS_ASSOC_DENIED_NOAGILITY = 21,
 282:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	/* 802.11h */
 283:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	WLAN_STATUS_ASSOC_DENIED_NOSPECTRUM = 22,
 284:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	WLAN_STATUS_ASSOC_REJECTED_BAD_POWER = 23,
 285:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	WLAN_STATUS_ASSOC_REJECTED_BAD_SUPP_CHAN = 24,
 286:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	/* 802.11g */
 287:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	WLAN_STATUS_ASSOC_DENIED_NOSHORTTIME = 25,
 288:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	WLAN_STATUS_ASSOC_DENIED_NODSSSOFDM = 26,
 289:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	/* 802.11i */
 290:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	WLAN_STATUS_INVALID_IE = 40,
 291:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	WLAN_STATUS_INVALID_GROUP_CIPHER = 41,
 292:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	WLAN_STATUS_INVALID_PAIRWISE_CIPHER = 42,
 293:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	WLAN_STATUS_INVALID_AKMP = 43,
GAS LISTING  			page 87


 294:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	WLAN_STATUS_UNSUPP_RSN_VERSION = 44,
 295:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	WLAN_STATUS_INVALID_RSN_IE_CAP = 45,
 296:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	WLAN_STATUS_CIPHER_SUITE_REJECTED = 46,
 297:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** };
 298:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 299:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** /* Reason codes */
 300:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** enum ieee80211_reasoncode {
 301:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	WLAN_REASON_UNSPECIFIED = 1,
 302:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	WLAN_REASON_PREV_AUTH_NOT_VALID = 2,
 303:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	WLAN_REASON_DEAUTH_LEAVING = 3,
 304:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	WLAN_REASON_DISASSOC_DUE_TO_INACTIVITY = 4,
 305:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	WLAN_REASON_DISASSOC_AP_BUSY = 5,
 306:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	WLAN_REASON_CLASS2_FRAME_FROM_NONAUTH_STA = 6,
 307:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	WLAN_REASON_CLASS3_FRAME_FROM_NONASSOC_STA = 7,
 308:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	WLAN_REASON_DISASSOC_STA_HAS_LEFT = 8,
 309:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	WLAN_REASON_STA_REQ_ASSOC_WITHOUT_AUTH = 9,
 310:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	/* 802.11h */
 311:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	WLAN_REASON_DISASSOC_BAD_POWER = 10,
 312:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	WLAN_REASON_DISASSOC_BAD_SUPP_CHAN = 11,
 313:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	/* 802.11i */
 314:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	WLAN_REASON_INVALID_IE = 13,
 315:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	WLAN_REASON_MIC_FAILURE = 14,
 316:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	WLAN_REASON_4WAY_HANDSHAKE_TIMEOUT = 15,
 317:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	WLAN_REASON_GROUP_KEY_HANDSHAKE_TIMEOUT = 16,
 318:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	WLAN_REASON_IE_DIFFERENT = 17,
 319:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	WLAN_REASON_INVALID_GROUP_CIPHER = 18,
 320:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	WLAN_REASON_INVALID_PAIRWISE_CIPHER = 19,
 321:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	WLAN_REASON_INVALID_AKMP = 20,
 322:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	WLAN_REASON_UNSUPP_RSN_VERSION = 21,
 323:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	WLAN_REASON_INVALID_RSN_IE_CAP = 22,
 324:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	WLAN_REASON_IEEE8021X_FAILED = 23,
 325:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	WLAN_REASON_CIPHER_SUITE_REJECTED = 24,
 326:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** };
 327:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 328:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** /* Action categories - 802.11h */
 329:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** enum ieee80211_actioncategories {
 330:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	WLAN_ACTION_SPECTRUM_MGMT = 0,
 331:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	/* Reserved 1-127  */
 332:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	/* Error    128-255 */
 333:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** };
 334:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 335:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** /* Action details - 802.11h */
 336:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** enum ieee80211_actiondetails {
 337:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	WLAN_ACTION_CATEGORY_MEASURE_REQUEST = 0,
 338:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	WLAN_ACTION_CATEGORY_MEASURE_REPORT = 1,
 339:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	WLAN_ACTION_CATEGORY_TPC_REQUEST = 2,
 340:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	WLAN_ACTION_CATEGORY_TPC_REPORT = 3,
 341:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	WLAN_ACTION_CATEGORY_CHANNEL_SWITCH = 4,
 342:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	/* 5 - 255 Reserved */
 343:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** };
 344:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 345:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_STATMASK_SIGNAL (1<<0)
 346:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_STATMASK_RSSI (1<<1)
 347:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_STATMASK_NOISE (1<<2)
 348:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_STATMASK_RATE (1<<3)
 349:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_STATMASK_WEMASK 0x7
 350:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
GAS LISTING  			page 88


 351:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_CCK_MODULATION    (1<<0)
 352:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_OFDM_MODULATION   (1<<1)
 353:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 354:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_24GHZ_BAND     (1<<0)
 355:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_52GHZ_BAND     (1<<1)
 356:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 357:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_CCK_RATE_1MB		        0x02
 358:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_CCK_RATE_2MB		        0x04
 359:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_CCK_RATE_5MB		        0x0B
 360:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_CCK_RATE_11MB		        0x16
 361:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_OFDM_RATE_6MB		        0x0C
 362:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_OFDM_RATE_9MB		        0x12
 363:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_OFDM_RATE_12MB		0x18
 364:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_OFDM_RATE_18MB		0x24
 365:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_OFDM_RATE_24MB		0x30
 366:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_OFDM_RATE_36MB		0x48
 367:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_OFDM_RATE_48MB		0x60
 368:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_OFDM_RATE_54MB		0x6C
 369:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_BASIC_RATE_MASK		0x80
 370:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 371:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_CCK_RATE_1MB_MASK		(1<<0)
 372:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_CCK_RATE_2MB_MASK		(1<<1)
 373:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_CCK_RATE_5MB_MASK		(1<<2)
 374:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_CCK_RATE_11MB_MASK		(1<<3)
 375:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_OFDM_RATE_6MB_MASK		(1<<4)
 376:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_OFDM_RATE_9MB_MASK		(1<<5)
 377:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_OFDM_RATE_12MB_MASK		(1<<6)
 378:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_OFDM_RATE_18MB_MASK		(1<<7)
 379:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_OFDM_RATE_24MB_MASK		(1<<8)
 380:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_OFDM_RATE_36MB_MASK		(1<<9)
 381:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_OFDM_RATE_48MB_MASK		(1<<10)
 382:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_OFDM_RATE_54MB_MASK		(1<<11)
 383:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 384:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_CCK_RATES_MASK	        0x0000000F
 385:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_CCK_BASIC_RATES_MASK	(IEEE80211_CCK_RATE_1MB_MASK | \
 386:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	IEEE80211_CCK_RATE_2MB_MASK)
 387:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_CCK_DEFAULT_RATES_MASK	(IEEE80211_CCK_BASIC_RATES_MASK | \
 388:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h ****         IEEE80211_CCK_RATE_5MB_MASK | \
 389:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h ****         IEEE80211_CCK_RATE_11MB_MASK)
 390:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 391:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_OFDM_RATES_MASK		0x00000FF0
 392:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_OFDM_BASIC_RATES_MASK	(IEEE80211_OFDM_RATE_6MB_MASK | \
 393:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	IEEE80211_OFDM_RATE_12MB_MASK | \
 394:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	IEEE80211_OFDM_RATE_24MB_MASK)
 395:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_OFDM_DEFAULT_RATES_MASK	(IEEE80211_OFDM_BASIC_RATES_MASK | \
 396:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	IEEE80211_OFDM_RATE_9MB_MASK  | \
 397:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	IEEE80211_OFDM_RATE_18MB_MASK | \
 398:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	IEEE80211_OFDM_RATE_36MB_MASK | \
 399:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	IEEE80211_OFDM_RATE_48MB_MASK | \
 400:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	IEEE80211_OFDM_RATE_54MB_MASK)
 401:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_DEFAULT_RATES_MASK (IEEE80211_OFDM_DEFAULT_RATES_MASK | \
 402:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h ****                                 IEEE80211_CCK_DEFAULT_RATES_MASK)
 403:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 404:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_NUM_OFDM_RATES	    8
 405:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_NUM_CCK_RATES	            4
 406:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_OFDM_SHIFT_MASK_A         4
 407:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
GAS LISTING  			page 89


 408:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** /* NOTE: This data is for statistical purposes; not all hardware provides this
 409:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h ****  *       information for frames received.
 410:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h ****  *       For ieee80211_rx_mgt, you need to set at least the 'len' parameter.
 411:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h ****  */
 412:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** struct ieee80211_rx_stats {
 413:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u32 mac_time;
 414:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	s8 rssi;
 415:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 signal;
 416:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 noise;
 417:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u16 rate;		/* in 100 kbps */
 418:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 received_channel;
 419:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 control;
 420:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 mask;
 421:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 freq;
 422:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u16 len;
 423:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u64 tsf;
 424:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u32 beacon_time;
 425:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** };
 426:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 427:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** /* IEEE 802.11 requires that STA supports concurrent reception of at least
 428:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h ****  * three fragmented frames. This define can be increased to support more
 429:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h ****  * concurrent frames, but it should be noted that each entry can consume about
 430:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h ****  * 2 kB of RAM and increasing cache size will slow down frame reassembly. */
 431:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_FRAG_CACHE_LEN 4
 432:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 433:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** struct ieee80211_frag_entry {
 434:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	unsigned long first_frag_time;
 435:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	unsigned int seq;
 436:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	unsigned int last_frag;
 437:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	struct sk_buff *skb;
 438:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 src_addr[ETH_ALEN];
 439:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 dst_addr[ETH_ALEN];
 440:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** };
 441:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 442:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** struct ieee80211_stats {
 443:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	unsigned int tx_unicast_frames;
 444:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	unsigned int tx_multicast_frames;
 445:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	unsigned int tx_fragments;
 446:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	unsigned int tx_unicast_octets;
 447:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	unsigned int tx_multicast_octets;
 448:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	unsigned int tx_deferred_transmissions;
 449:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	unsigned int tx_single_retry_frames;
 450:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	unsigned int tx_multiple_retry_frames;
 451:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	unsigned int tx_retry_limit_exceeded;
 452:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	unsigned int tx_discards;
 453:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	unsigned int rx_unicast_frames;
 454:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	unsigned int rx_multicast_frames;
 455:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	unsigned int rx_fragments;
 456:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	unsigned int rx_unicast_octets;
 457:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	unsigned int rx_multicast_octets;
 458:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	unsigned int rx_fcs_errors;
 459:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	unsigned int rx_discards_no_buffer;
 460:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	unsigned int tx_discards_wrong_sa;
 461:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	unsigned int rx_discards_undecryptable;
 462:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	unsigned int rx_message_in_msg_fragments;
 463:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	unsigned int rx_message_in_bad_msg_fragments;
 464:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** };
GAS LISTING  			page 90


 465:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 466:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** struct ieee80211_device;
 467:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 468:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #include "ieee80211_crypt.h"
 469:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 470:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define SEC_KEY_1		(1<<0)
 471:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define SEC_KEY_2		(1<<1)
 472:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define SEC_KEY_3		(1<<2)
 473:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define SEC_KEY_4		(1<<3)
 474:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define SEC_ACTIVE_KEY		(1<<4)
 475:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define SEC_AUTH_MODE		(1<<5)
 476:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define SEC_UNICAST_GROUP	(1<<6)
 477:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define SEC_LEVEL		(1<<7)
 478:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define SEC_ENABLED		(1<<8)
 479:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define SEC_ENCRYPT		(1<<9)
 480:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 481:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define SEC_LEVEL_0		0	/* None */
 482:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define SEC_LEVEL_1		1	/* WEP 40 and 104 bit */
 483:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define SEC_LEVEL_2		2	/* Level 1 + TKIP */
 484:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define SEC_LEVEL_2_CKIP	3	/* Level 1 + CKIP */
 485:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define SEC_LEVEL_3		4	/* Level 2 + CCMP */
 486:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 487:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define SEC_ALG_NONE		0
 488:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define SEC_ALG_WEP		1
 489:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define SEC_ALG_TKIP		2
 490:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define SEC_ALG_CCMP		3
 491:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 492:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define WEP_KEYS		4
 493:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define WEP_KEY_LEN		13
 494:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define SCM_KEY_LEN		32
 495:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define SCM_TEMPORAL_KEY_LENGTH	16
 496:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 497:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** struct ieee80211_security {
 498:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u16 active_key:2,
 499:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	    enabled:1,
 500:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	    auth_mode:2, auth_algo:4, unicast_uses_group:1, encrypt:1;
 501:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 encode_alg[WEP_KEYS];
 502:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 key_sizes[WEP_KEYS];
 503:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 keys[WEP_KEYS][SCM_KEY_LEN];
 504:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 level;
 505:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u16 flags;
 506:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** } __attribute__ ((packed));
 507:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 508:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** /*
 509:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 510:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h ****  802.11 data frame from AP
 511:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 512:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h ****       ,-------------------------------------------------------------------.
 513:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** Bytes |  2   |  2   |    6    |    6    |    6    |  2   | 0..2312 |   4  |
 514:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h ****       |------|------|---------|---------|---------|------|---------|------|
 515:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** Desc. | ctrl | dura |  DA/RA  |   TA    |    SA   | Sequ |  frame  |  fcs |
 516:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h ****       |      | tion | (BSSID) |         |         | ence |  data   |      |
 517:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h ****       `-------------------------------------------------------------------'
 518:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 519:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** Total: 28-2340 bytes
 520:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 521:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** */
GAS LISTING  			page 91


 522:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 523:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define BEACON_PROBE_SSID_ID_POSITION 12
 524:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 525:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** /* Management Frame Information Element Types */
 526:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** enum ieee80211_mfie {
 527:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	MFIE_TYPE_SSID = 0,
 528:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	MFIE_TYPE_RATES = 1,
 529:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	MFIE_TYPE_FH_SET = 2,
 530:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	MFIE_TYPE_DS_SET = 3,
 531:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	MFIE_TYPE_CF_SET = 4,
 532:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	MFIE_TYPE_TIM = 5,
 533:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	MFIE_TYPE_IBSS_SET = 6,
 534:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	MFIE_TYPE_COUNTRY = 7,
 535:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	MFIE_TYPE_HOP_PARAMS = 8,
 536:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	MFIE_TYPE_HOP_TABLE = 9,
 537:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	MFIE_TYPE_REQUEST = 10,
 538:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	MFIE_TYPE_CHALLENGE = 16,
 539:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	MFIE_TYPE_POWER_CONSTRAINT = 32,
 540:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	MFIE_TYPE_POWER_CAPABILITY = 33,
 541:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	MFIE_TYPE_TPC_REQUEST = 34,
 542:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	MFIE_TYPE_TPC_REPORT = 35,
 543:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	MFIE_TYPE_SUPP_CHANNELS = 36,
 544:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	MFIE_TYPE_CSA = 37,
 545:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	MFIE_TYPE_MEASURE_REQUEST = 38,
 546:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	MFIE_TYPE_MEASURE_REPORT = 39,
 547:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	MFIE_TYPE_QUIET = 40,
 548:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	MFIE_TYPE_IBSS_DFS = 41,
 549:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	MFIE_TYPE_ERP_INFO = 42,
 550:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	MFIE_TYPE_RSN = 48,
 551:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	MFIE_TYPE_RATES_EX = 50,
 552:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	MFIE_TYPE_GENERIC = 221,
 553:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	MFIE_TYPE_QOS_PARAMETER = 222,
 554:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** };
 555:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 556:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** /* Minimal header; can be used for passing 802.11 frames with sufficient
 557:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h ****  * information to determine what type of underlying data type is actually
 558:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h ****  * stored in the data. */
 559:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** struct ieee80211_hdr {
 560:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	__le16 frame_ctl;
 561:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	__le16 duration_id;
 562:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 payload[0];
 563:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** } __attribute__ ((packed));
 564:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 565:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** struct ieee80211_hdr_1addr {
 566:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	__le16 frame_ctl;
 567:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	__le16 duration_id;
 568:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 addr1[ETH_ALEN];
 569:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 payload[0];
 570:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** } __attribute__ ((packed));
 571:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 572:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** struct ieee80211_hdr_2addr {
 573:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	__le16 frame_ctl;
 574:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	__le16 duration_id;
 575:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 addr1[ETH_ALEN];
 576:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 addr2[ETH_ALEN];
 577:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 payload[0];
 578:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** } __attribute__ ((packed));
GAS LISTING  			page 92


 579:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 580:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** struct ieee80211_hdr_3addr {
 581:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	__le16 frame_ctl;
 582:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	__le16 duration_id;
 583:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 addr1[ETH_ALEN];
 584:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 addr2[ETH_ALEN];
 585:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 addr3[ETH_ALEN];
 586:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	__le16 seq_ctl;
 587:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 payload[0];
 588:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** } __attribute__ ((packed));
 589:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 590:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** struct ieee80211_hdr_4addr {
 591:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	__le16 frame_ctl;
 592:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	__le16 duration_id;
 593:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 addr1[ETH_ALEN];
 594:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 addr2[ETH_ALEN];
 595:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 addr3[ETH_ALEN];
 596:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	__le16 seq_ctl;
 597:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 addr4[ETH_ALEN];
 598:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 payload[0];
 599:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** } __attribute__ ((packed));
 600:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 601:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** struct ieee80211_hdr_3addrqos {
 602:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	__le16 frame_ctl;
 603:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	__le16 duration_id;
 604:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 addr1[ETH_ALEN];
 605:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 addr2[ETH_ALEN];
 606:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 addr3[ETH_ALEN];
 607:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	__le16 seq_ctl;
 608:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 payload[0];
 609:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	__le16 qos_ctl;
 610:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** } __attribute__ ((packed));
 611:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 612:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** struct ieee80211_hdr_4addrqos {
 613:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	__le16 frame_ctl;
 614:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	__le16 duration_id;
 615:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 addr1[ETH_ALEN];
 616:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 addr2[ETH_ALEN];
 617:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 addr3[ETH_ALEN];
 618:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	__le16 seq_ctl;
 619:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 addr4[ETH_ALEN];
 620:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 payload[0];
 621:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	__le16 qos_ctl;
 622:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** } __attribute__ ((packed));
 623:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 624:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** struct ieee80211_info_element {
 625:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 id;
 626:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 len;
 627:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 data[0];
 628:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** } __attribute__ ((packed));
 629:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 630:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** /*
 631:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h ****  * These are the data types that can make up management packets
 632:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h ****  *
 633:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u16 auth_algorithm;
 634:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u16 auth_sequence;
 635:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u16 beacon_interval;
GAS LISTING  			page 93


 636:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u16 capability;
 637:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 current_ap[ETH_ALEN];
 638:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u16 listen_interval;
 639:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	struct {
 640:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 		u16 association_id:14, reserved:2;
 641:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	} __attribute__ ((packed));
 642:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u32 time_stamp[2];
 643:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u16 reason;
 644:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u16 status;
 645:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** */
 646:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 647:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** struct ieee80211_auth {
 648:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	struct ieee80211_hdr_3addr header;
 649:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	__le16 algorithm;
 650:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	__le16 transaction;
 651:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	__le16 status;
 652:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	/* challenge */
 653:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	struct ieee80211_info_element info_element[0];
 654:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** } __attribute__ ((packed));
 655:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 656:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** struct ieee80211_channel_switch {
 657:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 id;
 658:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 len;
 659:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 mode;
 660:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 channel;
 661:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 count;
 662:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** } __attribute__ ((packed));
 663:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 664:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** struct ieee80211_action {
 665:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	struct ieee80211_hdr_3addr header;
 666:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 category;
 667:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 action;
 668:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	union {
 669:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 		struct ieee80211_action_exchange {
 670:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 			u8 token;
 671:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 			struct ieee80211_info_element info_element[0];
 672:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 		} exchange;
 673:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 		struct ieee80211_channel_switch channel_switch;
 674:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 675:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	} format;
 676:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** } __attribute__ ((packed));
 677:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 678:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** struct ieee80211_disassoc {
 679:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	struct ieee80211_hdr_3addr header;
 680:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	__le16 reason;
 681:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** } __attribute__ ((packed));
 682:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 683:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** /* Alias deauth for disassoc */
 684:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define ieee80211_deauth ieee80211_disassoc
 685:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 686:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** struct ieee80211_probe_request {
 687:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	struct ieee80211_hdr_3addr header;
 688:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	/* SSID, supported rates */
 689:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	struct ieee80211_info_element info_element[0];
 690:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** } __attribute__ ((packed));
 691:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 692:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** struct ieee80211_probe_response {
GAS LISTING  			page 94


 693:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	struct ieee80211_hdr_3addr header;
 694:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u32 time_stamp[2];
 695:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	__le16 beacon_interval;
 696:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	__le16 capability;
 697:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	/* SSID, supported rates, FH params, DS params,
 698:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	 * CF params, IBSS params, TIM (if beacon), RSN */
 699:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	struct ieee80211_info_element info_element[0];
 700:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** } __attribute__ ((packed));
 701:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 702:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** /* Alias beacon for probe_response */
 703:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define ieee80211_beacon ieee80211_probe_response
 704:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 705:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** struct ieee80211_assoc_request {
 706:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	struct ieee80211_hdr_3addr header;
 707:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	__le16 capability;
 708:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	__le16 listen_interval;
 709:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	/* SSID, supported rates, RSN */
 710:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	struct ieee80211_info_element info_element[0];
 711:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** } __attribute__ ((packed));
 712:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 713:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** struct ieee80211_reassoc_request {
 714:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	struct ieee80211_hdr_3addr header;
 715:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	__le16 capability;
 716:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	__le16 listen_interval;
 717:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 current_ap[ETH_ALEN];
 718:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	struct ieee80211_info_element info_element[0];
 719:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** } __attribute__ ((packed));
 720:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 721:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** struct ieee80211_assoc_response {
 722:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	struct ieee80211_hdr_3addr header;
 723:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	__le16 capability;
 724:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	__le16 status;
 725:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	__le16 aid;
 726:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	/* supported rates */
 727:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	struct ieee80211_info_element info_element[0];
 728:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** } __attribute__ ((packed));
 729:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 730:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** struct ieee80211_txb {
 731:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 nr_frags;
 732:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 encrypted;
 733:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 rts_included;
 734:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 reserved;
 735:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	__le16 frag_size;
 736:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	__le16 payload_size;
 737:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	struct sk_buff *fragments[0];
 738:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** };
 739:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 740:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** /* SWEEP TABLE ENTRIES NUMBER */
 741:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define MAX_SWEEP_TAB_ENTRIES		  42
 742:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define MAX_SWEEP_TAB_ENTRIES_PER_PACKET  7
 743:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** /* MAX_RATES_LENGTH needs to be 12.  The spec says 8, and many APs
 744:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h ****  * only use 8, and then use extended rates for the remaining supported
 745:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h ****  * rates.  Other APs, however, stick all of their supported rates on the
 746:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h ****  * main rates information element... */
 747:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define MAX_RATES_LENGTH                  ((u8)12)
 748:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define MAX_RATES_EX_LENGTH               ((u8)16)
 749:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define MAX_NETWORK_COUNT                  128
GAS LISTING  			page 95


 750:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 751:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define CRC_LENGTH                 4U
 752:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 753:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define MAX_WPA_IE_LEN 64
 754:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 755:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define NETWORK_EMPTY_ESSID    (1<<0)
 756:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define NETWORK_HAS_OFDM       (1<<1)
 757:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define NETWORK_HAS_CCK        (1<<2)
 758:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 759:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** /* QoS structure */
 760:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define NETWORK_HAS_QOS_PARAMETERS      (1<<3)
 761:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define NETWORK_HAS_QOS_INFORMATION     (1<<4)
 762:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define NETWORK_HAS_QOS_MASK            (NETWORK_HAS_QOS_PARAMETERS | \
 763:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 					 NETWORK_HAS_QOS_INFORMATION)
 764:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 765:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** /* 802.11h */
 766:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define NETWORK_HAS_POWER_CONSTRAINT    (1<<5)
 767:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define NETWORK_HAS_CSA                 (1<<6)
 768:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define NETWORK_HAS_QUIET               (1<<7)
 769:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define NETWORK_HAS_IBSS_DFS            (1<<8)
 770:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define NETWORK_HAS_TPC_REPORT          (1<<9)
 771:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 772:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define QOS_QUEUE_NUM                   4
 773:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define QOS_OUI_LEN                     3
 774:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define QOS_OUI_TYPE                    2
 775:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define QOS_ELEMENT_ID                  221
 776:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define QOS_OUI_INFO_SUB_TYPE           0
 777:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define QOS_OUI_PARAM_SUB_TYPE          1
 778:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define QOS_VERSION_1                   1
 779:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define QOS_AIFSN_MIN_VALUE             2
 780:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 781:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** struct ieee80211_qos_information_element {
 782:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 elementID;
 783:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 length;
 784:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 qui[QOS_OUI_LEN];
 785:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 qui_type;
 786:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 qui_subtype;
 787:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 version;
 788:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 ac_info;
 789:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** } __attribute__ ((packed));
 790:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 791:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** struct ieee80211_qos_ac_parameter {
 792:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 aci_aifsn;
 793:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 ecw_min_max;
 794:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	__le16 tx_op_limit;
 795:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** } __attribute__ ((packed));
 796:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 797:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** struct ieee80211_qos_parameter_info {
 798:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	struct ieee80211_qos_information_element info_element;
 799:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 reserved;
 800:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	struct ieee80211_qos_ac_parameter ac_params_record[QOS_QUEUE_NUM];
 801:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** } __attribute__ ((packed));
 802:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 803:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** struct ieee80211_qos_parameters {
 804:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	__le16 cw_min[QOS_QUEUE_NUM];
 805:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	__le16 cw_max[QOS_QUEUE_NUM];
 806:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 aifs[QOS_QUEUE_NUM];
GAS LISTING  			page 96


 807:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 flag[QOS_QUEUE_NUM];
 808:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	__le16 tx_op_limit[QOS_QUEUE_NUM];
 809:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** } __attribute__ ((packed));
 810:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 811:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** struct ieee80211_qos_data {
 812:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	struct ieee80211_qos_parameters parameters;
 813:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	int active;
 814:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	int supported;
 815:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 param_count;
 816:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 old_param_count;
 817:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** };
 818:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 819:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** struct ieee80211_tim_parameters {
 820:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 tim_count;
 821:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 tim_period;
 822:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** } __attribute__ ((packed));
 823:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 824:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** /*******************************************************/
 825:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 826:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** enum {				/* ieee80211_basic_report.map */
 827:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	IEEE80211_BASIC_MAP_BSS = (1 << 0),
 828:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	IEEE80211_BASIC_MAP_OFDM = (1 << 1),
 829:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	IEEE80211_BASIC_MAP_UNIDENTIFIED = (1 << 2),
 830:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	IEEE80211_BASIC_MAP_RADAR = (1 << 3),
 831:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	IEEE80211_BASIC_MAP_UNMEASURED = (1 << 4),
 832:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	/* Bits 5-7 are reserved */
 833:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 834:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** };
 835:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** struct ieee80211_basic_report {
 836:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 channel;
 837:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	__le64 start_time;
 838:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	__le16 duration;
 839:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 map;
 840:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** } __attribute__ ((packed));
 841:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 842:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** enum {				/* ieee80211_measurement_request.mode */
 843:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	/* Bit 0 is reserved */
 844:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	IEEE80211_MEASUREMENT_ENABLE = (1 << 1),
 845:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	IEEE80211_MEASUREMENT_REQUEST = (1 << 2),
 846:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	IEEE80211_MEASUREMENT_REPORT = (1 << 3),
 847:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	/* Bits 4-7 are reserved */
 848:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** };
 849:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 850:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** enum {
 851:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	IEEE80211_REPORT_BASIC = 0,	/* required */
 852:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	IEEE80211_REPORT_CCA = 1,	/* optional */
 853:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	IEEE80211_REPORT_RPI = 2,	/* optional */
 854:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	/* 3-255 reserved */
 855:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** };
 856:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 857:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** struct ieee80211_measurement_params {
 858:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 channel;
 859:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	__le64 start_time;
 860:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	__le16 duration;
 861:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** } __attribute__ ((packed));
 862:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 863:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** struct ieee80211_measurement_request {
GAS LISTING  			page 97


 864:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	struct ieee80211_info_element ie;
 865:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 token;
 866:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 mode;
 867:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 type;
 868:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	struct ieee80211_measurement_params params[0];
 869:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** } __attribute__ ((packed));
 870:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 871:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** struct ieee80211_measurement_report {
 872:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	struct ieee80211_info_element ie;
 873:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 token;
 874:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 mode;
 875:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 type;
 876:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	union {
 877:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 		struct ieee80211_basic_report basic[0];
 878:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	} u;
 879:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** } __attribute__ ((packed));
 880:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 881:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** struct ieee80211_tpc_report {
 882:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 transmit_power;
 883:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 link_margin;
 884:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** } __attribute__ ((packed));
 885:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 886:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** struct ieee80211_channel_map {
 887:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 channel;
 888:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 map;
 889:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** } __attribute__ ((packed));
 890:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 891:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** struct ieee80211_ibss_dfs {
 892:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	struct ieee80211_info_element ie;
 893:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 owner[ETH_ALEN];
 894:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 recovery_interval;
 895:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	struct ieee80211_channel_map channel_map[0];
 896:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** };
 897:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 898:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** struct ieee80211_csa {
 899:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 mode;
 900:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 channel;
 901:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 count;
 902:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** } __attribute__ ((packed));
 903:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 904:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** struct ieee80211_quiet {
 905:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 count;
 906:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 period;
 907:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 duration;
 908:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 offset;
 909:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** } __attribute__ ((packed));
 910:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 911:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** struct ieee80211_network {
 912:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	/* These entries are used to identify a unique network */
 913:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 bssid[ETH_ALEN];
 914:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 channel;
 915:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	/* Ensure null-terminated for any debug msgs */
 916:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 ssid[IW_ESSID_MAX_SIZE + 1];
 917:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 ssid_len;
 918:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 919:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	struct ieee80211_qos_data qos_data;
 920:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
GAS LISTING  			page 98


 921:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	/* These are network statistics */
 922:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	struct ieee80211_rx_stats stats;
 923:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u16 capability;
 924:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 rates[MAX_RATES_LENGTH];
 925:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 rates_len;
 926:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 rates_ex[MAX_RATES_EX_LENGTH];
 927:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 rates_ex_len;
 928:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	unsigned long last_scanned;
 929:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 mode;
 930:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u32 flags;
 931:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u32 last_associate;
 932:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u32 time_stamp[2];
 933:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u16 beacon_interval;
 934:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u16 listen_interval;
 935:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u16 atim_window;
 936:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 erp_value;
 937:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 wpa_ie[MAX_WPA_IE_LEN];
 938:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	size_t wpa_ie_len;
 939:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 rsn_ie[MAX_WPA_IE_LEN];
 940:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	size_t rsn_ie_len;
 941:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	struct ieee80211_tim_parameters tim;
 942:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 943:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	/* 802.11h info */
 944:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 945:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	/* Power Constraint - mandatory if spctrm mgmt required */
 946:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 power_constraint;
 947:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 948:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	/* TPC Report - mandatory if spctrm mgmt required */
 949:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	struct ieee80211_tpc_report tpc_report;
 950:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 951:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	/* IBSS DFS - mandatory if spctrm mgmt required and IBSS
 952:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	 * NOTE: This is variable length and so must be allocated dynamically */
 953:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	struct ieee80211_ibss_dfs *ibss_dfs;
 954:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 955:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	/* Channel Switch Announcement - optional if spctrm mgmt required */
 956:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	struct ieee80211_csa csa;
 957:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 958:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	/* Quiet - optional if spctrm mgmt required */
 959:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	struct ieee80211_quiet quiet;
 960:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 961:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	struct list_head list;
 962:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** };
 963:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 964:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** enum ieee80211_state {
 965:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	IEEE80211_UNINITIALIZED = 0,
 966:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	IEEE80211_INITIALIZED,
 967:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	IEEE80211_ASSOCIATING,
 968:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	IEEE80211_ASSOCIATED,
 969:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	IEEE80211_AUTHENTICATING,
 970:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	IEEE80211_AUTHENTICATED,
 971:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	IEEE80211_SHUTDOWN
 972:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** };
 973:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 974:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define DEFAULT_MAX_SCAN_AGE (15 * HZ)
 975:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define DEFAULT_FTS 2346
 976:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 977:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define CFG_IEEE80211_RESERVE_FCS (1<<0)
GAS LISTING  			page 99


 978:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define CFG_IEEE80211_COMPUTE_FCS (1<<1)
 979:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define CFG_IEEE80211_RTS (1<<2)
 980:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 981:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_24GHZ_MIN_CHANNEL 1
 982:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_24GHZ_MAX_CHANNEL 14
 983:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_24GHZ_CHANNELS    14
 984:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 985:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_52GHZ_MIN_CHANNEL 34
 986:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_52GHZ_MAX_CHANNEL 165
 987:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE80211_52GHZ_CHANNELS    131
 988:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 989:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** enum {
 990:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	IEEE80211_CH_PASSIVE_ONLY = (1 << 0),
 991:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	IEEE80211_CH_B_ONLY = (1 << 2),
 992:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	IEEE80211_CH_NO_IBSS = (1 << 3),
 993:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	IEEE80211_CH_UNIFORM_SPREADING = (1 << 4),
 994:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	IEEE80211_CH_RADAR_DETECT = (1 << 5),
 995:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	IEEE80211_CH_INVALID = (1 << 6),
 996:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** };
 997:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
 998:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** struct ieee80211_channel {
 999:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u32 freq;
1000:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 channel;
1001:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 flags;
1002:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 max_power;
1003:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** };
1004:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
1005:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** struct ieee80211_geo {
1006:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 name[4];
1007:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 bg_channels;
1008:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 a_channels;
1009:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	struct ieee80211_channel bg[IEEE80211_24GHZ_CHANNELS];
1010:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	struct ieee80211_channel a[IEEE80211_52GHZ_CHANNELS];
1011:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** };
1012:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
1013:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** struct ieee80211_device {
1014:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	struct net_device *dev;
1015:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	struct ieee80211_security sec;
1016:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
1017:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	/* Bookkeeping structures */
1018:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	struct net_device_stats stats;
1019:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	struct ieee80211_stats ieee_stats;
1020:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
1021:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	struct ieee80211_geo geo;
1022:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
1023:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	/* Probe / Beacon management */
1024:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	struct list_head network_free_list;
1025:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	struct list_head network_list;
1026:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	struct ieee80211_network *networks;
1027:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	int scans;
1028:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	int scan_age;
1029:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
1030:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	int iw_mode;		/* operating mode (IW_MODE_*) */
1031:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	struct iw_spy_data spy_data;	/* iwspy support */
1032:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
1033:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	spinlock_t lock;
1034:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
GAS LISTING  			page 100


1035:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	int tx_headroom;	/* Set to size of any additional room needed at front
1036:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 				 * of allocated Tx SKBs */
1037:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u32 config;
1038:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
1039:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	/* WEP and other encryption related settings at the device level */
1040:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	int open_wep;		/* Set to 1 to allow unencrypted frames */
1041:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
1042:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	int reset_on_keychange;	/* Set to 1 if the HW needs to be reset on
1043:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 				 * WEP key changes */
1044:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
1045:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	/* If the host performs {en,de}cryption, then set to 1 */
1046:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	int host_encrypt;
1047:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	int host_encrypt_msdu;
1048:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	int host_decrypt;
1049:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	/* host performs multicast decryption */
1050:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	int host_mc_decrypt;
1051:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
1052:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	int host_open_frag;
1053:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	int host_build_iv;
1054:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	int ieee802_1x;		/* is IEEE 802.1X used */
1055:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
1056:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	/* WPA data */
1057:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	int wpa_enabled;
1058:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	int drop_unencrypted;
1059:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	int privacy_invoked;
1060:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	size_t wpa_ie_len;
1061:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 *wpa_ie;
1062:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
1063:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	struct list_head crypt_deinit_list;
1064:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	struct ieee80211_crypt_data *crypt[WEP_KEYS];
1065:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	int tx_keyidx;		/* default TX key index (crypt[tx_keyidx]) */
1066:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	struct timer_list crypt_deinit_timer;
1067:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	int crypt_quiesced;
1068:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
1069:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	int bcrx_sta_key;	/* use individual keys to override default keys even
1070:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 				 * with RX of broad/multicast frames */
1071:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
1072:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	/* Fragmentation structures */
1073:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	struct ieee80211_frag_entry frag_cache[IEEE80211_FRAG_CACHE_LEN];
1074:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	unsigned int frag_next_idx;
1075:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u16 fts;		/* Fragmentation Threshold */
1076:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u16 rts;		/* RTS threshold */
1077:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
1078:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	/* Association info */
1079:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 bssid[ETH_ALEN];
1080:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
1081:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	enum ieee80211_state state;
1082:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
1083:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	int mode;		/* A, B, G */
1084:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	int modulation;		/* CCK, OFDM */
1085:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	int freq_band;		/* 2.4Ghz, 5.2Ghz, Mixed */
1086:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	int abg_true;		/* ABG flag              */
1087:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
1088:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	int perfect_rssi;
1089:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	int worst_rssi;
1090:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
1091:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	/* Callback functions */
GAS LISTING  			page 101


1092:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	void (*set_security) (struct net_device * dev,
1093:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 			      struct ieee80211_security * sec);
1094:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	int (*hard_start_xmit) (struct ieee80211_txb * txb,
1095:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 				struct net_device * dev, int pri);
1096:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	int (*reset_port) (struct net_device * dev);
1097:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	int (*is_queue_full) (struct net_device * dev, int pri);
1098:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
1099:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	int (*handle_management) (struct net_device * dev,
1100:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 				  struct ieee80211_network * network, u16 type);
1101:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
1102:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	/* Typical STA methods */
1103:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	int (*handle_auth) (struct net_device * dev,
1104:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 			    struct ieee80211_auth * auth);
1105:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	int (*handle_deauth) (struct net_device * dev,
1106:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 			      struct ieee80211_deauth * auth);
1107:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	int (*handle_action) (struct net_device * dev,
1108:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 			      struct ieee80211_action * action,
1109:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 			      struct ieee80211_rx_stats * stats);
1110:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	int (*handle_disassoc) (struct net_device * dev,
1111:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 				struct ieee80211_disassoc * assoc);
1112:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	int (*handle_beacon) (struct net_device * dev,
1113:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 			      struct ieee80211_beacon * beacon,
1114:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 			      struct ieee80211_network * network);
1115:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	int (*handle_probe_response) (struct net_device * dev,
1116:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 				      struct ieee80211_probe_response * resp,
1117:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 				      struct ieee80211_network * network);
1118:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	int (*handle_probe_request) (struct net_device * dev,
1119:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 				     struct ieee80211_probe_request * req,
1120:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 				     struct ieee80211_rx_stats * stats);
1121:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	int (*handle_assoc_response) (struct net_device * dev,
1122:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 				      struct ieee80211_assoc_response * resp,
1123:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 				      struct ieee80211_network * network);
1124:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
1125:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	/* Typical AP methods */
1126:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	int (*handle_assoc_request) (struct net_device * dev);
1127:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	int (*handle_reassoc_request) (struct net_device * dev,
1128:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 				       struct ieee80211_reassoc_request * req);
1129:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
1130:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	/* This must be the last item so that it points to the data
1131:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	 * allocated beyond this structure by alloc_ieee80211 */
1132:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	u8 priv[0];
1133:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** };
1134:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
1135:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE_A            (1<<0)
1136:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE_B            (1<<1)
1137:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE_G            (1<<2)
1138:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define IEEE_MODE_MASK    (IEEE_A|IEEE_B|IEEE_G)
1139:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
1140:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #include <linux/version.h>	/* KERNEL_VERSION */
1141:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,12)
1142:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** static inline int is_multicast_ether_addr(const u8 *addr)
1143:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** {
1144:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h ****        return addr[0] & 0x01;
1145:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** }
1146:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #endif
1147:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
1148:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** /* Fix for kernels < 2.6.12, since we use __nocast */
GAS LISTING  			page 102


1149:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #ifndef __nocast
1150:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #define __nocast
1151:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #endif
1152:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
1153:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,14)
1154:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** static inline void *kzalloc(size_t size, unsigned __nocast flags)
1155:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** {
1156:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	void *ret = kmalloc(size, flags);
1157:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	if (ret)
1158:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 		memset(ret, 0, size);
1159:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	return ret;
1160:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** }
1161:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #endif
1162:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
1163:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,15)
1164:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** static inline unsigned compare_ether_addr(const u8 *_a, const u8 *_b)
1165:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** {
1166:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	const u16 *a = (const u16 *) _a;
1167:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	const u16 *b = (const u16 *) _b;
1168:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
1169:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	BUILD_BUG_ON(ETH_ALEN != 6);
1170:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	return ((a[0] ^ b[0]) | (a[1] ^ b[1]) | (a[2] ^ b[2])) != 0;
1171:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** }
1172:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #endif
1173:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
1174:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** static inline void *ieee80211_priv(struct net_device *dev)
1175:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** {
1176:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 	return ((struct ieee80211_device *)netdev_priv(dev))->priv;
1177:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** }
1178:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** 
1179:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,14)
1180:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** static inline int is_broadcast_ether_addr(const u8 *addr)
1181:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h **** {
1182:/home/usuario/ipw3945install/ieee80211-1.1.12/net/ieee80211.h ****         return (addr[0] & addr[1] & addr[2] & addr[3] & addr[4] & addr[5]) == 0xff;
 1445              	.loc 10 1182 0
 1446 0830 22442455 	andb 85(%esp),%al
 1447 0834 22442456 	andb 86(%esp),%al
 1448 0838 22442457 	andb 87(%esp),%al
 1449 083c 23442458 	andl 88(%esp),%eax
 1450 0840 22442459 	andb 89(%esp),%al
 1451              	.LBE140:
 1452              	.LBE139:
 1453              	.loc 10 1181 0
 1454 0844 FEC0     	incb %al
 1455 0846 7507     	jne .L450
 1456              	.L451:
 349:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		/* Determine fragmentation size based on destination (multicast
 350:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		 * and broadcast are not fragmented) */
 351:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		if (is_multicast_ether_addr(dest) ||
 352:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		    is_broadcast_ether_addr(dest))
 353:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 			frag_size = MAX_FRAG_THRESHOLD;
 1457              	.loc 1 353 0
 1458 0848 BB2A0900 	movl $2346,%ebx
 1458      00
 1459 084d EB0B     	jmp .L454
 1460              	.L450:
 354:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		else
GAS LISTING  			page 103


 355:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 			frag_size = ieee->fts;
 1461              	.loc 1 355 0
 1462 084f 8B442440 	movl 64(%esp),%eax
 1463 0853 0FB7984C 	movzwl 1868(%eax),%ebx
 1463      070000
 1464              	.L454:
 356:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 
 357:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		/* Determine amount of payload per fragment.  Regardless of if
 358:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		 * this stack is providing the full 802.11 header, one will
 359:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		 * eventually be affixed to this fragment -- so we must account
 360:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		 * for it when determining the amount of payload space. */
 361:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		bytes_per_frag = frag_size - IEEE80211_3ADDR_LEN;
 1465              	.loc 1 361 0
 1466 085a 8D53E8   	leal -24(%ebx),%edx
 1467 085d 89542434 	movl %edx,52(%esp)
 362:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		if (ieee->config &
 1468              	.loc 1 362 0
 1469 0861 8B7C2440 	movl 64(%esp),%edi
 1470 0865 F6875C06 	testb $3,1628(%edi)
 1470      000003
 1471 086c 7407     	je .L455
 363:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		    (CFG_IEEE80211_COMPUTE_FCS | CFG_IEEE80211_RESERVE_FCS))
 364:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 			bytes_per_frag -= IEEE80211_FCS_LEN;
 1472              	.loc 1 364 0
 1473 086e 8D43E4   	leal -28(%ebx),%eax
 1474 0871 89442434 	movl %eax,52(%esp)
 1475              	.L455:
 365:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 
 366:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		/* Each fragment may need to have room for encryptiong
 367:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		 * pre/postfix */
 368:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		if (host_encrypt)
 1476              	.loc 1 368 0
 1477 0875 837C2418 	cmpl $0,24(%esp)
 1477      00
 1478 087a 7415     	je .L456
 369:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 			bytes_per_frag -= crypt->ops->extra_mpdu_prefix_len +
 1479              	.loc 1 369 0
 1480 087c 8B542408 	movl 8(%esp),%edx
 1481 0880 8B4208   	movl 8(%edx),%eax
 1482 0883 8B783C   	movl 60(%eax),%edi
 1483 0886 297C2434 	subl %edi,52(%esp)
 1484 088a 8B5040   	movl 64(%eax),%edx
 1485 088d 29542434 	subl %edx,52(%esp)
 1486              	.L456:
 370:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 			    crypt->ops->extra_mpdu_postfix_len;
 371:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 
 372:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		/* Number of fragments is the total
 373:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		 * bytes_per_frag / payload_per_fragment */
 374:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		nr_frags = bytes / bytes_per_frag;
 375:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		bytes_last_frag = bytes % bytes_per_frag;
 1487              	.loc 1 375 0
 1488 0891 8B442410 	movl 16(%esp),%eax
 1489 0895 99       	cltd
 1490 0896 F77C2434 	idivl 52(%esp)
 376:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		if (bytes_last_frag)
 1491              	.loc 1 376 0
 1492 089a 85D2     	testl %edx,%edx
GAS LISTING  			page 104


 1493              	.loc 1 375 0
 1494 089c 8954242C 	movl %edx,44(%esp)
 1495 08a0 89442430 	movl %eax,48(%esp)
 1496              	.loc 1 376 0
 1497 08a4 7407     	je .L457
 377:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 			nr_frags++;
 1498              	.loc 1 377 0
 1499 08a6 40       	incl %eax
 1500 08a7 89442430 	movl %eax,48(%esp)
 1501 08ab EB23     	jmp .L459
 1502              	.L457:
 378:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		else
 379:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 			bytes_last_frag = bytes_per_frag;
 1503              	.loc 1 379 0
 1504 08ad 8B7C2434 	movl 52(%esp),%edi
 1505 08b1 897C242C 	movl %edi,44(%esp)
 1506 08b5 EB19     	jmp .L459
 1507              	.L448:
 380:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	} else {
 381:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		nr_frags = 1;
 382:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		bytes_per_frag = bytes_last_frag = bytes;
 1508              	.loc 1 382 0
 1509 08b7 8B442410 	movl 16(%esp),%eax
 383:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		frag_size = bytes + IEEE80211_3ADDR_LEN;
 1510              	.loc 1 383 0
 1511 08bb 89C3     	movl %eax,%ebx
 1512              	.loc 1 381 0
 1513 08bd C7442430 	movl $1,48(%esp)
 1513      01000000 
 1514              	.loc 1 382 0
 1515 08c5 8944242C 	movl %eax,44(%esp)
 1516 08c9 89442434 	movl %eax,52(%esp)
 1517              	.loc 1 383 0
 1518 08cd 83C318   	addl $24,%ebx
 1519              	.L459:
 384:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	}
 385:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 
 386:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	rts_required = (frag_size > ieee->rts
 1520              	.loc 1 386 0
 1521 08d0 8B542440 	movl 64(%esp),%edx
 1522 08d4 0FB7824E 	movzwl 1870(%edx),%eax
 1522      070000
 1523 08db 31F6     	xorl %esi,%esi
 1524 08dd 39C3     	cmpl %eax,%ebx
 1525 08df 7E11     	jle .L461
 1526 08e1 F6825C06 	testb $4,1628(%edx)
 1526      000004
 1527 08e8 7408     	je .L461
 1528 08ea 66BE0100 	movw $1,%si
 387:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 			&& ieee->config & CFG_IEEE80211_RTS);
 388:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	if (rts_required)
 389:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		nr_frags++;
 1529              	.loc 1 389 0
 1530 08ee FF442430 	incl 48(%esp)
 1531              	.L461:
 390:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 
 391:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	/* When we allocate the TXB we allocate enough space for the reserve
GAS LISTING  			page 105


 392:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	 * and full fragment bytes (bytes_per_frag doesn't include prefix,
 393:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	 * postfix, header, FCS, etc.) */
 394:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	txb = ieee80211_alloc_txb(nr_frags, frag_size,
 1532              	.loc 1 394 0
 1533 08f2 6A20     	pushl $32
 1534              	.LCFI81:
 1535 08f4 8B7C2444 	movl 68(%esp),%edi
 1536 08f8 FFB75806 	pushl 1624(%edi)
 1536      0000
 1537              	.LCFI82:
 1538 08fe 53       	pushl %ebx
 1539              	.LCFI83:
 1540 08ff FF74243C 	pushl 60(%esp)
 1541              	.LCFI84:
 1542 0903 E84DF8FF 	call ieee80211_alloc_txb
 1542      FF
 1543 0908 8944244C 	movl %eax,76(%esp)
 395:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 				  ieee->tx_headroom, GFP_ATOMIC);
 396:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	if (unlikely(!txb)) {
 1544              	.loc 1 396 0
 1545 090c 83C410   	addl $16,%esp
 1546              	.LCFI85:
 1547 090f 85C0     	testl %eax,%eax
 1548 0911 7513     	jne .L462
 397:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		printk(KERN_WARNING "%s: Could not allocate TXB\n",
 1549              	.loc 1 397 0
 1550 0913 FF37     	pushl (%edi)
 1551              	.LCFI86:
 1552 0915 687E0000 	pushl $.LC4
 1552      00
 1553              	.LCFI87:
 1554 091a E8FCFFFF 	call printk
 1554      FF
 398:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		       ieee->dev->name);
 399:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		goto failed;
 1555              	.loc 1 399 0
 1556 091f 59       	popl %ecx
 1557              	.LCFI88:
 1558 0920 5B       	popl %ebx
 1559              	.LCFI89:
 1560 0921 E9F30300 	jmp .L623
 1560      00
 1561              	.L462:
 400:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	}
 401:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	txb->encrypted = encrypt;
 1562              	.loc 1 401 0
 1563 0926 8A44241C 	movb 28(%esp),%al
 1564 092a 8B54243C 	movl 60(%esp),%edx
 1565 092e 884201   	movb %al,1(%edx)
 402:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	if (host_encrypt)
 1566              	.loc 1 402 0
 1567 0931 837C2418 	cmpl $0,24(%esp)
 1567      00
 1568 0936 7415     	je .L463
 403:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		txb->payload_size = frag_size * (nr_frags - 1) +
 1569              	.loc 1 403 0
 1570 0938 8B442430 	movl 48(%esp),%eax
GAS LISTING  			page 106


 1571 093c 48       	decl %eax
 1572 093d 8B7C242C 	movl 44(%esp),%edi
 1573 0941 0FAFD8   	imull %eax,%ebx
 1574 0944 8D043B   	leal (%ebx,%edi),%eax
 1575 0947 66894206 	movw %ax,6(%edx)
 1576 094b EB0C     	jmp .L464
 1577              	.L463:
 404:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		    bytes_last_frag;
 405:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	else
 406:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		txb->payload_size = bytes;
 1578              	.loc 1 406 0
 1579 094d 8B542410 	movl 16(%esp),%edx
 1580 0951 8B44243C 	movl 60(%esp),%eax
 1581 0955 66895006 	movw %dx,6(%eax)
 1582              	.L464:
 407:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 
 408:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	if (rts_required) {
 1583              	.loc 1 408 0
 1584 0959 85F6     	testl %esi,%esi
 409:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		skb_frag = txb->fragments[0];
 410:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		frag_hdr =
 411:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		    (struct ieee80211_hdr_3addr *)skb_put(skb_frag, hdr_len);
 412:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 
 413:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		/*
 414:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		 * Set header frame_ctl to the RTS.
 415:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		 */
 416:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		header.frame_ctl =
 417:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		    cpu_to_le16(IEEE80211_FTYPE_CTL | IEEE80211_STYPE_RTS);
 418:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		memcpy(frag_hdr, &header, hdr_len);
 419:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 
 420:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		/*
 421:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		 * Restore header frame_ctl to the original data setting.
 422:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		 */
 423:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		header.frame_ctl = cpu_to_le16(fc);
 424:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 
 425:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		if (ieee->config &
 426:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		    (CFG_IEEE80211_COMPUTE_FCS | CFG_IEEE80211_RESERVE_FCS))
 427:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 			skb_put(skb_frag, 4);
 428:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 
 429:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		txb->rts_included = 1;
 430:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		i = 1;
 431:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	} else
 432:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		i = 0;
 1585              	.loc 1 432 0
 1586 095b C7442438 	movl $0,56(%esp)
 1586      00000000 
 1587              	.loc 1 408 0
 1588 0963 0F84A700 	je .L502
 1588      0000
 1589              	.loc 1 409 0
 1590 0969 8B7C243C 	movl 60(%esp),%edi
 1591 096d 8B5F08   	movl 8(%edi),%ebx
 1592              	.LBB141:
 1593              	.LBB142:
 1594              	.loc 6 702 0
 1595 0970 837B6400 	cmpl $0,100(%ebx)
 1596              	.loc 6 758 0
GAS LISTING  			page 107


 1597 0974 8BBBAC00 	movl 172(%ebx),%edi
 1597      0000
 1598              	.loc 6 702 0
 1599 097a 7402     	je .L466
 1600              	.loc 6 759 0
 1601              	
 1602 097c 0F0B     	ud2
 1603              	
 1604              	
 1605              	.L466:
 1606              	.loc 6 760 0
 1607 097e 8D4718   	leal 24(%edi),%eax
 1608              	.loc 6 761 0
 1609 0981 83436018 	addl $24,96(%ebx)
 1610              	.loc 6 762 0
 1611 0985 3B83B000 	cmpl 176(%ebx),%eax
 1611      0000
 1612              	.loc 6 760 0
 1613 098b 8983AC00 	movl %eax,172(%ebx)
 1613      0000
 1614              	.loc 6 762 0
 1615 0991 7611     	jbe .L469
 1616              	.LBB143:
 1617              	.loc 6 763 0
 1618              	
 1619 0993 B8980900 	movl $1f,%eax
 1619      00
 1620              	1:
 1621              	
 1622              	.LBE143:
 1623 0998 50       	pushl %eax
 1624              	.LCFI90:
 1625 0999 6A18     	pushl $24
 1626              	.LCFI91:
 1627 099b 53       	pushl %ebx
 1628              	.LCFI92:
 1629 099c E8FCFFFF 	call skb_over_panic
 1629      FF
 1630 09a1 83C40C   	addl $12,%esp
 1631              	.LCFI93:
 1632              	.L469:
 1633              	.LBE142:
 1634              	.LBE141:
 1635              	.loc 1 416 0
 1636 09a4 66C74424 	movw $180,100(%esp)
 1636      64B400
 1637 09ab 8D742464 	leal 100(%esp),%esi
 1638              	.LBB144:
 1639              	.LBB145:
 1640              	.LBB146:
 1641              	.loc 8 252 0
 1642 09af B9060000 	movl $6,%ecx
 1642      00
 1643              	
 1644 09b4 F3A5     	rep
 1645              	
 1646              	.LBE146:
GAS LISTING  			page 108


 1647              	.LBE145:
 1648              	.LBE144:
 1649              	.loc 1 423 0
 1650 09b6 8B44240C 	movl 12(%esp),%eax
 1651 09ba 66894424 	movw %ax,100(%esp)
 1651      64
 1652              	.loc 1 425 0
 1653 09bf 8B542440 	movl 64(%esp),%edx
 1654 09c3 F6825C06 	testb $3,1628(%edx)
 1654      000003
 1655 09ca 7434     	je .L496
 1656              	.LBB147:
 1657              	.LBB148:
 1658              	.loc 6 702 0
 1659 09cc 837B6400 	cmpl $0,100(%ebx)
 1660 09d0 7402     	je .L497
 1661              	.loc 6 759 0
 1662              	
 1663 09d2 0F0B     	ud2
 1664              	
 1665              	
 1666              	.L497:
 1667              	.loc 6 760 0
 1668 09d4 8B83AC00 	movl 172(%ebx),%eax
 1668      0000
 1669 09da 83C004   	addl $4,%eax
 1670              	.loc 6 761 0
 1671 09dd 83436004 	addl $4,96(%ebx)
 1672              	.loc 6 762 0
 1673 09e1 3B83B000 	cmpl 176(%ebx),%eax
 1673      0000
 1674              	.loc 6 760 0
 1675 09e7 8983AC00 	movl %eax,172(%ebx)
 1675      0000
 1676              	.loc 6 762 0
 1677 09ed 7611     	jbe .L496
 1678              	.LBB149:
 1679              	.loc 6 763 0
 1680              	
 1681 09ef B8F40900 	movl $1f,%eax
 1681      00
 1682              	1:
 1683              	
 1684              	.LBE149:
 1685 09f4 50       	pushl %eax
 1686              	.LCFI94:
 1687 09f5 6A04     	pushl $4
 1688              	.LCFI95:
 1689 09f7 53       	pushl %ebx
 1690              	.LCFI96:
 1691 09f8 E8FCFFFF 	call skb_over_panic
 1691      FF
 1692 09fd 83C40C   	addl $12,%esp
 1693              	.LCFI97:
 1694              	.L496:
 1695              	.LBE148:
 1696              	.LBE147:
GAS LISTING  			page 109


 1697              	.loc 1 429 0
 1698 0a00 8B5C243C 	movl 60(%esp),%ebx
 1699 0a04 C6430201 	movb $1,2(%ebx)
 1700              	.loc 1 430 0
 1701 0a08 C7442438 	movl $1,56(%esp)
 1701      01000000 
 1702              	.L502:
 433:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 
 434:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	for (; i < nr_frags; i++) {
 1703              	.loc 1 434 0
 1704 0a10 8B7C2430 	movl 48(%esp),%edi
 1705 0a14 397C2438 	cmpl %edi,56(%esp)
 1706              	.L638:
 1707 0a18 0F8D2602 	jge .L602
 1707      0000
 435:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		skb_frag = txb->fragments[i];
 1708              	.loc 1 435 0
 1709 0a1e 8B442438 	movl 56(%esp),%eax
 1710 0a22 8B54243C 	movl 60(%esp),%edx
 436:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 
 437:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		if (host_encrypt || host_build_iv)
 1711              	.loc 1 437 0
 1712 0a26 837C2418 	cmpl $0,24(%esp)
 1712      00
 1713              	.loc 1 435 0
 1714 0a2b 8B5C8208 	movl 8(%edx,%eax,4),%ebx
 1715              	.loc 1 437 0
 1716 0a2f 7507     	jne .L507
 1717 0a31 837C2414 	cmpl $0,20(%esp)
 1717      00
 1718 0a36 7416     	je .L506
 1719              	.L507:
 1720              	.LBB150:
 1721              	.loc 6 870 0
 1722 0a38 8B7C2408 	movl 8(%esp),%edi
 1723 0a3c 8B4708   	movl 8(%edi),%eax
 1724 0a3f 8B403C   	movl 60(%eax),%eax
 1725              	.LBB151:
 1726              	.loc 6 871 0
 1727 0a42 0183A800 	addl %eax,168(%ebx)
 1727      0000
 1728              	.loc 6 872 0
 1729 0a48 0183AC00 	addl %eax,172(%ebx)
 1729      0000
 1730              	.L506:
 1731              	.LBE151:
 1732              	.LBE150:
 1733              	.LBB152:
 1734              	.LBB153:
 1735              	.loc 6 702 0
 1736 0a4e 837B6400 	cmpl $0,100(%ebx)
 1737              	.loc 6 758 0
 1738 0a52 8BABAC00 	movl 172(%ebx),%ebp
 1738      0000
 1739              	.loc 6 702 0
 1740 0a58 7402     	je .L509
 1741              	.loc 6 759 0
GAS LISTING  			page 110


 1742              	
 1743 0a5a 0F0B     	ud2
 1744              	
 1745              	
 1746              	.L509:
 1747              	.loc 6 760 0
 1748 0a5c 8D4518   	leal 24(%ebp),%eax
 1749              	.loc 6 761 0
 1750 0a5f 83436018 	addl $24,96(%ebx)
 1751              	.loc 6 762 0
 1752 0a63 3B83B000 	cmpl 176(%ebx),%eax
 1752      0000
 1753              	.loc 6 760 0
 1754 0a69 8983AC00 	movl %eax,172(%ebx)
 1754      0000
 1755              	.loc 6 762 0
 1756 0a6f 7611     	jbe .L512
 1757              	.LBB154:
 1758              	.loc 6 763 0
 1759              	
 1760 0a71 B8760A00 	movl $1f,%eax
 1760      00
 1761              	1:
 1762              	
 1763              	.LBE154:
 1764 0a76 50       	pushl %eax
 1765              	.LCFI98:
 1766 0a77 6A18     	pushl $24
 1767              	.LCFI99:
 1768 0a79 53       	pushl %ebx
 1769              	.LCFI100:
 1770 0a7a E8FCFFFF 	call skb_over_panic
 1770      FF
 1771 0a7f 83C40C   	addl $12,%esp
 1772              	.LCFI101:
 1773              	.L512:
 1774 0a82 8D742464 	leal 100(%esp),%esi
 1775              	.LBE153:
 1776              	.LBE152:
 1777              	.LBB155:
 1778              	.LBB156:
 1779              	.LBB157:
 1780              	.loc 8 252 0
 1781 0a86 B9060000 	movl $6,%ecx
 1781      00
 1782 0a8b 89EF     	movl %ebp,%edi
 1783              	
 1784 0a8d F3A5     	rep
 1785              	
 1786              	.LBE157:
 1787              	.LBE156:
 1788              	.LBE155:
 438:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 			skb_reserve(skb_frag,
 439:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 				    crypt->ops->extra_mpdu_prefix_len);
 440:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 
 441:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		frag_hdr =
 442:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		    (struct ieee80211_hdr_3addr *)skb_put(skb_frag, hdr_len);
GAS LISTING  			page 111


 443:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		memcpy(frag_hdr, &header, hdr_len);
 444:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 
 445:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		/* If this is not the last fragment, then add the MOREFRAGS
 446:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		 * bit to the frame control */
 447:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		if (i != nr_frags - 1) {
 1789              	.loc 1 447 0
 1790 0a8f 8B442430 	movl 48(%esp),%eax
 1791 0a93 48       	decl %eax
 448:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 			frag_hdr->frame_ctl =
 449:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 			    cpu_to_le16(fc | IEEE80211_FCTL_MOREFRAGS);
 450:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 			bytes = bytes_per_frag;
 451:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		} else {
 452:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 			/* The last fragment takes the remaining length */
 453:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 			bytes = bytes_last_frag;
 1792              	.loc 1 453 0
 1793 0a94 8B54242C 	movl 44(%esp),%edx
 1794              	.loc 1 447 0
 1795 0a98 39442438 	cmpl %eax,56(%esp)
 1796              	.loc 1 453 0
 1797 0a9c 89542410 	movl %edx,16(%esp)
 1798              	.loc 1 447 0
 1799 0aa0 7413     	je .L540
 1800              	.loc 1 448 0
 1801 0aa2 8B44240C 	movl 12(%esp),%eax
 1802 0aa6 80CC04   	orb $4,%ah
 1803 0aa9 66894500 	movw %ax,(%ebp)
 1804              	.loc 1 450 0
 1805 0aad 8B7C2434 	movl 52(%esp),%edi
 1806 0ab1 897C2410 	movl %edi,16(%esp)
 1807              	.L540:
 454:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		}
 455:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 
 456:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		if (i == 0 && !snapped) {
 1808              	.loc 1 456 0
 1809 0ab5 837C2438 	cmpl $0,56(%esp)
 1809      00
 1810 0aba 754B     	jne .L541
 1811 0abc 833C2400 	cmpl $0,(%esp)
 1812 0ac0 7545     	jne .L541
 1813              	.LBB158:
 1814              	.LBB159:
 1815              	.loc 6 702 0
 1816 0ac2 837B6400 	cmpl $0,100(%ebx)
 1817              	.loc 6 758 0
 1818 0ac6 8BB3AC00 	movl 172(%ebx),%esi
 1818      0000
 1819              	.loc 6 702 0
 1820 0acc 7402     	je .L542
 1821              	.loc 6 759 0
 1822              	
 1823 0ace 0F0B     	ud2
 1824              	
 1825              	
 1826              	.L542:
 1827              	.loc 6 760 0
 1828 0ad0 8D4608   	leal 8(%esi),%eax
 1829              	.loc 6 761 0
GAS LISTING  			page 112


 1830 0ad3 83436008 	addl $8,96(%ebx)
 1831              	.loc 6 762 0
 1832 0ad7 3B83B000 	cmpl 176(%ebx),%eax
 1832      0000
 1833              	.loc 6 760 0
 1834 0add 8983AC00 	movl %eax,172(%ebx)
 1834      0000
 1835              	.loc 6 762 0
 1836 0ae3 7611     	jbe .L545
 1837              	.LBB160:
 1838              	.loc 6 763 0
 1839              	
 1840 0ae5 B8EA0A00 	movl $1f,%eax
 1840      00
 1841              	1:
 1842              	
 1843              	.LBE160:
 1844 0aea 50       	pushl %eax
 1845              	.LCFI102:
 1846 0aeb 6A08     	pushl $8
 1847              	.LCFI103:
 1848 0aed 53       	pushl %ebx
 1849              	.LCFI104:
 1850 0aee E8FCFFFF 	call skb_over_panic
 1850      FF
 1851 0af3 83C40C   	addl $12,%esp
 1852              	.LCFI105:
 1853              	.L545:
 1854              	.LBE159:
 1855              	.LBE158:
 1856              	.loc 6 757 0
 1857 0af6 FF742420 	pushl 32(%esp)
 1858              	.LCFI106:
 1859 0afa 56       	pushl %esi
 1860              	.LCFI107:
 1861 0afb E800F5FF 	call ieee80211_copy_snap
 1861      FF
 457:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 			ieee80211_copy_snap(skb_put
 458:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 					    (skb_frag, SNAP_SIZE + sizeof(u16)),
 459:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 					    ether_type);
 460:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 			bytes -= SNAP_SIZE + sizeof(u16);
 1862              	.loc 1 460 0
 1863 0b00 836C2418 	subl $8,24(%esp)
 1863      08
 1864 0b05 58       	popl %eax
 1865              	.LCFI108:
 1866 0b06 5A       	popl %edx
 1867              	.LCFI109:
 1868              	.L541:
 1869              	.LBB161:
 1870              	.LBB162:
 1871              	.LBB163:
 1872              	.loc 6 702 0
 1873 0b07 837B6400 	cmpl $0,100(%ebx)
 1874 0b0b 8BBBAC00 	movl 172(%ebx),%edi
 1874      0000
 1875 0b11 7402     	je .L576
GAS LISTING  			page 113


 1876              	.loc 6 759 0
 1877              	
 1878 0b13 0F0B     	ud2
 1879              	
 1880              	
 1881              	.L576:
 1882              	.loc 6 760 0
 1883 0b15 8B542410 	movl 16(%esp),%edx
 1884 0b19 8D0417   	leal (%edi,%edx),%eax
 1885              	.loc 6 761 0
 1886 0b1c 015360   	addl %edx,96(%ebx)
 1887              	.loc 6 762 0
 1888 0b1f 3B83B000 	cmpl 176(%ebx),%eax
 1888      0000
 1889              	.loc 6 760 0
 1890 0b25 8983AC00 	movl %eax,172(%ebx)
 1890      0000
 1891              	.loc 6 762 0
 1892 0b2b 7610     	jbe .L579
 1893              	.LBB164:
 1894              	.loc 6 763 0
 1895              	
 1896 0b2d B8320B00 	movl $1f,%eax
 1896      00
 1897              	1:
 1898              	
 1899              	.LBE164:
 1900 0b32 50       	pushl %eax
 1901              	.LCFI110:
 1902 0b33 52       	pushl %edx
 1903              	.LCFI111:
 1904 0b34 53       	pushl %ebx
 1905              	.LCFI112:
 1906 0b35 E8FCFFFF 	call skb_over_panic
 1906      FF
 1907 0b3a 83C40C   	addl $12,%esp
 1908              	.LCFI113:
 1909              	.L579:
 1910              	.LBE163:
 1911              	.LBE162:
 1912              	.loc 8 205 0
 1913 0b3d 8B842498 	movl 152(%esp),%eax
 1913      000000
 1914              	.LBB165:
 1915              	.loc 8 207 0
 1916 0b44 8B4C2410 	movl 16(%esp),%ecx
 1917              	.LBE165:
 1918              	.loc 8 205 0
 1919 0b48 8BB0A800 	movl 168(%eax),%esi
 1919      0000
 1920              	.LBB166:
 1921              	.loc 8 207 0
 1922 0b4e C1E902   	shrl $2,%ecx
 1923              	
 1924 0b51 F3A5     	rep
 1925 0b53 8B4C2410 	movl 16(%esp),%ecx
 1926 0b57 83E103   	andl $3,%ecx
GAS LISTING  			page 114


 1927 0b5a 7402     	jz 1f
 1928 0b5c F3A4     	rep
 1929              	1:
 1930              	
 1931              	.LBE166:
 1932              	.LBE161:
 1933              	.LBB167:
 1934              	.LBB168:
 1935              	.loc 6 811 0
 1936 0b5e 8B942498 	movl 152(%esp),%edx
 1936      000000
 1937 0b65 8B4260   	movl 96(%edx),%eax
 1938 0b68 39442410 	cmpl %eax,16(%esp)
 1939 0b6c 771F     	ja .L587
 1940              	.LBB169:
 1941              	.LBB170:
 1942              	.loc 6 794 0
 1943 0b6e 2B442410 	subl 16(%esp),%eax
 1944              	.loc 6 795 0
 1945 0b72 3B4264   	cmpl 100(%edx),%eax
 1946              	.loc 6 794 0
 1947 0b75 894260   	movl %eax,96(%edx)
 1948              	.loc 6 795 0
 1949 0b78 7302     	jae .L584
 1950              	
 1951 0b7a 0F0B     	ud2
 1952              	
 1953              	
 1954              	.L584:
 1955 0b7c 8B442410 	movl 16(%esp),%eax
 1956 0b80 8BBC2498 	movl 152(%esp),%edi
 1956      000000
 1957 0b87 0187A800 	addl %eax,168(%edi)
 1957      0000
 1958              	.L587:
 1959              	.LBE170:
 1960              	.LBE169:
 1961              	.LBE168:
 1962              	.LBE167:
 461:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		}
 462:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 
 463:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		memcpy(skb_put(skb_frag, bytes), skb->data, bytes);
 464:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 
 465:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		/* Advance the SKB... */
 466:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		skb_pull(skb, bytes);
 467:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 
 468:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		/* Encryption routine will move the header forward in order
 469:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		 * to insert the IV between the header and the payload */
 470:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		if (host_encrypt)
 1963              	.loc 1 470 0
 1964 0b8d 837C2418 	cmpl $0,24(%esp)
 1964      00
 1965 0b92 7411     	je .L588
 471:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 			ieee80211_encrypt_fragment(ieee, skb_frag, hdr_len);
 1966              	.loc 1 471 0
 1967 0b94 6A18     	pushl $24
 1968              	.LCFI114:
GAS LISTING  			page 115


 1969 0b96 53       	pushl %ebx
 1970              	.LCFI115:
 1971 0b97 FF742448 	pushl 72(%esp)
 1972              	.LCFI116:
 1973 0b9b E8B5F4FF 	call ieee80211_encrypt_fragment
 1973      FF
 1974 0ba0 83C40C   	addl $12,%esp
 1975              	.LCFI117:
 1976 0ba3 EB4D     	jmp .L589
 1977              	.L588:
 472:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		else if (host_build_iv) {
 1978              	.loc 1 472 0
 1979 0ba5 837C2414 	cmpl $0,20(%esp)
 1979      00
 1980 0baa 7446     	je .L589
 1981              	.LBB171:
 473:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 			struct ieee80211_crypt_data *crypt;
 474:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 
 475:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 			crypt = ieee->crypt[ieee->tx_keyidx];
 1982              	.loc 1 475 0
 1983 0bac 8B542440 	movl 64(%esp),%edx
 1984 0bb0 8B82B006 	movl 1712(%edx),%eax
 1984      0000
 1985 0bb6 8BB482A0 	movl 1696(%edx,%eax,4),%esi
 1985      060000
 1986              	.LBB172:
 1987              	.LBB173:
 1988              	.loc 3 103 0
 1989              	
 1990 0bbd FF4610   	incl 16(%esi)
 1991              	
 1992              	.LBE173:
 1993              	.LBE172:
 476:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 			atomic_inc(&crypt->refcnt);
 477:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 			if (crypt->ops->build_iv)
 1994              	.loc 1 477 0
 1995 0bc0 8B4E08   	movl 8(%esi),%ecx
 1996 0bc3 83791400 	cmpl $0,20(%ecx)
 1997 0bc7 7426     	je .L592
 478:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 				crypt->ops->build_iv(skb_frag, hdr_len,
 1998              	.loc 1 478 0
 1999 0bc9 FF760C   	pushl 12(%esi)
 2000              	.LCFI118:
 2001 0bcc 660FB642 	movzbw 4(%edx),%ax
 2001      04
 2002 0bd1 8B7C2444 	movl 68(%esp),%edi
 2003 0bd5 83E003   	andl $3,%eax
 2004 0bd8 0FB65407 	movzbl 10(%edi,%eax),%edx
 2004      0A
 2005 0bdd C1E005   	sall $5,%eax
 2006 0be0 52       	pushl %edx
 2007              	.LCFI119:
 2008 0be1 8D44070E 	leal 14(%edi,%eax),%eax
 2009 0be5 50       	pushl %eax
 2010              	.LCFI120:
 2011 0be6 6A18     	pushl $24
 2012              	.LCFI121:
GAS LISTING  			page 116


 2013 0be8 53       	pushl %ebx
 2014              	.LCFI122:
 2015 0be9 FF5114   	call *20(%ecx)
 2016 0bec 83C414   	addl $20,%esp
 2017              	.LCFI123:
 2018              	.L592:
 2019              	.LBB174:
 2020              	.LBB175:
 2021              	.loc 3 117 0
 2022              	
 2023 0bef FF4E10   	decl 16(%esi)
 2024              	
 2025              	.L589:
 2026              	.LBE175:
 2027              	.LBE174:
 2028              	.LBE171:
 479:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 				      ieee->sec.keys[ieee->sec.active_key],
 480:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 				      ieee->sec.key_sizes[ieee->sec.active_key],
 481:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 				      crypt->priv);
 482:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 			atomic_dec(&crypt->refcnt);
 483:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		}
 484:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 
 485:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		if (ieee->config &
 2029              	.loc 1 485 0
 2030 0bf2 8B442440 	movl 64(%esp),%eax
 2031 0bf6 F6805C06 	testb $3,1628(%eax)
 2031      000003
 2032 0bfd 7434     	je .L505
 2033              	.LBB176:
 2034              	.LBB177:
 2035              	.loc 6 702 0
 2036 0bff 837B6400 	cmpl $0,100(%ebx)
 2037 0c03 7402     	je .L595
 2038              	.loc 6 759 0
 2039              	
 2040 0c05 0F0B     	ud2
 2041              	
 2042              	
 2043              	.L595:
 2044              	.loc 6 760 0
 2045 0c07 8B83AC00 	movl 172(%ebx),%eax
 2045      0000
 2046 0c0d 83C004   	addl $4,%eax
 2047              	.loc 6 761 0
 2048 0c10 83436004 	addl $4,96(%ebx)
 2049              	.loc 6 762 0
 2050 0c14 3B83B000 	cmpl 176(%ebx),%eax
 2050      0000
 2051              	.loc 6 760 0
 2052 0c1a 8983AC00 	movl %eax,172(%ebx)
 2052      0000
 2053              	.loc 6 762 0
 2054 0c20 7611     	jbe .L505
 2055              	.LBB178:
 2056              	.loc 6 763 0
 2057              	
 2058 0c22 B8270C00 	movl $1f,%eax
GAS LISTING  			page 117


 2058      00
 2059              	1:
 2060              	
 2061              	.LBE178:
 2062 0c27 50       	pushl %eax
 2063              	.LCFI124:
 2064 0c28 6A04     	pushl $4
 2065              	.LCFI125:
 2066 0c2a 53       	pushl %ebx
 2067              	.LCFI126:
 2068 0c2b E8FCFFFF 	call skb_over_panic
 2068      FF
 2069 0c30 83C40C   	addl $12,%esp
 2070              	.LCFI127:
 2071              	.L505:
 2072              	.LBE177:
 2073              	.LBE176:
 2074              	.loc 1 434 0
 2075 0c33 FF442438 	incl 56(%esp)
 2076 0c37 8B542430 	movl 48(%esp),%edx
 2077 0c3b 39542438 	cmpl %edx,56(%esp)
 2078 0c3f E9D4FDFF 	jmp .L638
 2078      FF
 2079              	.L128:
 2080              	.L602:
 486:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		    (CFG_IEEE80211_COMPUTE_FCS | CFG_IEEE80211_RESERVE_FCS))
 487:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 			skb_put(skb_frag, 4);
 488:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	}
 489:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 
 490:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c ****       success:
 491:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	spin_unlock_irqrestore(&ieee->lock, flags);
 2081              	.loc 1 491 0
 2082              	
 2083 0c44 FF742428 	pushl 40(%esp)
 2083      9D
 2084              	
 2085              	.LBB179:
 2086              	.LBB180:
 2087              	.LBB181:
 2088              	.LBB182:
 2089              	.loc 4 91 0
 2090 0c49 B800E0FF 	movl $-8192,%eax
 2090      FF
 2091              	
 2092 0c4e 21E0     	andl %esp,%eax
 2093              	
 2094              	.LBE182:
 2095              	.LBE181:
 2096              	.loc 4 89 0
 2097 0c50 F7401400 	testl $268369920,20(%eax)
 2097      00FF0F
 2098 0c57 7507     	jne .L606
 2099              	.LBB183:
 2100              	.loc 5 659 0
 2101              	
 2102 0c59 9C58     	pushfl
 2103              	
GAS LISTING  			page 118


 2104              	.LBE183:
 2105 0c5b F6C402   	testb $2,%ah
 2106 0c5e 7539     	jne .L605
 2107              	.L606:
 2108              	.LBB184:
 2109              	.LBB185:
 2110              	.LBB186:
 2111              	.LBB187:
 2112              	.loc 3 135 0
 2113 0c60 8B9C2498 	movl 152(%esp),%ebx
 2113      000000
 2114              	
 2115 0c67 FF8BA000 	decl 160(%ebx)
 2115      00000F94 
 2115      C0
 2116              	
 2117              	.LBE187:
 2118              	.LBE186:
 2119              	.loc 3 132 0
 2120 0c70 84C0     	testb %al,%al
 2121 0c72 7458     	je .L619
 2122              	.LBB188:
 2123              	.loc 5 645 0
 2124              	
 2125 0c74 9C5BFA   	pushfl
 2126              	.loc 5 647 0
 2127              	
 2128 0c77 A1240000 	movl per_cpu__softnet_data+36,%eax
 2128      00
 2129 0c7c 8BBC2498 	movl 152(%esp),%edi
 2129      000000
 2130 0c83 8907     	movl %eax,(%edi)
 2131              	.loc 5 649 0
 2132 0c85 B8020000 	movl $2,%eax
 2132      00
 2133              	.loc 5 648 0
 2134 0c8a 893D2400 	movl %edi,per_cpu__softnet_data+36
 2134      0000
 2135              	.loc 5 649 0
 2136 0c90 E8FCFFFF 	call raise_softirq_irqoff
 2136      FF
 2137              	.loc 5 650 0
 2138              	
 2139 0c95 539D     	pushl %ebx
 2140              	
 2141              	.LBE188:
 2142              	.LBE185:
 2143              	.LBE184:
 2144 0c97 EB33     	jmp .L619
 2145              	.L605:
 2146              	.LBB189:
 2147              	.LBB190:
 2148              	.loc 6 369 0
 2149 0c99 8B942498 	movl 152(%esp),%edx
 2149      000000
 2150 0ca0 8B82A000 	movl 160(%edx),%eax
 2150      0000
GAS LISTING  			page 119


 2151 0ca6 48       	decl %eax
 2152 0ca7 7502     	jne .L614
 2153              	.loc 6 370 0
 2154 0ca9 EB14     	jmp .L615
 2155              	.L614:
 2156              	.LBB191:
 2157              	.LBB192:
 2158              	.loc 3 135 0
 2159 0cab 8B9C2498 	movl 152(%esp),%ebx
 2159      000000
 2160              	
 2161 0cb2 FF8BA000 	decl 160(%ebx)
 2161      00000F94 
 2161      C0
 2162              	
 2163              	.LBE192:
 2164              	.LBE191:
 2165              	.loc 3 132 0
 2166 0cbb 84C0     	testb %al,%al
 2167 0cbd 740D     	je .L619
 2168              	.L615:
 2169              	.loc 6 373 0
 2170 0cbf FFB42498 	pushl 152(%esp)
 2170      000000
 2171              	.LCFI128:
 2172 0cc6 E8FCFFFF 	call __kfree_skb
 2172      FF
 2173 0ccb 5D       	popl %ebp
 2174              	.LCFI129:
 2175              	.L619:
 2176              	.LBE190:
 2177              	.LBE189:
 2178              	.LBE180:
 2179              	.LBE179:
 492:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 
 493:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	dev_kfree_skb_any(skb);
 494:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 
 495:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	if (txb) {
 2180              	.loc 1 495 0
 2181 0ccc 837C243C 	cmpl $0,60(%esp)
 2181      00
 2182 0cd1 7442     	je .L620
 2183              	.LBB193:
 496:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		int ret = (*ieee->hard_start_xmit) (txb, dev, priority);
 2184              	.loc 1 496 0
 2185 0cd3 FF742404 	pushl 4(%esp)
 2186              	.LCFI130:
 2187 0cd7 FFB424A0 	pushl 160(%esp)
 2187      000000
 2188              	.LCFI131:
 2189 0cde FF742444 	pushl 68(%esp)
 2190              	.LCFI132:
 2191 0ce2 8B7C244C 	movl 76(%esp),%edi
 2192 0ce6 FF977807 	call *1912(%edi)
 2192      0000
 497:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		if (ret == 0) {
 2193              	.loc 1 497 0
GAS LISTING  			page 120


 2194 0cec 83C40C   	addl $12,%esp
 2195              	.LCFI133:
 2196 0cef 85C0     	testl %eax,%eax
 2197 0cf1 7518     	jne .L621
 498:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 			stats->tx_packets++;
 2198              	.loc 1 498 0
 2199 0cf3 8B442424 	movl 36(%esp),%eax
 2200 0cf7 FF4004   	incl 4(%eax)
 499:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 			stats->tx_bytes += txb->payload_size;
 2201              	.loc 1 499 0
 2202 0cfa 8B54243C 	movl 60(%esp),%edx
 2203 0cfe 0FB74206 	movzwl 6(%edx),%eax
 2204 0d02 8B5C2424 	movl 36(%esp),%ebx
 2205 0d06 01430C   	addl %eax,12(%ebx)
 2206 0d09 EB0A     	jmp .L620
 2207              	.L621:
 500:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 			return 0;
 501:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		}
 502:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 
 503:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		ieee80211_txb_free(txb);
 2208              	.loc 1 503 0
 2209 0d0b FF74243C 	pushl 60(%esp)
 2210              	.LCFI134:
 2211 0d0f E8FCFFFF 	call ieee80211_txb_free
 2211      FF
 2212              	.LBE193:
 2213 0d14 5F       	popl %edi
 2214              	.LCFI135:
 2215              	.L620:
 504:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	}
 505:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 
 506:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	return 0;
 2216              	.loc 1 506 0
 2217 0d15 31D2     	xorl %edx,%edx
 2218 0d17 EB1D     	jmp .L121
 2219              	.L334:
 2220              	.L623:
 507:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 
 508:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c ****       failed:
 509:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	spin_unlock_irqrestore(&ieee->lock, flags);
 2221              	.loc 1 509 0
 2222              	
 2223 0d19 FF742428 	pushl 40(%esp)
 2223      9D
 2224              	
 2225              	.LBB194:
 2226              	.LBB195:
 2227              	.LBB196:
 2228              	.LBB197:
 2229              	.file 11 "include/asm/bitops.h"
   1:include/asm/bitops.h **** #ifndef _I386_BITOPS_H
   2:include/asm/bitops.h **** #define _I386_BITOPS_H
   3:include/asm/bitops.h **** 
   4:include/asm/bitops.h **** /*
   5:include/asm/bitops.h ****  * Copyright 1992, Linus Torvalds.
   6:include/asm/bitops.h ****  */
   7:include/asm/bitops.h **** 
GAS LISTING  			page 121


   8:include/asm/bitops.h **** #include <linux/config.h>
   9:include/asm/bitops.h **** #include <linux/compiler.h>
  10:include/asm/bitops.h **** 
  11:include/asm/bitops.h **** /*
  12:include/asm/bitops.h ****  * These have to be done with inline assembly: that way the bit-setting
  13:include/asm/bitops.h ****  * is guaranteed to be atomic. All bit operations return 0 if the bit
  14:include/asm/bitops.h ****  * was cleared before the operation and != 0 if it was not.
  15:include/asm/bitops.h ****  *
  16:include/asm/bitops.h ****  * bit 0 is the LSB of addr; bit 32 is the LSB of (addr+1).
  17:include/asm/bitops.h ****  */
  18:include/asm/bitops.h **** 
  19:include/asm/bitops.h **** #ifdef CONFIG_SMP
  20:include/asm/bitops.h **** #define LOCK_PREFIX "lock ; "
  21:include/asm/bitops.h **** #else
  22:include/asm/bitops.h **** #define LOCK_PREFIX ""
  23:include/asm/bitops.h **** #endif
  24:include/asm/bitops.h **** 
  25:include/asm/bitops.h **** #define ADDR (*(volatile long *) addr)
  26:include/asm/bitops.h **** 
  27:include/asm/bitops.h **** /**
  28:include/asm/bitops.h ****  * set_bit - Atomically set a bit in memory
  29:include/asm/bitops.h ****  * @nr: the bit to set
  30:include/asm/bitops.h ****  * @addr: the address to start counting from
  31:include/asm/bitops.h ****  *
  32:include/asm/bitops.h ****  * This function is atomic and may not be reordered.  See __set_bit()
  33:include/asm/bitops.h ****  * if you do not require the atomic guarantees.
  34:include/asm/bitops.h ****  *
  35:include/asm/bitops.h ****  * Note: there are no guarantees that this function will not be reordered
  36:include/asm/bitops.h ****  * on non x86 architectures, so if you are writting portable code,
  37:include/asm/bitops.h ****  * make sure not to rely on its reordering guarantees.
  38:include/asm/bitops.h ****  *
  39:include/asm/bitops.h ****  * Note that @nr may be almost arbitrarily large; this function is not
  40:include/asm/bitops.h ****  * restricted to acting on a single-word quantity.
  41:include/asm/bitops.h ****  */
  42:include/asm/bitops.h **** static inline void set_bit(int nr, volatile unsigned long * addr)
  43:include/asm/bitops.h **** {
  44:include/asm/bitops.h **** 	__asm__ __volatile__( LOCK_PREFIX
 2230              	.loc 11 44 0
 2231 0d1e 8BBC249C 	movl 156(%esp),%edi
 2231      000000
 2232              	
 2233 0d25 0FBA6F24 	btsl $0,36(%edi)
 2233      00
 2234              	
 2235              	.LBE197:
 2236              	.LBE196:
 2237              	.LBE195:
 2238              	.LBE194:
 510:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	netif_stop_queue(dev);
 511:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	stats->tx_errors++;
 2239              	.loc 1 511 0
 2240 0d2a 8B442424 	movl 36(%esp),%eax
 2241 0d2e FF4014   	incl 20(%eax)
 512:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	return 1;
 2242              	.loc 1 512 0
 2243 0d31 BA010000 	movl $1,%edx
 2243      00
GAS LISTING  			page 122


 2244              	.L121:
 513:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** }
 2245              	.loc 1 513 0
 2246 0d36 81C48400 	addl $132,%esp
 2246      0000
 2247 0d3c 5B       	popl %ebx
 2248 0d3d 5E       	popl %esi
 2249 0d3e 5F       	popl %edi
 2250 0d3f 89D0     	movl %edx,%eax
 2251 0d41 5D       	popl %ebp
 2252 0d42 C3       	ret
 2253              	.LFE926:
 2255              	.globl ieee80211_tx_frame
 2257              	ieee80211_tx_frame:
 2258              	.LFB927:
 514:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 
 515:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** /* Incoming 802.11 strucure is converted to a TXB
 516:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c ****  * a block of 802.11 fragment packets (stored as skbs) */
 517:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** int ieee80211_tx_frame(struct ieee80211_device *ieee,
 518:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		       struct ieee80211_hdr *frame, int len)
 519:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** {
 2259              	.loc 1 519 0
 2260 0d43 55       	pushl %ebp
 2261              	.LCFI136:
 2262 0d44 57       	pushl %edi
 2263              	.LCFI137:
 2264 0d45 56       	pushl %esi
 2265              	.LCFI138:
 2266 0d46 53       	pushl %ebx
 2267              	.LCFI139:
 2268 0d47 83EC0C   	subl $12,%esp
 2269              	.LCFI140:
 520:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	struct ieee80211_txb *txb = NULL;
 521:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	unsigned long flags;
 522:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	struct net_device_stats *stats = &ieee->stats;
 2270              	.loc 1 522 0
 2271 0d4a 8B442420 	movl 32(%esp),%eax
 2272 0d4e 05940000 	addl $148,%eax
 2272      00
 2273              	.loc 1 520 0
 2274 0d53 31ED     	xorl %ebp,%ebp
 2275              	.loc 1 522 0
 2276 0d55 89442404 	movl %eax,4(%esp)
 523:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	struct sk_buff *skb_frag;
 524:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	int priority = -1;
 525:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 
 526:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	spin_lock_irqsave(&ieee->lock, flags);
 2277              	.loc 1 526 0
 2278              	
 2279 0d59 9C8F4424 	pushfl
 2279      08FA
 527:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 
 528:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	/* If there is no driver handler to take the TXB, dont' bother
 529:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	 * creating it... */
 530:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	if (!ieee->hard_start_xmit) {
 2280              	.loc 1 530 0
 2281              	
GAS LISTING  			page 123


 2282 0d5f 8B542420 	movl 32(%esp),%edx
 2283 0d63 83BA7807 	cmpl $0,1912(%edx)
 2283      000000
 2284 0d6a 7513     	jne .L643
 531:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		printk(KERN_WARNING "%s: No xmit handler.\n", ieee->dev->name);
 2285              	.loc 1 531 0
 2286 0d6c FF32     	pushl (%edx)
 2287              	.LCFI141:
 2288 0d6e 68230000 	pushl $.LC1
 2288      00
 2289              	.LCFI142:
 2290 0d73 E8FCFFFF 	call printk
 2290      FF
 532:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		goto success;
 2291              	.loc 1 532 0
 2292 0d78 5F       	popl %edi
 2293              	.LCFI143:
 2294 0d79 58       	popl %eax
 2295              	.LCFI144:
 2296 0d7a E9E20000 	jmp .L690
 2296      00
 2297              	.L643:
 533:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	}
 534:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 
 535:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	if (unlikely(len < 24)) {
 2298              	.loc 1 535 0
 2299 0d7f 837C2428 	cmpl $23,40(%esp)
 2299      17
 2300 0d84 7F19     	jg .L645
 536:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		printk(KERN_WARNING "%s: skb too small (%d).\n",
 2301              	.loc 1 536 0
 2302 0d86 FF742428 	pushl 40(%esp)
 2303              	.LCFI145:
 2304 0d8a 8B742424 	movl 36(%esp),%esi
 2305 0d8e FF36     	pushl (%esi)
 2306              	.LCFI146:
 2307 0d90 683C0000 	pushl $.LC2
 2307      00
 2308              	.LCFI147:
 2309 0d95 E8FCFFFF 	call printk
 2309      FF
 2310 0d9a E9BF0000 	jmp .L700
 2310      00
 2311              	.LCFI148:
 2312              	.L645:
 537:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		       ieee->dev->name, len);
 538:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		goto success;
 539:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	}
 540:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 
 541:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	/* When we allocate the TXB we allocate enough space for the reserve
 542:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	 * and full fragment bytes (bytes_per_frag doesn't include prefix,
 543:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	 * postfix, header, FCS, etc.) */
 544:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	txb = ieee80211_alloc_txb(1, len, ieee->tx_headroom, GFP_ATOMIC);
 2313              	.loc 1 544 0
 2314 0d9f 6A20     	pushl $32
 2315              	.LCFI149:
 2316 0da1 8B442424 	movl 36(%esp),%eax
GAS LISTING  			page 124


 2317 0da5 FFB05806 	pushl 1624(%eax)
 2317      0000
 2318              	.LCFI150:
 2319 0dab FF742430 	pushl 48(%esp)
 2320              	.LCFI151:
 2321 0daf 6A01     	pushl $1
 2322              	.LCFI152:
 2323 0db1 E89FF3FF 	call ieee80211_alloc_txb
 2323      FF
 545:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	if (unlikely(!txb)) {
 2324              	.loc 1 545 0
 2325 0db6 83C410   	addl $16,%esp
 2326              	.LCFI153:
 2327 0db9 85C0     	testl %eax,%eax
 2328              	.loc 1 544 0
 2329 0dbb 89C5     	movl %eax,%ebp
 2330              	.loc 1 545 0
 2331 0dbd 0F84D800 	je .L699
 2331      0000
 546:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		printk(KERN_WARNING "%s: Could not allocate TXB\n",
 547:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		       ieee->dev->name);
 548:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		goto failed;
 549:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	}
 550:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	txb->encrypted = 0;
 2332              	.loc 1 550 0
 2333 0dc3 C6400100 	movb $0,1(%eax)
 551:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	txb->payload_size = len;
 2334              	.loc 1 551 0
 2335 0dc7 8B542428 	movl 40(%esp),%edx
 2336 0dcb 66895006 	movw %dx,6(%eax)
 552:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 
 553:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	skb_frag = txb->fragments[0];
 2337              	.loc 1 553 0
 2338 0dcf 8B5808   	movl 8(%eax),%ebx
 2339              	.LBB198:
 2340              	.LBB199:
 2341              	.LBB200:
 2342              	.loc 6 702 0
 2343 0dd2 837B6400 	cmpl $0,100(%ebx)
 2344 0dd6 8BBBAC00 	movl 172(%ebx),%edi
 2344      0000
 2345 0ddc 7402     	je .L677
 2346              	.loc 6 759 0
 2347              	
 2348 0dde 0F0B     	ud2
 2349              	
 2350              	
 2351              	.L677:
 2352              	.loc 6 760 0
 2353 0de0 8B742428 	movl 40(%esp),%esi
 2354 0de4 8D0437   	leal (%edi,%esi),%eax
 2355              	.loc 6 761 0
 2356 0de7 017360   	addl %esi,96(%ebx)
 2357              	.loc 6 762 0
 2358 0dea 3B83B000 	cmpl 176(%ebx),%eax
 2358      0000
 2359              	.loc 6 760 0
GAS LISTING  			page 125


 2360 0df0 8983AC00 	movl %eax,172(%ebx)
 2360      0000
 2361              	.loc 6 762 0
 2362 0df6 7610     	jbe .L680
 2363              	.LBB201:
 2364              	.loc 6 763 0
 2365              	
 2366 0df8 B8FD0D00 	movl $1f,%eax
 2366      00
 2367              	1:
 2368              	
 2369              	.LBE201:
 2370 0dfd 50       	pushl %eax
 2371              	.LCFI154:
 2372 0dfe 56       	pushl %esi
 2373              	.LCFI155:
 2374 0dff 53       	pushl %ebx
 2375              	.LCFI156:
 2376 0e00 E8FCFFFF 	call skb_over_panic
 2376      FF
 2377 0e05 83C40C   	addl $12,%esp
 2378              	.LCFI157:
 2379              	.L680:
 2380              	.LBE200:
 2381              	.LBE199:
 2382              	.LBB202:
 2383              	.loc 8 207 0
 2384 0e08 8B4C2428 	movl 40(%esp),%ecx
 2385 0e0c C1E902   	shrl $2,%ecx
 2386 0e0f 8B742424 	movl 36(%esp),%esi
 2387              	
 2388 0e13 F3A5     	rep
 2389 0e15 8B4C2428 	movl 40(%esp),%ecx
 2390 0e19 83E103   	andl $3,%ecx
 2391 0e1c 7402     	jz 1f
 2392 0e1e F3A4     	rep
 2393              	1:
 2394              	
 2395              	.LBE202:
 2396              	.LBE198:
 554:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 
 555:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	memcpy(skb_put(skb_frag, len), frame, len);
 556:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 
 557:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	if (ieee->config &
 2397              	.loc 1 557 0
 2398 0e20 8B442420 	movl 32(%esp),%eax
 2399 0e24 F6805C06 	testb $3,1628(%eax)
 2399      000003
 2400 0e2b 7434     	je .L690
 2401              	.LBB203:
 2402              	.LBB204:
 2403              	.loc 6 702 0
 2404 0e2d 837B6400 	cmpl $0,100(%ebx)
 2405 0e31 7402     	je .L684
 2406              	.loc 6 759 0
 2407              	
 2408 0e33 0F0B     	ud2
GAS LISTING  			page 126


 2409              	
 2410              	
 2411              	.L684:
 2412              	.loc 6 760 0
 2413 0e35 8B83AC00 	movl 172(%ebx),%eax
 2413      0000
 2414 0e3b 83C004   	addl $4,%eax
 2415              	.loc 6 761 0
 2416 0e3e 83436004 	addl $4,96(%ebx)
 2417              	.loc 6 762 0
 2418 0e42 3B83B000 	cmpl 176(%ebx),%eax
 2418      0000
 2419              	.loc 6 760 0
 2420 0e48 8983AC00 	movl %eax,172(%ebx)
 2420      0000
 2421              	.loc 6 762 0
 2422 0e4e 7611     	jbe .L690
 2423              	.LBB205:
 2424              	.loc 6 763 0
 2425              	
 2426 0e50 B8550E00 	movl $1f,%eax
 2426      00
 2427              	1:
 2428              	
 2429              	.LBE205:
 2430 0e55 50       	pushl %eax
 2431              	.LCFI158:
 2432 0e56 6A04     	pushl $4
 2433              	.LCFI159:
 2434 0e58 53       	pushl %ebx
 2435              	.LCFI160:
 2436 0e59 E8FCFFFF 	call skb_over_panic
 2436      FF
 2437              	.L700:
 2438 0e5e 83C40C   	addl $12,%esp
 2439              	.LCFI161:
 2440              	.L644:
 2441              	.L690:
 2442              	.LBE204:
 2443              	.LBE203:
 558:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	    (CFG_IEEE80211_COMPUTE_FCS | CFG_IEEE80211_RESERVE_FCS))
 559:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		skb_put(skb_frag, 4);
 560:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 
 561:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c ****       success:
 562:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	spin_unlock_irqrestore(&ieee->lock, flags);
 2444              	.loc 1 562 0
 2445              	
 2446 0e61 FF742408 	pushl 8(%esp)
 2446      9D
 563:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 
 564:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	if (txb) {
 2447              	.loc 1 564 0
 2448              	
 2449 0e66 85ED     	testl %ebp,%ebp
 2450 0e68 742D     	je .L693
 565:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		if ((*ieee->hard_start_xmit) (txb, ieee->dev, priority) == 0) {
 2451              	.loc 1 565 0
GAS LISTING  			page 127


 2452 0e6a 6AFF     	pushl $-1
 2453              	.LCFI162:
 2454 0e6c 8B542424 	movl 36(%esp),%edx
 2455 0e70 FF32     	pushl (%edx)
 2456              	.LCFI163:
 2457 0e72 55       	pushl %ebp
 2458              	.LCFI164:
 2459 0e73 FF927807 	call *1912(%edx)
 2459      0000
 2460 0e79 83C40C   	addl $12,%esp
 2461              	.LCFI165:
 2462 0e7c 85C0     	testl %eax,%eax
 2463 0e7e 7510     	jne .L694
 566:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 			stats->tx_packets++;
 2464              	.loc 1 566 0
 2465 0e80 8B742404 	movl 4(%esp),%esi
 2466 0e84 FF4604   	incl 4(%esi)
 567:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 			stats->tx_bytes += txb->payload_size;
 2467              	.loc 1 567 0
 2468 0e87 0FB74506 	movzwl 6(%ebp),%eax
 2469 0e8b 01460C   	addl %eax,12(%esi)
 2470 0e8e EB07     	jmp .L693
 2471              	.L694:
 568:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 			return 0;
 569:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		}
 570:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 		ieee80211_txb_free(txb);
 2472              	.loc 1 570 0
 2473 0e90 55       	pushl %ebp
 2474              	.LCFI166:
 2475 0e91 E8FCFFFF 	call ieee80211_txb_free
 2475      FF
 2476 0e96 5E       	popl %esi
 2477              	.LCFI167:
 2478              	.L693:
 571:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	}
 572:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	return 0;
 2479              	.loc 1 572 0
 2480 0e97 31C0     	xorl %eax,%eax
 2481 0e99 EB23     	jmp .L639
 2482              	.L647:
 2483              	.L699:
 2484              	.loc 1 546 0
 2485 0e9b 8B442420 	movl 32(%esp),%eax
 2486 0e9f FF30     	pushl (%eax)
 2487              	.LCFI168:
 2488 0ea1 687E0000 	pushl $.LC4
 2488      00
 2489              	.LCFI169:
 2490 0ea6 E8FCFFFF 	call printk
 2490      FF
 2491              	.loc 1 548 0
 2492 0eab 59       	popl %ecx
 2493              	.LCFI170:
 2494 0eac 5B       	popl %ebx
 2495              	.LCFI171:
 573:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 
 574:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c ****       failed:
GAS LISTING  			page 128


 575:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	spin_unlock_irqrestore(&ieee->lock, flags);
 2496              	.loc 1 575 0
 2497              	
 2498 0ead FF742408 	pushl 8(%esp)
 2498      9D
 576:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	stats->tx_errors++;
 2499              	.loc 1 576 0
 2500              	
 2501 0eb2 8B542404 	movl 4(%esp),%edx
 2502 0eb6 FF4214   	incl 20(%edx)
 577:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** 	return 1;
 2503              	.loc 1 577 0
 2504 0eb9 B8010000 	movl $1,%eax
 2504      00
 2505              	.L639:
 578:/home/usuario/ipw3945install/ieee80211-1.1.12/ieee80211_tx.c **** }
 2506              	.loc 1 578 0
 2507 0ebe 83C40C   	addl $12,%esp
 2508 0ec1 5B       	popl %ebx
 2509 0ec2 5E       	popl %esi
 2510 0ec3 5F       	popl %edi
 2511 0ec4 5D       	popl %ebp
 2512 0ec5 C3       	ret
 2513              	.LFE927:
 2515              	.section __kcrctab,"a",@progbits
 2516              	.align 4
 2519              	__kcrctab_ieee80211_tx_frame:
 2520 0000 00000000 	.long __crc_ieee80211_tx_frame
 2521              	.section __ksymtab_strings,"a",@progbits
 2524              	__kstrtab_ieee80211_tx_frame:
 2525 0000 69656565 	.string "ieee80211_tx_frame"
 2525      38303231 
 2525      315F7478 
 2525      5F667261 
 2525      6D6500
 2526              	.section __ksymtab,"a",@progbits
 2527              	.align 4
 2530              	__ksymtab_ieee80211_tx_frame:
 2531 0000 00000000 	.long ieee80211_tx_frame
 2532 0004 00000000 	.long __kstrtab_ieee80211_tx_frame
 2533              	.section __kcrctab
 2534              	.align 4
 2537              	__kcrctab_ieee80211_txb_free:
 2538 0004 00000000 	.long __crc_ieee80211_txb_free
 2539              	.section __ksymtab_strings
 2542              	__kstrtab_ieee80211_txb_free:
 2543 0013 69656565 	.string "ieee80211_txb_free"
 2543      38303231 
 2543      315F7478 
 2543      625F6672 
 2543      656500
 2544              	.section __ksymtab
 2545              	.align 4
 2548              	__ksymtab_ieee80211_txb_free:
 2549 0008 00000000 	.long ieee80211_txb_free
 2550 000c 13000000 	.long __kstrtab_ieee80211_txb_free
 2551              	.weak __crc_ieee80211_txb_free
GAS LISTING  			page 129


 2552              	.weak __crc_ieee80211_tx_frame
 3739              	.Letext0:
 40047              	.ident "GCC: (GNU) 3.4.5 20050809 (prerelease) (Ubuntu 3.4.4-6ubuntu8.1)"
GAS LISTING  			page 130


DEFINED SYMBOLS
                            *ABS*:0000000000000000 ieee80211_tx.c
 {entrada estndar}:13     .data:0000000000000000 P802_1H_OUI
                             .bss:0000000000000000 RFC1042_OUI
 {entrada estndar}:21     .text:0000000000000000 ieee80211_copy_snap
 {entrada estndar}:87     .text:0000000000000055 ieee80211_encrypt_fragment
 {entrada estndar}:177    .text:00000000000000be ieee80211_txb_free
 {entrada estndar}:318    .text:0000000000000155 ieee80211_alloc_txb
 {entrada estndar}:574    .text:0000000000000267 ieee80211_xmit
 {entrada estndar}:2257   .text:0000000000000d43 ieee80211_tx_frame
 {entrada estndar}:2519   __kcrctab:0000000000000000 __kcrctab_ieee80211_tx_frame
 {entrada estndar}:2524   __ksymtab_strings:0000000000000000 __kstrtab_ieee80211_tx_frame
 {entrada estndar}:2530   __ksymtab:0000000000000000 __ksymtab_ieee80211_tx_frame
 {entrada estndar}:2537   __kcrctab:0000000000000004 __kcrctab_ieee80211_txb_free
 {entrada estndar}:2542   __ksymtab_strings:0000000000000013 __kstrtab_ieee80211_txb_free
 {entrada estndar}:2548   __ksymtab:0000000000000008 __ksymtab_ieee80211_txb_free

UNDEFINED SYMBOLS
printk
per_cpu__softnet_data
raise_softirq_irqoff
__kfree_skb
kfree
__kmalloc
alloc_skb
skb_over_panic
__crc_ieee80211_tx_frame
__crc_ieee80211_txb_free
