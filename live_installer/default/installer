#!/usr/bin/python

'''
Installer

This is a installer program for a Ubuntu or Metadistros Live system.
This is the main program, but there is also a couple of libraries to
help it to work. For example the frontends library.
The way it works is simple. It detect the Frontend to use, then
load the module for that frontend. After that, it makes some calls
through the frontend in order to get the info necessary to install.

Once it has the info, partitioning, format, copy de distro to the disk
and configure everything.
'''

import sys
import shutil
import os
import subprocess
import debconf

class CommandFailed(Exception): pass

class Installer:
    source = '/source'
    target = '/target'
    
    def get_locales(self):
      '''get_locales() -> timezone, keymap, locales

      Get the timezone, keymap and locales from the
      Debconf database and return them.
      '''
      debconf.runFrontEnd()
      db = debconf.Debconf()

      try:
        timezone = db.get('express/timezone')
        if timezone == '':
            timezone = db.get('tzconfig/choose_country_zone_multiple')
      except:
        timezone = open('/etc/timezone').readline().strip()
      keymap  = db.get('express/keymap')
      keymap_sec = db.get('debian-installer/keymap')
      if keymap != keymap_sec:
        keymap = keymap_sec
        
      locales = db.get('locales/default_environment_locale')
      return timezone, keymap, locales

    def frontend(self, type='noui'):
      '''frontend(type='noui') -> none
      
      Get the type of frontend to use and load the module for that.
      Get the locales stuff with get_locales() method and ask
      the hostname, fullname, username and  password through the
      selected frontend.
      After get everything call to the install() method.
      '''
      ui = getattr(__import__('frontend.%s' % type), type)

      timezone, keymap, locales = get_locales()
      self.wizard = ui.Wizard()
      hostname, fullname, username, password = self.wizard.get_info()

      self.install(timezone,keymap,locales,username,password,fullname,hostname)

    def install(self, timezone, keymap, locales, username, password, fullname, hostname):
        '''install(timezone, keymap, locales, username, password, fullname,
        hostname) -> none

        Here is all the logic of the program. After get the info from the
        frontend, the program do all it need to install the distro to the
        target(partitioning,formating,copy and postconfig).
        '''
	mountpoints = self.wizard.get_partitions()
        self.format_target(mountpoints)
        self.mount_target(mountpoints)
        self.mount_source()
        try:
            self.copy_all()
        finally:
            self.unmount_source()

        try:
            self.configure_fstab(mountpoints)
            self.configure_timezone(timezone)
            self.configure_keymap(keymap)
            self.configure_user(username, password, fullname)
            self.configure_hostname(hostname)
            self.configure_network()
            self.configure_hardware()
        finally:
            self.unmount_target(mountpoints)


    def configure_fstab(self, mountpoints):
        fstab = open(os.path.join(self.target,'etc/fstab'), 'w')
        for path, device in mountpoints.items():
            if path == '/':
                passno = 1
            else:
                passno = 2

            filesystem = 'ext3'
            options = 'defaults'
            
            print >>fstab, '%s\t%s\t%s\t%s\t%d\t%d' % (device, path, filesystem, options, 0, passno)
        fstab.close()

    def configure_timezone(self, timezone):
        # tzsetup ignores us if these exist
        for tzfile in ('etc/timezone', 'etc/localtime'):
            path = os.path.join(self.target, tzfile)
            if os.path.exists(path):
                os.unlink(path)

        self.set_debconf('base-config', 'tzconfig/preseed_zone', timezone)
        self.chrex('tzsetup', '-y')

    def configure_keymap(self, keymap):
        self.set_debconf('debian-installer', 'debian-installer/keymap', keymap)
        self.chrex('install-keymap', keymap)

    def configure_user(self, username, password, fullname):
        self.chrex('passwd', '-l', 'root')
        self.set_debconf('passwd', 'passwd/username', username)
        self.set_debconf('passwd', 'passwd/user-fullname', fullname)
        self.set_debconf('passwd', 'passwd/user-password', password)
        self.set_debconf('passwd', 'passwd/user-password-again', password)
        self.reconfigure('passwd')

    def configure_hostname(self, hostname):
        fp = open(os.path.join(self.target, 'etc/hostname'), 'w')
        print >>fp, hostname
        fp.close()

    def configure_hardware(self):
        self.chrex('mount', '-t', 'proc', 'proc', '/proc')
        self.chrex('mount', '-t', 'sysfs', 'sysfs', '/sys')

        kernel_version = open('/proc/sys/kernel/osrelease').readline().strip()
        packages = ['gnome-panel', 'xserver-xorg', 'linux-image-' + kernel_version]
        
        try:
            for package in packages:
                self.copy_debconf(package)
                self.reconfigure(package)
        finally:
            self.chrex('umount', '/proc')
            self.chrex('umount', '/sys')

    def configure_network(self):
        self.ex('/usr/share/setup-tool-backends/scripts/network-conf','--get',
        '>',self.target + '/tmp/network.xml')
        self.chex('/usr/share/setup-tool-backends/scripts/network-conf','--set',
        '<','/tmp/network.xml')
    
    def format_target(self, mountpoints):
        '''format_target(mountpoints) -> bool

        From mountpoints extract the devices to partition 
        and do it.
        The method return true or false depends the result
        of this operation.
        '''
        #FIXME: create this method
        pass
        
    def mount_target(self, mountpoints):
        os.mkdir(self.target)
        self.ex('mount', mountpoints['/'], self.target)

        for path, device in mountpoints.items():
            if path in ('/', 'swap'):
                continue
            path = os.path.join(self.target, path[1:])
            os.mkdir(path)
            self.ex('mount', device, path)

    def unmount_target(self, mountpoints):
        for path, device in mountpoints.items():
            if path in ('/', 'swap'):
                continue
            path = os.path.join(self.target, path[1:])
            self.ex('umount', path)
        self.ex('umount', self.target)

    def copy_all(self):
        files = []
        total_size = 0
        
        for dirpath, dirnames, filenames in os.walk(self.source):
            sourcepath = dirpath[len(self.source)+1:]

            for name in dirnames + filenames:
                relpath = os.path.join(sourcepath, name)
                fqpath = os.path.join(self.source, dirpath, name)

                if os.path.isfile(fqpath):
		    size = os.path.getsize(fqpath)
		    total_size += size	
                    files.append((relpath, size))
                else:
                    files.append((relpath, None))

        copy = subprocess.Popen(['cpio', '-d0mp', self.target],
                                cwd=self.source,
                                stdin=subprocess.PIPE)

        copied_bytes = 0
        for path, size in files:
            copy.stdin.write(path + '\0')
            if size is not None:
                copied_bytes += size
            per = (copied_bytes * 100) / total_size
            self.wizard.set_progress(per)

        copy.stdin.close()
        copy.wait()
        

    def mount_source(self):
	from os import path
	files = ['/cdrom/casper/filesystem.cloop', '/cdrom/META/META.squashfs']
	for f in files:
		if path.isfile(f) and path.splitext(f)[1] == '.cloop':
			file = f
			self.dev = '/dev/cloop1'
		elif path.isfile(f) and path.splitext(f)[1] == '.squashfs':
			file = f
			self.dev = '/dev/loop3'
		else:
                    return -1			

        self.ex('losetup', self.dev, file)
        os.mkdir(self.source)
        self.ex('mount', self.dev, self.source)
	return 0

    def unmount_source(self):
        self.ex('umount', self.source)
        self.ex('losetup', '-d', self.dev)

    def ex(self, *args):
        status = subprocess.call(args)
        if status != 0:
            raise CommandFailed(str(args))

    def chrex(self, *args):
        self.ex('chroot', self.target, *args)

    def copy_debconf(self, package):
        targetdb = os.path.join(self.target, 'var/cache/debconf/config.dat')
        self.ex('debconf-copydb', 'configdb', 'targetdb', '-p', '^%s/' % package,
                '--config=Name:targetdb', '--config=Driver:File','--config=Filename:' + targetdb)

    def set_debconf(self, owner, question, value):
        dccomm = subprocess.Popen(['chroot', self.target, 'debconf-communicate', '-fnoninteractive', owner],
                                  stdin=subprocess.PIPE, stdout=subprocess.PIPE, close_fds=True)
        dc = debconf.Debconf(read=dccomm.stdout, write=dccomm.stdin)
        dc.set(question, value)
        dc.fset(question, 'seen', 'true')
        dccomm.stdin.close()
        dccomm.wait()

    def reconfigure(self, package):
        self.chrex('dpkg-reconfigure', '-fnoninteractive', package)

if __name__ == '__main__':
    Installer().frontend()

# vim:ai:et:sts=4:tw=80:sw=4:
