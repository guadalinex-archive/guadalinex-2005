#!/usr/bin/python

'''
Installer

This is a installer program for a Ubuntu or Metadistros Live system.
This is the main program, but there is also a couple of libraries to
help it to work. For example the frontends library.
The way it works is simple. It detect the Frontend to use, then
load the module for that frontend. After that, it makes some calls
through the frontend in order to get the info necessary to install.

Once it has the info, partitioning, format, copy de distro to the disk
and configure everything.
'''

import sys
import shutil
import os
import subprocess
import debconf
import UE

class CommandFailed(Exception): pass

class Installer:
    source = '/source'
    target = '/target'
    
    def get_locales(self):
        '''get_locales() -> timezone, keymap, locales

        Get the timezone, keymap and locales from the
        Debconf database and return them.
        '''
        debconf.runFrontEnd()
        db = debconf.Debconf()

        # We get here the current kernel version
        self.kernel_version = open('/proc/sys/kernel/osrelease').readline().strip()
        
        try:
          timezone = db.get('express/timezone')
          if timezone == '':
              timezone = db.get('tzconfig/choose_country_zone_multiple')
        except:
          timezone = open('/etc/timezone').readline().strip()
        keymap = db.get('debian-installer/keymap')
          
        locales = db.get('locales/default_environment_locale')
        return timezone, keymap, locales

    def frontend(self, type='Gnome'):
        '''frontend(type='Gnome') -> none
        
        Get the type of frontend to use and load the module for that.
        Get the locales stuff with get_locales() method and ask
        the hostname, fullname, username and  password through the
        selected frontend.
        After get everything call to the install() method.
        '''
        mod = __import__('UE.frontend', globals(), locals() , [type])
        ui = getattr(mod, type)

        distro = os.listdir('/usr/share/ubuntu-express/htmldocs/')[0]
        self.wizard = ui.Wizard(distro)
        pid = os.fork()
        if pid == 0:
            self.wizard.run()
            print 'After run()'
        else:
            status = self.wizard.is_active()
            print status
            while status == False:
                status = self.wizard.is_active()
            print status
            print 'After while'
            self.install()

    def install(self):
        '''install() -> none

        Here is all the logic of the program. After get the info from the
        frontend, the program do all it need to install the distro to the
        target(partitioning,formating,copy and postconfig).
        '''
        timezone, keymap, locales = self.get_locales()
        hostname, fullname, username, password = self.wizard.get_info()
	mountpoints = self.wizard.get_partitions()
        #self.format_target(mountpoints)
        #self.mount_target(mountpoints)
        self.mount_source()
        try:
            self.copy_all()
        finally:
            self.unmount_source()

        try:
            self.configure_fstab(mountpoints)
            self.configure_timezone(timezone)
            self.configure_keymap(keymap)
            self.configure_user(username, password, fullname)
            self.configure_hostname(hostname)
            self.configure_network()
            #self.configure_bootloader(mountpoints['/'])
            self.configure_hardware()
        finally:
            #self.unmount_target(mountpoints)
            pass


    def configure_fstab(self, mountpoints):
        fstab = open(os.path.join(self.target,'etc/fstab'), 'w')
        for path, device in mountpoints.items():
            if path == '/':
                passno = 1
            else:
                passno = 2

            filesystem = 'ext3'
            options = 'defaults'
            
            print >>fstab, '%s\t%s\t%s\t%s\t%d\t%d' % (device, path, filesystem, options, 0, passno)
        fstab.close()

    def configure_timezone(self, timezone):
        # tzsetup ignores us if these exist
        for tzfile in ('etc/timezone', 'etc/localtime'):
            path = os.path.join(self.target, tzfile)
            if os.path.exists(path):
                os.unlink(path)

        self.set_debconf('base-config', 'tzconfig/preseed_zone', timezone)
        self.chrex('tzsetup', '-y')

    def configure_keymap(self, keymap):
        self.set_debconf('debian-installer', 'debian-installer/keymap', keymap)
        self.chrex('install-keymap', keymap)

    def configure_user(self, username, password, fullname):
        self.chrex('passwd', '-l', 'root')
        self.set_debconf('passwd', 'passwd/username', username)
        self.set_debconf('passwd', 'passwd/user-fullname', fullname)
        self.set_debconf('passwd', 'passwd/user-password', password)
        self.set_debconf('passwd', 'passwd/user-password-again', password)
        self.reconfigure('passwd')

    def configure_hostname(self, hostname):
        fp = open(os.path.join(self.target, 'etc/hostname'), 'w')
        print >>fp, hostname
        fp.close()

    def configure_hardware(self):
        self.chrex('mount', '-t', 'proc', 'proc', '/proc')
        self.chrex('mount', '-t', 'sysfs', 'sysfs', '/sys')

        packages = ['gnome-panel', 'xserver-xorg', 'linux-image-' + self.kernel_version]
        
        try:
            for package in packages:
                self.copy_debconf(package)
                self.reconfigure(package)
        finally:
            self.chrex('umount', '/proc')
            self.chrex('umount', '/sys')

    def configure_network(self):
        self.ex('/usr/share/setup-tool-backends/scripts/network-conf','--get',
        '>',self.target + '/tmp/network.xml')
        self.chex('/usr/share/setup-tool-backends/scripts/network-conf','--set',
        '<','/tmp/network.xml')
    
    def configure_bootloader(self, target_dev):
        # Copying the old boot config
        files = ['/etc/lilo.conf', '/boot/grub/menu.lst','/etc/grub.conf',
                 '/boot/grub/grub.conf']
        TEST = '/mnt/test/'
        grub_dev = misc.grub_dev(target_dev)
        proc_file = open('/proc/partitions').readlines()
        parts = []

        for entry in proc_file[2:]:
            dev = entry.split()
            if len(dev[3]) == 4:
                parts.append(dev[3])
        self.ex('mkdir', TEST)
        for part in parts:
            if self.ex('mount', '/dev/' + part , TEST):
                for file in files:
                    if os.path.exists(TEST + file):
                        self.ex('cp', TEST + file, self.target + file)
                        
                self.ex('umount', TEST)

        # The new boot
        self.chex('/usr/sbin/mkinitrd')
        # For the Grub
        grub_conf = open(self.target + '/boot/grub/menu.lst', 'a')
        grub_conf.write('''
title %s
root (%s)
kernel (%s)/vmlinuz-%s root=%s ro vga=791 quiet
initrd (%s)/initrd.img-%s
savedefault
boot

''' % ('Ubuntu', grub_dev, grub_dev, self.kernel_version, target_dev, 
        grub_dev, self.kernel_version) )
    
        self.ex('/usr/share/setup-tool-backends/scripts/boot-conf','--get',
        '>',self.target + '/tmp/boot.xml')
        self.chex('/usr/share/setup-tool-backends/scripts/boot-conf','--set',
        '<','/tmp/boot.xml')

    def format_target(self, mountpoints):
        '''format_target(mountpoints) -> bool

        From mountpoints extract the devices to partition 
        and do it.
        The method return true or false depends the result
        of this operation.
        '''
        for path, device in mountpoints.items():
            if path in ['/']:
                try:
                    self.ex('mkfs.ext3','device')
                except:
                    return False
            elif path == 'swap':
                try:
                    self.ex('mkswap','device')
                except:
                    return False
        return True
        
    def mount_target(self, mountpoints):
        if not os.path.isdir(self.target):
            os.mkdir(self.target)
        self.ex('mount', mountpoints['/'], self.target)

        for path, device in mountpoints.items():
            if path in ('/', 'swap'):
                continue
            path = os.path.join(self.target, path[1:])
            os.mkdir(path)
            self.ex('mount', device, path)

    def unmount_target(self, mountpoints):
        for path, device in mountpoints.items():
            if path in ('/', 'swap'):
                continue
            path = os.path.join(self.target, path[1:])
            self.ex('umount', path)
        self.ex('umount', self.target)

    def copy_all(self):
        files = []
        total_size = 0
        
        for dirpath, dirnames, filenames in os.walk(self.source):
            sourcepath = dirpath[len(self.source)+1:]

            for name in dirnames + filenames:
                relpath = os.path.join(sourcepath, name)
                fqpath = os.path.join(self.source, dirpath, name)

                if os.path.isfile(fqpath):
		    size = os.path.getsize(fqpath)
		    total_size += size	
                    files.append((relpath, size))
                else:
                    files.append((relpath, None))

        copy = subprocess.Popen(['cpio', '-d0mp', self.target],
                                cwd=self.source,
                                stdin=subprocess.PIPE)

        copied_bytes = 0
        for path, size in files:
            copy.stdin.write(path + '\0')
            if size is not None:
                copied_bytes += size
            per = (copied_bytes * 100) / total_size
            self.wizard.set_progress(per)

        copy.stdin.close()
        copy.wait()
        

    def mount_source(self):
	from os import path
	files = ['/cdrom/casper/filesystem.cloop', '/cdrom/META/META.squashfs']
	for f in files:
		if path.isfile(f) and path.splitext(f)[1] == '.cloop':
			file = f
			self.dev = '/dev/cloop1'
		elif path.isfile(f) and path.splitext(f)[1] == '.squashfs':
			file = f
			self.dev = '/dev/loop3'
		else:
                    return -1			

        self.ex('losetup', self.dev, file)
        os.mkdir(self.source)
        self.ex('mount', self.dev, self.source)
	return 0

    def unmount_source(self):
        self.ex('umount', self.source)
        self.ex('losetup', '-d', self.dev)

    def ex(self, *args):
        status = subprocess.call(args)
        if status != 0:
            raise CommandFailed(str(args))
        return 0

    def chrex(self, *args):
        self.ex('chroot', self.target, *args)

    def copy_debconf(self, package):
        targetdb = os.path.join(self.target, 'var/cache/debconf/config.dat')
        self.ex('debconf-copydb', 'configdb', 'targetdb', '-p', '^%s/' % package,
                '--config=Name:targetdb', '--config=Driver:File','--config=Filename:' + targetdb)

    def set_debconf(self, owner, question, value):
        dccomm = subprocess.Popen(['chroot', self.target, 'debconf-communicate', '-fnoninteractive', owner],
                                  stdin=subprocess.PIPE, stdout=subprocess.PIPE, close_fds=True)
        dc = debconf.Debconf(read=dccomm.stdout, write=dccomm.stdin)
        dc.set(question, value)
        dc.fset(question, 'seen', 'true')
        dccomm.stdin.close()
        dccomm.wait()

    def reconfigure(self, package):
        self.chrex('dpkg-reconfigure', '-fnoninteractive', package)

if __name__ == '__main__':
    Installer().frontend()

# vim:ai:et:sts=4:tw=80:sw=4:
